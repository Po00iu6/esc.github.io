<!DOCTYPE html>

<html lang="zh-CN">
<head><link href="../pwd.css" rel="stylesheet" type="text/css"/>
<meta charset="utf-8"/>
<meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible"/>
<link href="../../../sqhgxsq/next/Material/logo.png" rel="apple-touch-icon"/>
<link href="https://ys.mihoyo.com/main/favicon.ico" rel="icon" type="image/x-icon"/>
<link href="https://ys.mihoyo.com/main/favicon.ico" rel="shortcut icon" type="image/x-icon"/>
<meta content="webkit" name="renderer"/>
<meta content="https://fastcdn.mihoyo.com/static-resource-v2/2023/12/20/e04bc0be964b4fc7056bc1128b35f200_4546122273706382871.png" property="og:image"/>
<meta content="yes" name="apple-mobile-web-app-capable"/>
<meta content="black" name="apple-mobile-web-app-status-bar-style"/>
<meta content="telephone=no,email=no,adress=no" name="format-detection"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/>
<meta content="OIer的错题集,ESC,ESC.html" name="keywords"/>
<meta content="OIer的错题集,ESC,ESC.html" name="description"/>
<!-- bing sitmap system -->
<meta content="E636B33C63F884A1E40D913638E2424B" name="msvalidate.01">
<!-- -->
<title>错题集</title>
<link href="../style.css" rel="stylesheet"/>
<!-- -->
<style>
        @media screen and (max-width:600px) {
            .bg1{
        background-image: url("https://act-webstatic.mihoyo.com/event-static/2023/12/20/3e86d5a644ce40d2778f6022bab0aefa_3709066284567295672.jpg?x-oss-process=image/quality,Q_80/resize,m_lfit,s_700");
            }
        }
        @media screen and (min-width:601px){
            .bg1{
        background-image: url("https://act-webstatic.mihoyo.com/event-static/2023/12/20/92836dbf7e557f52b6d805217f66f4d6_3267077969577797231.jpg?x-oss-process=image/quality,Q_80/resize,m_lfit,s_700");
    }
        }
    </style>
<!-- -->
</meta></head>
<body>
<header id="_header">
<!-- <div class="ph" id="h_1" onclick="window.open('./index.html')">
            NOI
        </div> -->
<!-- <div class="ph" id="h_2" onclick="window.open('./PH.html')">
            物理
        </div> -->
<!-- <div class="ph" id="h_3" onclick="window.open('./CM.html')">
            化学
        </div> -->
<!-- <div class="ph" id="h_4" onclick="window.open('./BO.html')">
            生物
        </div> -->
<!-- <div class="ph" id="h_5" onclick="window.open('https://oi-wiki.org/')">
            OIWiki
        </div> -->
</header>
<!-- -->
<audio autoplay="" id="dd" src="https://static-mp-54c94446-e6a2-431f-84c4-ed0d181ae263.next.bspapp.com/music/MoonHalo.mp3" style="display: none;"></audio>
<!-- -->
<div class="bg1"></div>
<div class="bg2"></div>
<div class="bg3"></div>
<div class="bg4"></div>
<div class="bg5"></div>
<div class="bg6"></div>
<div class="bg7"></div>
<div class="bg8"></div>
<!-- -->
<div class="op">
<h1>下拉查看OI错题</h1>
</div>
<br/>
<h1>错题集</h1>
<br/>
<hr style="z-index: 1;"/>
<br/>
<!-- -->
<div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1345">1345：【例4-6】香甜的黄油</a>这道题我也是不会，要求用SPFA解决，反正不会，目前走一步看一步吧。<a href="https://blog.csdn.net/qq_42914633/article/details/98882991">题解</a></div>
<div class="t1">群友提供的Dijkstra算法的通解：<img alt="Dijkstra" src="https://upload-bbs.miyoushe.com/upload/2024/10/06/198629752/c6aebb59e6f1a42ec6bb8ba938758d66_7600648732841161930.jpg"/>目前我确实看不懂，后面再说吧。</div>
<div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1344">1344：【例4-4】最小花费</a>这道题属于是板子题了，我得背一下板子，否则后面真的学不下去。(因为前面啥板子都没背过，这个Dijkstra算法难写，没办法那就背吧。)<a href="https://blog.csdn.net/weixin_61017400/article/details/124343916">Dijkstra算法模板</a><p><a href="https://www.luogu.com.cn/training/444587#problems">Dijkstra算法刷题题单</a>我觉得这块还是得练练，要不然后面真不知道要怎么进行下去。</p></div>
<div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1343">1343：【例4-2】牛的旅行</a><p>这道题看了<a href="https://www.cnblogs.com/jzxnl/p/11397149.html">题解</a>，觉得很简单，但实际做起来发现结果居然不对，始终不知道哪错了。</p></div>
<div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1343">1343：【例4-2】牛的旅行</a>这道题还是求最短路，只不过是求整个牧场最短路当中最大的那个。</div>
<div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1342">1342：【例4-1】最短路径问题</a><p>这道题错的稀里糊涂，我也不知道为啥。第一次写的时候输出了个0.00，其实不是0，而是被省略了小数，这很显然是一个异常的答案。后来找到了原因，原来是memset初始化double类型的数组时不能用0x3f，具体原因见<a href="https://blog.csdn.net/PoPoQQQ/article/details/38926889">博文</a>，而应该赋值成0x7f，否则最终结果连0.1都不到。最后这道题我也是AC了。</p><br/><p><a href="https://blog.csdn.net/lq1990717/article/details/123321240#:~:text=%E8%AE%A2%E9%98%85%E4%B8%93%E6%A0%8F.%20%E3%80%90%E9%A2%98%E7%9B%AE%E9%93%BE">Floyed算法求最短路</a>可以说是最基础的了。</p></div>
<div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1375">1375：骑马修栅栏(fence)</a>记录欧拉路要在回溯阶段存储，否则会出现错误。另外，起始点不一定是1。题目中说“输出第一个数较小的”意思就是开始的节点度数最小，那么我们的最终代码就出来了：<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
int f,n;
int arr[2001],top=1;
int g[2001][2001],du[2001];
void dfs(int xi)
{
    for(int i=1;i&lt;=n;i++)
    {
        if(g[xi][i])
        {
            g[xi][i]--;g[i][xi]--; 
            dfs(i);
        }
    }
    arr[top++]=xi;<span>//回溯阶段存储路径</span>
}
int main()
{
    cin&gt;&gt;f;
    int start=0x3f3f3f3f;<span>//就像我说的，起始节点不一定是1，所以要初始时赋值为一个很大的数，后面找最小的节点编号。</span> 
    for(int i=1,x,y;i&lt;=f;i++)
    {
        cin&gt;&gt;x&gt;&gt;y;
        g[x][y]++;g[y][x]++;
        du[x]++;du[y]++;
        n=x&gt;n?x:n;<span>//找到最大的点的编号。</span>
        n=y&gt;n?y:n;
        start=start&lt;x?start:x;<span>//找到最小的点</span>
        start=start&lt;y?start:y;
    }
    for(int i=1;i&lt;=n;i++)
    {
        if(du[i]%2==1)
        {
            start=i;
            break;
        }
    }
    dfs(start);
    for(int i=top-1;i&gt;=1;i--)
    {<span>//到序输出</span>
        cout&lt;&lt;arr[i]&lt;&lt;endl;
    }
    return 0;
}
    </pre>说白了还是最基础的邻接矩阵存图，没什么难的，但要是不注意题目说的是啥，那就容易爆0。(当时我还在想500进制表示法是啥来着，但现在看来啥用也没有。)</div>
<div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1374">1374：铲雪车(snow)</a><p>看到这道题我第一时间想到的是建立一个图。结果当我看到<a href="https://blog.csdn.net/lq1990717/article/details/129891715#:~:text=%E9%93%B2%E9%9B%AA%E8%BD%A6%E5%8F%AF%E4%BB%A5%E5%9C%A8%E4%BB%BB%E6%84%8F%E4%BA%A4%E5%8F%89">题解</a>的时候立刻小脑萎缩。</p>致错原因：做题前没有充分分析题目。有些题目要用数学方法证明，如果能证明出来，那么题目会非常简单，但如果证明不出来，那么就只能模拟。但通常像这种题目，模拟难度往往很高。*我也不会模拟。</div>
<div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1341">1341：【例题】一笔画问题</a>致错原因：这是无向图，有度，没有入度和出度之分，直接用度就好了。使用邻接矩阵解决。<p><a href="https://blog.csdn.net/Wchenchen0/article/details/81283700">题解</a>仅供参考。</p>原本深入浅出的那本书上讲的挺好的，到这里怎么我的编程能力还退化了呢？</div>
<div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1372">1372：小明的账单</a>这道题挺简单，但要注意的是要对每个账单设置一个id，已经弹出的账单保证不再弹出。<a href="https://blog.csdn.net/lq1990717/article/details/128502439#:~:text=ybt%201372%EF%BC%9A%E5%B0%8F">题解</a>使用优先队列priority_queue可以快速完成。不建议使用多重集合multiset。</div>
<div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1371">1371：看病</a>这道题看似很简单，其实坑点一大堆。其中一个点还超时。<a href="https://blog.csdn.net/lq1990717/article/details/128490063#:~:text=1371%EF%BC%9A%E7%9C%8B%E7%97%85%20%E6%97%B6%E9%97%B4">题解</a></div>
<div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1370">1370：最小函数值(minval)</a><p>这道题不难，主要是刚开始读题可能会理解错，这道题的意思是对函数值排序，不是叫你对解出的x值排序。这是<a href="https://www.cnblogs.com/tflsnoi/p/14150443.html#:~:text=1370%EF%BC%9A%E6%9C%80%E5%B0%8F%E5%87%BD%E6%95%B0%E5%80%BC">题解</a></p></div>
<div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1373">1373：鱼塘钓鱼(fishing)</a><p>这道题挺难的，因为我不会。但是<a href="https://blog.csdn.net/Wchenchen0/article/details/81259412">题解</a>很好看。</p></div>
<div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1369">1369：合并果子(fruit)</a>哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈，我对了！我对了！<br/>我终于对了一道题了！！！哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈......<br/><b>需要注意的是，要分成函数写，否测会WA，不知道为啥，写成顺序结构会WA，但封装成函数就AC了(挠头~)。</b><p>*也可以直接用<code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt;</code>来解出答案。(也不知道比赛时叫不叫用)</p><pre>
#include &lt;iostream&gt;
using namespace std;
#define LL long long
LL n,a[30001],ans;
void swap(LL &amp;a,LL &amp;b)
{
    LL tmp=a;a=b;b=tmp;
}
void _init()
{
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;a[i];
        int p=i;
        while(p!=1)
        {
            if(a[p/2]&gt;a[p])
            {
                swap(a[p/2],a[p]);
            }
            else break;
            p=p/2;
        }
    }
}
void put(int x)
{
    a[++n]=x;int p=n;
    while(p!=1)
    {
        if(a[p/2]&gt;a[p])
        {
            swap(a[p/2],a[p]);
        }
        else break;
        p=p/2;
    }
}
int get()
{
    LL res=a[1];
    a[1]=a[n--];
    for(int i=1;i&lt;=n;i++)
    {
        int p=i;
        while(p!=1)
        {
            if(a[p/2]&gt;a[p])
            {
                swap(a[p/2],a[p]);
            }
            else break;
            p=p/2;
        }
    }
    return res;
}
int main()
{
    cin&gt;&gt;n;
    _init();
    while(1)
    {
        if(n==1)break;
        LL a=get();
        LL b=get();
        put(a+b);
        ans+=(a+b);
    }
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}
    </pre></div>
<div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1368">1368：对称二叉树(tree_c)</a>二叉树的题目好难啊，这道题还是不会。<a href="https://blog.csdn.net/lq1990717/article/details/127680193">题解</a></div>
<div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1367">1367：查找二叉树(tree_a)</a>致错原因：题目描述的问题，与我无瓜~，™也没说1号必须是根节点呀？<a href="https://blog.csdn.net/qq_39053800/article/details/108318606">题解</a>如此简单的一道题，我又双叒做错了。</div>
<div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1365">1365：FBI树(fbi)</a><p>这道题不会，我看的<a href="https://www.cnblogs.com/tflsnoi/p/14110703.html#:~:text=%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E7%AC%A8%E5%8A%9E%E6%B3%95%E5%BB%BA%E6%A3%B5%E6%A0%91">题解</a></p></div>
<div class="t1">使用cin、cout、string......时，一定要引入命名空间<code>using namespace std;</code></div>
<div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1363">1363：小球(drop)</a>这道题可以暴力遍历。<a href="https://www.cnblogs.com/sxrekord/p/small_ball.html#:~:text=1363%EF%BC%9A%E5%B0%8F%E7%90%83%20(d">题解</a>*然而我还傻傻模拟了一棵树。</div>
<div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1364">1364：二叉树遍历(flist)</a>这么简单的题也能错？我真的服了。致错原因：没有加if判断。<a href="https://www.cnblogs.com/sxrekord/p/binary_tree_traversal.html">题解</a>就只这两个if判断<pre>
if(p&gt;l)print(l,p-1);
if(p&lt;r)print(p+1,r);</pre>*函数名和题解的不一样。</div>
<div class="t1"><a href="http://ybt.ssoier.cn:8088/pic/1340.gif">1340：【例3-5】扩展二叉树</a>写的时候发现全错，但答案是对的，后来发现自己忘记把新创建的节点赋值为NULL，然后再判断要不要创建新节点。<br/>这是正确写法，重点标红：<pre>void crt(tree &amp;p)
{
    char x=getchar();
    <b style="color: red;">p=NULL;</b><span>//先赋值为NULL。</span>
    <b style="color: red;">if(x=='.')return;</b><span>//再看看要不要创建新的。</span>
    <b style="color: red;">p=new node;</b><span>//如果要，那么就创建新的。</span>
    p-&gt;l=NULL;p-&gt;r=NULL;
    p-&gt;data=x;
    crt(p-&gt;l);
    crt(p-&gt;r);
}</pre>如果反过来写虽然输出是对的，但判题机给我判错，我想可能是因为我没有把p赋值为NULL，导致输出时某些不可见字符被输出了出来导致错误。</div>
<div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1339">1339：【例3-4】求后序遍历</a>第一次就想写出来不就成了天才了？(自我安慰)<a href="https://blog.csdn.net/qq_39053800/article/details/108182882">题解</a>这是模板，后面学二叉树可能会用它来构造二叉树，需要背下来。</div>
<div class="t1">创建链表。<pre>struct node
{
    int data;<span>//数据。</span> 
    node *next,*pre;<span>//前指针、后指针。 </span>
};
node *head,*p,*r;<span>//创建头、中、尾指针。</span>  </pre></div>
<div class="t1">
链表新增以及移动的几个步骤：<br/>
1.申请新节点。<br/>
2.赋值数据。<br/>
3.当前节点的下一个置为NULL，前一个节点的下一个置为自己。<br/>
4.指针后移，即前一个变成自己。<br/>
<pre>
p=new node;
p-&gt;data=x;
p-&gt;next=NULL;
r-&gt;next=p;
r=p;
</pre>在此之前还需要<code>head=new node;<br/>r=head;</code>最后指针p归位<code>p=head-&gt;next;</code>
</div>
<div class="t1">二叉树的存储结构，可以用数组，也可以用指针。两种方式都差不多，总之就是模拟。<br/>这个是指针方式：<code>
typedef struct node;<br/>
typedef node *tree;<br/>
struct node<br/>
{<br/>
	  *tree lchild,rchild;<br/>
	  int data;<br/>
};<br/>
tree bt;<br/>
</code></div>
<!-- -->
<!-- -->
<!-- -->
</body>
<script src="../CanvasFor_index.js"></script>
<!-- <script src="./Canvas2.js"></script> -->
<script src="../Volume.js"></script>
<script src="../Unit.js"></script>
<script src="../ChangSpanColor.js"></script>
<script src="../a_blank.js"></script>
</html>