<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <link rel="apple-touch-icon" href="../../../sqhgxsq/next/Material/logo.png">
    <link rel="icon" href="https://ys.mihoyo.com/main/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="https://ys.mihoyo.com/main/favicon.ico" type="image/x-icon">
    <meta name="renderer" content="webkit">
    <meta property="og:image" content="https://fastcdn.mihoyo.com/static-resource-v2/2023/12/20/e04bc0be964b4fc7056bc1128b35f200_4546122273706382871.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="keywords" content="OIer的错题集,ESC,ESC.html">
    <meta name="description" content="OIer的错题集,ESC,ESC.html">

    <!-- bing sitmap system -->
    <meta name="msvalidate.01" content="E636B33C63F884A1E40D913638E2424B" />
    <!--  -->

    <title>错题集</title>

    <link rel="stylesheet" href="../style.css">

    <!--  -->
    <style>
        @media screen and (max-width:600px) {
            .bg1{
        background-image: url("https://act-webstatic.mihoyo.com/event-static/2024/04/24/89598a73795af7383311761ef2847a7c_2644644495778400050.jpg?x-oss-process=image/quality,Q_80/resize,m_lfit,s_700");
            }
        }
        @media screen and (min-width:601px){
            .bg1{
        background-image: url("https://act-webstatic.mihoyo.com/event-static/2024/04/24/e2f2f0ea955a2357b2263f1f181ae3eb_555140138046979500.jpg?x-oss-process=image/quality,Q_80/resize,m_lfit,s_700");
    }
        }
    </style>
    <!--  -->
</head>
<body>
    <header id="_header">
        <!-- <div class="ph" id="h_1" onclick="window.open('./index.html')">
            NOI
        </div> -->
        <!-- <div class="ph" id="h_2" onclick="window.open('./PH.html')">
            物理
        </div> -->
        <!-- <div class="ph" id="h_3" onclick="window.open('./CM.html')">
            化学
        </div> -->
        <!-- <div class="ph" id="h_4" onclick="window.open('./BO.html')">
            生物
        </div> -->
        <!-- <div class="ph" id="h_5" onclick="window.open('https://oi-wiki.org/')">
            OIWiki
        </div> -->
    </header>
    
    <!--  -->
    <audio src="https://static-mp-54c94446-e6a2-431f-84c4-ed0d181ae263.next.bspapp.com/music/pinKing.mp3" id="dd" autoplay loop style="display: none;"></audio>
    <!--  -->
    <div class="bg1"></div>
    <div class="bg2"></div>
    <div class="bg3"></div>
    <div class="bg4"></div>
    <div class="bg5"></div>
    <div class="bg6"></div>
    <div class="bg7"></div>
    <div class="bg8"></div>
    <!--  -->


    <div class="op">
        <h1>下拉查看OI错题</h1>
    </div>



    <br>
    <h1>错题集</h1>
    <br>
    <hr style="z-index: 1;">
    <br>
    <!--  -->
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1306">1306：最长公共子上升序列</a>据说这道题是一道模板题。总之我不会，就算是看了题解还是不会。<p><a href="https://blog.csdn.net/lq1990717/article/details/124222748">君义_noip</a>的题解第一个还写错了，也没看懂在写啥。</p><p><a href="https://www.cnblogs.com/-Ackerman/p/11232960.html#:~:text=%E5%A6%82%E6%9E%9C%E6%98%AF%E6%B1%82%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E4%B8%8B%E9%99%8D">-Ackermanの博客</a>的题解还算比较清晰，但没时间看了，暂时就过吧。</p></div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1305">1305：Maximum sum</a>这是一个动态规划之最大连续子段和问题。没学过，不会。<p><a href="https://blog.csdn.net/lq1990717/article/details/124162300#:~:text=%E8%A7%A3%E6%B3%951%EF%BC%9A%20%E8%A6%81%E5%9C%A8%E6%95%B4%E4%B8%AA%E5%BA%8F">题解</a>看的似懂非懂。</p></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1107">P1107 [BJWC2008] 雷涛的小猫</a>始终不知道自己哪错了，拿了80分，稀里糊涂看了题解。</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1304">1304：数的划分</a>信心都快要错没了。致错原因：没找对状态转移方程。<a href="https://developer.aliyun.com/article/1285630#:~:text=%E7%AE%80%E4%BB%8B%EF%BC%9A%201304%EF%BC%9A%E6%95%B0%E7%9A%84%E5%88%92%E5%88%86%20%E6%97%B6%E9%97%B4%E9%99%90%E5%88%B6%3A%201000%20ms%20%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6%3A%2065536%20KB,%E5%B0%86%E6%95%B4%E6%95%B0n%E5%88%86%E6%88%90k%E4%BB%BD%EF%BC%8C%E4%B8%94%E6%AF%8F%E4%BB%BD%E4%B8%8D%E8%83%BD%E4%B8%BA%E7%A9%BA%EF%BC%8C%E4%BB%BB%E6%84%8F%E4%B8%A4%E4%BB%BD%E4%B8%8D%E8%83%BD%E7%9B%B8%E5%90%8C%20%28%E4%B8%8D%E8%80%83%E8%99%91%E9%A1%BA%E5%BA%8F%29%E3%80%82%20%E4%BE%8B%E5%A6%82%EF%BC%9An%3D7%EF%BC%8Ck%3D3%EF%BC%8C%E4%B8%8B%E9%9D%A2%E4%B8%89%E7%A7%8D%E5%88%86%E6%B3%95%E8%A2%AB%E8%AE%A4%E4%B8%BA%E6%98%AF%E7%9B%B8%E5%90%8C%E7%9A%84%E3%80%82%201%EF%BC%8C1%EF%BC%8C5%EF%BC%9B%201%EF%BC%8C5%EF%BC%8C1%EF%BC%9B%205%EF%BC%8C1%EF%BC%8C1%EF%BC%9B%20%E9%97%AE%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E5%88%86%E6%B3%95%E3%80%82%20%E8%BE%93%E5%87%BA%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%EF%BC%8C%E5%8D%B3%E4%B8%8D%E5%90%8C%E7%9A%84%E5%88%86%E6%B3%95%E3%80%82">阿里云题解</a>这个题解还是蛮清晰的。</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1303">1303：鸣人的影分身</a>这道题不是很清楚，但为了时间，还是草草过了，后面遇到类似的题回来看看吧。<a href="https://blog.csdn.net/lq1990717/article/details/125285359#:~:text=%E6%88%91%E4%BB%AC%E7%9A%84%E4%B8%BB%E8%A7%92%E6%BC%A9%E6%B6%A1%E9%B8%A3%E4%BA%BA%E6%89%80">题解</a>题解写的也是一如既往的简单啊。为什么我就是想不出来呢?</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1302">1302：股票买卖</a>致错原因：数组忘记改名了，导致同一个数组用了2遍。<a href="https://blog.csdn.net/lq1990717/article/details/125284609#:~:text=%E8%AE%A2%E9%98%85%E4%B8%93%E6%A0%8F.%20%E3%80%90%E9%A2%98%E7%9B%AE%E9%93%BE">题解</a>我写的是解法一的优化版，下次忘了就回来看看。</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1301">1301：大盗阿福</a>常规做法会超时，必须优化。<a href="https://blog.csdn.net/weq2011/article/details/127170491#:~:text=%E9%98%BF%E7%A6%8F%E6%98%AF%E4%B8%80%E5%90%8D%E7%BB%8F%E9%AA%8C%E4%B8%B0%E5%AF%8C%E7%9A%84">题解</a>这个作者写的很全，有2种优化，1.一维数组+压缩循环。2.滚动数组+压缩循环。</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1300">1300：鸡蛋的硬度</a>很难想。<a href="https://blog.csdn.net/lq1990717/article/details/125259551">题解</a></div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1299">1299：糖果</a>致错原因：还是不会找状态转移方程。dp[i][j]表示取前i个数的余数为j时的最大值。<a href="https://blog.csdn.net/qq_40802813/article/details/123556631#:~:text=1299%EF%BC%9A%E7%B3%96%E6%9E%9C%20%E6%97%B6%E9%97%B4">题解</a></div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1297">1297：公共子序列</a>这道题和最长公共子序列那道题很像，但就是有一点点不一样，不知道为什么，竟然这都能AC？<pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
using namespace std;
string a,b;
int dp[501][501];
int f(string a,string b)
{
    memset(dp,0,sizeof(0));
    a=" "+a;
    b=" "+b;
    for(int i=1;i&lt;a.length();i++)
    {
        for(int j=1;j&lt;b.length();j++)
        {
            if(a[i]==b[j])
            {
                <span>//增加</span>
                dp[i][j]=dp[i-1][j-1]+1;
            }
            else
            {
                <span>//继承</span>
                dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
            }
        }
    }
    return dp[a.length()-1][b.length()-1];
}
int main()
{
    while(cin&gt;&gt;a&gt;&gt;b)
    {
        cout&lt;&lt;f(a,b)&lt;&lt;endl;
    }
    return 0;
}
    </pre>容易忽视的问题：当你在字符串前面加上空格时，字符串长度也会增加，因此ij不能循环到s.length()了，输出也不能输出到s.length()。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1434">P1434 [SHOI2002] 滑雪</a>这道题是动态规划+记忆化搜索。
    <pre>
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
using namespace std;
int r,c,a[201][201],maxn,dp[200][200];
int dir[4][2]={{1,0},{-1,0},{0,1},{0,-1}};
int dfs(int x,int y)
{
    <span>//如果来过，那么直接返回当前点出发的长度。就不需要再走一遍了。</span>
    if(dp[x][y])return dp[x][y];
    <span>//如果没来过，那么算上这个点，从这个点开始进行搜索。</span>
    dp[x][y]=1;
    for(int i=0;i&lt;4;i++)
    {
        int ux=x+dir[i][0],uy=y+dir[i][1];
        if(ux&gt;=1&&ux&lt;=r&&uy&gt;=1&&uy&lt;=c&&a[ux][uy]&lt;a[x][y])
        {
            dfs(ux,uy);
            dp[x][y]=max(dp[x][y],dp[ux][uy]+1);
        }
    }
    return dp[x][y];
}
int main()
{
    cin&gt;&gt;r&gt;&gt;c;
    for(int i=1;i&lt;=r;i++)
    {
        for(int j=1;j&lt;=c;j++)
        {
            cin&gt;&gt;a[i][j];
        }
    }
    for(int i=1;i&lt;=r;i++)
    {
        for(int j=1;j&lt;=c;j++)
        {
            maxn=max(maxn,dfs(i,j));
        }
    }
    cout&lt;&lt;maxn&lt;&lt;endl;
    return 0;
}
</pre>如果仅仅用记忆化搜索，那么只能拿90分，其中一个点超时。优化：如果你已经找到一条对于该点出发来说的最长路径，那么下次遇到这个点的时候就可以不用搜索，直接返回这条路径的长度即可，最后用这个长度加上你之前走过的长度就是当前点的答案。省下了大量时间。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1854">P1854 花店橱窗布置</a><p>这是一个不一样的动态规划，不会做，就看题解了。结果发现题解代码和<a href="https://www.luogu.com.cn/problem/P2066">P2066 机器分配</a>一模一样，可以去对比一下。</p>我觉得好的题解是这个<a href="https://blog.csdn.net/lq1990717/article/details/125213307">信息学奥赛一本通 1279：【例9.23】橱窗布置(flower) | 洛谷 P1854 花店橱窗布置</a></div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1278">1278：【例9.22】复制书稿(book)</a>这这道题很难，当时没做出来，就这样吧。
    <pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
using namespace std;
int m,k,a[1001],s[1001],dp[1001][1001];
void show(int t,int x)
{
    int i;
    int sum=0;
    if(t==0)return;
    for(i=t;i&gt;=1&&sum+a[i]&lt;=x;i--)
    {
        sum+=a[i];
    }
    show(i,x);
    cout&lt;&lt;i+1&lt;&lt;" "&lt;&lt;t&lt;&lt;endl;
}
int main()
{
    cin&gt;&gt;m&gt;&gt;k;
    for(int i=1;i&lt;=m;i++)
    {
        cin&gt;&gt;a[i];
        s[i]=a[i]+s[i-1];
    }
    memset(dp,0x3f,sizeof(dp));
    for(int i=1;i&lt;=m;i++)
    {
        dp[i][1]=s[i];
    }
    for(int i=1;i&lt;=m;i++)
    {//i表示抄写的人数。 
        for(int j=2;j&lt;=k;j++)
        {//前j本书分配给i个人抄写。 
            for(int h=j;h&lt;=i;h++)
            {//最后一个人需要抄写h~i本书。 
                dp[i][j]=min(dp[i][j],max(dp[h-1][j-1],s[i]-s[h-1]));
            }
        }
    }
    show(m,dp[m][k]);
    return 0;
}
</pre>
</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1004">P1004 [NOIP2000 提高组] 方格取数</a>因为是2个人走，所以要用4维数组，dp[i][j][k][p]，ij表示第一个人走的，kp表示第二个人走的。
    <pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
using namespace std;
#define LL long long
LL n,a[40][40],ans,dp[11][11][11][11];
void print()
{
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=n;j++)
        {
            cout&lt;&lt;a[i][j]&lt;&lt;" ";
        }cout&lt;&lt;endl;
    }cout&lt;&lt;endl;
}
LL max(LL a,LL b)
{
    return a&gt;b?a:b;
}
void f()
{
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=n;j++)
        {
            for(int k=1;k&lt;=n;k++)
            {
                for(int p=1;p&lt;=n;p++)
                {
                    dp[i][j][k][p]=max(dp[i-1][j][k-1][p],max(dp[i][j-1][k][p-1],max(dp[i-1][j][k][p-1],dp[i][j-1][k-1][p])))+a[i][j];
                    if(i!=k&&j!=p)<span>//如果第一个人没走过，那第二个人就走过来。</span>
                    {
                        dp[i][j][k][p]+=a[k][p];
                    }	
                }
            }
        }
    }
    ans=dp[n][n][n][n];
}
int main()
{
    cin&gt;&gt;n;
    LL x,y,v;
    while(cin&gt;&gt;x&gt;&gt;y&gt;&gt;v&&(x!=0||y!=0||v!=0))
    {
        a[x][y]=v;
    }
    f();
    cout&lt;&lt;ans&lt;&lt;endl;
}
    </pre>当时情况没有考虑周全，导致暴力求解WA了2个点。暴力做法的代码在这里了<a href="https://www.luogu.com.cn/record/179790417">暴力代码</a>
    </div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P2758">P2758 编辑距离</a>确定状态，转移方程，注意边界条件。<br>致错原因：未处理边界。
    <pre>
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
using namespace std;
int dp[2001][2001];
string a,b;
int main()
{
    cin&gt;&gt;a&gt;&gt;b;
    a=" "+a;b=" "+b;
    <b style="color: red;">for(int i=1;i&lt;=a.length();i++)
    {<span>//当其中一个串为0时，最小操作次数就是不为零的那个串的长度咯！</span>
        dp[i][0]=i;
    }
    for(int i=1;i&lt;=b.length();i++)
    {
        dp[0][i]=i;
    }</b>
    for(int i=1;i&lt;=a.length();i++)
    {
        for(int j=1;j&lt;=b.length();j++)
        {
            if(a[i]==b[j])dp[i][j]=dp[i-1][j-1];
            else
            {
                <span>//我可以增删改三选一，三选一找最小值。</span>
                dp[i][j]=min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]))+1;
            }
        }
    }
    cout&lt;&lt;dp[a.length()][b.length()]&lt;&lt;endl;
    return 0;
}
    </pre>
    </div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1275">1275：【例9.19】乘积最大</a>像这种动态规划的题目不要用瞪眼法，瞪眼法看不出来的，需要先用小数据枚举，找规律，找状态转移方程。<br>致错原因：区间定义错误。</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1274">1274：【例9.18】合并石子</a>状态转移方程，dp[i][j]表示从第i堆石子到第j堆石子合并的最小价值。</div>
    <div class="t1">二维数组最大开5000*5000，否则可能出现MLE的情况。如果数据范围拿不准，就用vector吧。</div>
    <div class="t1">
        各个数据类型大小(单位字节Byte,B)：<br>short 2<br>int 4<br>long 4<br>long long 8<br>char 1<br>double 8<br><br>1MB=1024kb=1024*1024B。
    </div>
    <div class="t1">循环边界再检查一遍。看看变量名是否与上文重合了。</div>
    <div class="t1">有些题目需要对某些情况特判。</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1293">1293：买书</a>错误原因：没有看清条件。</div>
    <div class="t1">
        <a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1296">1296：开餐馆</a>
        致错原因：ans最大值更新时放在了if语句内，导致更新失败而爆0。
        <pre>
int ans=dp[1];
for(int i=1;i&lt;=n;i++)
{
    for(int j=1;j&lt;i;j++)
    {
        if(m[i]-m[j]&gt;k)
        {
            dp[i]=max(dp[i],dp[j]+p[i]);
        }
        <b style="color: red;">ans=max(ans,dp[i]);</b>//&lt;------- 应该是在这，之前写到上边括号里头了。
    }
}
cout&lt;&lt;ans&lt;&lt;endl;
        </pre>
    </div>
    <div class="t1">经常忘记题目叫输出的是啥，比如叫你求最大值，而且输出格式是“max=最大值”，结果我只输出了最大值，那么全0分。</div>

    <div class="t1">01背包：每种物品只选一次。(逆推)<code>二维：dp[i][j]=max(dp[i-1][j],dp<b style="color: rgb(255, 79, 188);">[i-1]</b>[j-w[i]]+c[i])<br>一维：dp[j]=max(dp[j],dp[j-w[i]]+c[i])</code><br>完全背包：每种物品数量无限。(顺推)<code><p>二维：dp[i][j]=max(dp[i-1][j],dp<b style="color: rgb(255, 79, 188);">[i]</b>[j-w[i]]+c[i])<br>一维：dp[j]=max(dp[j],dp[j-w[i]]+c[i]);</p></code><br>多重背包：每种物品数量有限。(二维可顺可逆，一维要逆推)<br><code><p>二维：dp[i][j]=max(dp[i][j],dp<b style="color: rgb(255, 79, 188);">[i-1]</b>[j-k*w[i]]+k*c[i]);<br>一维：dp[j]=max(dp[j],dp[j-k*v[i]]+k*w[i]);</p></code></p><br>混合背包：遍历物品的时候加个判断就好，物品只有一个那就是01背包，无限就是完全背包，有穷就是多重背包。其他都不变。<br><br>二维费用问题：普通背包的基础上再加一个状态就好，状态的最小值设为0或1。<br><br>分组背包：普通背包问题的基础上最内层多加一个遍历每组的物品个数就好了，可以用vector储存每组的物品信息。<br><br>有依赖的背包问题：需要建树。<br><br>背包问题的方案总数：递推，f[0]=1，普通背包基础上，往下推即可。<br><br>**01背包dp[i][j]的意思是，考虑前i个物品且背包容量为j的情况下能够获得的最大价值。当优化成一维dp[i]时，表示考虑前i件物品能达到的最大价值。<br>**完全背包：含义与01背包相同，只不过第i种物品可以取无数次。<br><br>*背包的数组优化，仅仅在空间上进行了优化。</div>

    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1271">1271：【例9.15】潜水员</a>二维费用问题的典型题目，代码如下：
        <pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
int m,n,s,a[1001],b[1001],c[1001],dp[1001][1001];
int main()
{
    cin&gt;&gt;m&gt;&gt;n&gt;&gt;s;
    for(int i=1;i&lt;=s;i++)
    {
        cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i];
    }
    memset(dp,0x3f,sizeof(dp));
    dp[0][0]=0;//都不放的时候就是0。 
    for(int i=1;i&lt;=s;i++)
    {
        for(int j=m;j&gt;=0;j--)
        {//枚举氧气 
            for(int k=n;k&gt;=0;k--)
            {//枚举氮气 
                //氧气限度不能低于0，如果低于0代表超了。 
                dp[j][k]=min(dp[j][k],dp[max(0,j-a[i])][max(0,k-b[i])]+c[i]);
            }
        }
    }
    cout&lt;&lt;dp[m][n]&lt;&lt;endl;
    return 0;
}
        </pre>
    </div>

    <div class="t1">Linux主要命令，一定要熟练掌握，否则赛场两眼一摸黑。<br><br><p><code>mkdir</code>：创建文件夹。</p><p><code>touch</code>：创建文件。</p><p><code>cd</code>：切换目录。</p><p><code>ls</code>：列出当前文件夹下的内容。</p><p><code>cat</code>：显示文件内容，而且是全部显示。</p><p><code>more</code>：查看文件内容，但是翻页查看。</p><p><code>cp [-r] [被复制] [复制到哪]</code>：复制文件文件夹，参数<code>-r</code>可以复制文件夹。</p><p><code>mv [被移动] [目的地]</code>：移动文件文件夹。</p><p><code>rm [-r -f] [参数1......参数n]</code>：删除文件，<code>-r</code>删除文件夹，<code>-f</code>强制删除。</p></div>

    <div class="t1"><p>对拍时使用<code>rand()</code>函数生成伪随机数的方法。</p><p>头文件是<code>#include &lt;cstdlib&gt;</code></p>接下来是代码：
        <pre>
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cstdlib&gt;

int getRand(int min, int max) {
    return (rand() % (max - min + 1)) + min;
}

int main() {
    srand(time(0)); // 使用当前时间作为种子
    for (int i = 0; i &lt; 10; i++) {
        int r = getRand(2, 20); // 生成2到20之间的随机整数
        std::cout &lt;&lt; r &lt;&lt; std::endl;
    }
    return 0;
}
        </pre>
        建议写一个自己的解题代码，再写一个暴力的代码，之后再写一个随机数生成数据的代码。<br><br>即，用随机数生成数据，然后用暴力算法测试数据答案，最后用自己的解题代码测试答案与暴力解法是否相等，如果不相等，说明代码存在漏洞。
    </div>
    
    <div class="t1"><b>别忘了加上文件读写。</b><p>文件读写的头文件是<code>#include &lt;cstdio&gt;</code>。</p>开头加上这句<code>freopen("demo.in","r",stdin);<br>freopen("demo.out","w",stdout);</code>否则等着爆0。<br>结尾建议加上这句<code>fclose(stdin);<br>fclose(stdout);</code></div>

    <div class="t1">调试的那些打印语句别忘了注释掉！否则0分等着你！</div>
    <div class="t1">
        二维数组求“最大连续子矩阵和”的解法：<br><br>
        <b>暴力解法：</b>6层循环即可，外两层是左上角，中间两层是右下角，内两层是枚举累加左上到右下的和。<br><br>
        <b>优化解法1：一维前缀和优化</b>
        跟一维数组求“最大连续子区间”的优化解法是一样的，只不过把<code>w[i]=w[i-1]+a[i];</code>改成了<code>w[i][j]=w[i][j-1]+a[i][j]</code>然后对循环以及部分内容稍微改动就完事了。<br><br>
        <b>优化解法2：二维前缀和优化</b>
        <pre>
#include &lt;iostream&gt;
using namespace std;
int n,a[10001][10001],w[10001][10001],maxn=-0x3f3f3f3f;
//maxn建议赋值为负数，因为矩阵当中可能会出现负的数。
int main()
{
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=n;j++)
        {
            cin&gt;&gt;a[i][j];
            w[i][j]=w[i-1][j]+w[i][j-1]+a[i][j]-w[i-1][j-1];
        }
    }
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=n;j++)
        {//------枚举左上角--------

            for(int k=i;k&lt;=n;k++)
            {
                for(int t=j;t&lt;=n;t++)
                {//--------枚举右下角---------

                    int sum=w[k][t]-w[k][j-1]-w[i-1][t]+w[i-1][j-1];
                    maxn=maxn&gt;sum?maxn:sum;

                }
            }

        }
    }
    cout&lt;&lt;maxn&lt;&lt;endl;
    return 0;
}
        </pre>
        图解：
        <img src="https://upload-bbs.miyoushe.com/upload/2024/09/30/198629752/bbf70b405981e8ae02468e701a216a77_3706323876176022470.png" alt="矩阵图解">如图，我们的二维前缀和优化相当于求(i-1,j-1)到(k,t)之间的前缀和。也就是我用红色线条画的那部分。那么那部分的前缀和sum就等于我用w[k][t]减去(区1+区2+区3)的前缀和，那么公式也就是<code>sum=w[k][t]-(w[k][j-1]-w[i-1][j-1])+(w[i-1][t]-w[i-1][j-1])+w[i-1][j-1];</code>最后化简后就成了这样子：<code>sum=w[k][t]-w[k][j-1]-w[i-1][t]+w[i-1][j-1];</code><br><p>*这也就是<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1282">1282：最大子矩阵</a>的解法</p>（这道题妥妥模板题。我还硬啃了2小时，艹！）
    </div>

    <div class="t1">
        一维数组求“最大连续子序列和”的解法：
        <br><b>优化解法1：（递推）</b>
        <pre>
#include &lt;iostream&gt;
using namespace std;
int n,a[10001],maxn;
int main()
{
    cin&gt;n;
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;a[i];
    }
    //-----------------------
    for(int i=1;i&lt;=n;i++)
    {
        int sum=0;
        for(int j=i;j&lt;=n;j++)
        {
            sum+=a[j];
            maxn=sum&gt;maxn?sum:maxn;
        }
    }
    //----------------------
    cout&lt;&lt;maxn&lt;&lt;endl;
    return 0;
}
    </pre>
    两个注释线夹着的循环可以改为这种写法：（最朴素的解法）
    <pre>
for(int i=1;i<=n;i++)
{
    for(int j=i;j<=n;j++)
    {
        int sum=0;
        for(int k=i;k<=j;k++)
        {
            sum+=a[k];
        }
        maxn=sum>maxn?sum:maxn;
    }
}
    </pre>
    这两种是等价的，但前者能少一个循环。
    <br><b>优化解法2：利用前缀和求区间和</b>
    <pre>
#include &lt;iostream&gt;
using namespace std;
int n,a[10001],maxn,w[10001];
int main()
{
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;a[i];
        w[i]=w[i-1]+a[i];
    }
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=i;j&lt;=n;j++)
        {
            maxn=maxn&gt;(w[j]-w[i-1])?maxn:(w[j]-w[i-1]);
        }
    }
    cout&lt;&lt;maxn&lt;&lt;endl;
    return 0;
}
    </pre>
    这里用w数组在输入的时候就顺带把前缀和全都求出来了，然后要求出某个区间的前缀和，那就用区间的右端点的前缀和与左端点的前缀和相加就能得到答案。(但要注意左端点的头也得算在内，要i-1)。如图解：
    <img src="https://upload-bbs.miyoushe.com/upload/2024/09/30/198629752/175dac2c567043cd0c76c462fa3e903c_1093202781834302723.png" alt="区间图解">
    <br>
    一维和二维的处理方式有点不一样，见参考：<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1282">1282：最大子矩阵</a>
    </div>

    <div class="t1"><b>二维前缀和的计算方法</b><br>在二维数组中，我们首先定义一个同等大小的二维数组dp，其中dp[i][j]表示从原数组左上角(1,1)到(i,j)形成的子矩阵的元素和。计算dp[i][j]的状态转移方程如下：
<code>dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + arr[i][j];</code>
    <b>*即，自身前缀和=左+上+自身-左上。</b>
    </div>

    <div class="t1">动态规划+最优路径典中典的题目，这道题实在是太典了，建议记住。<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1266">1266：【例9.10】机器分配</a>
    <pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
using namespace std;
int n,m;
int a[10001][10001];
int dp[10001][10001];
int vis[10001][10001];
void print(int x,int y)
{
    if(x==0)return;
    print(x-1,y-vis[x][y]);
    cout&lt;&lt;x&lt;&lt;" "&lt;&lt;vis[x][y]&lt;&lt;endl;
}
int main()
{
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=m;j++)
        {
            cin&gt;&gt;a[i][j];
        }
    }
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=m;j++)
        {
            for(int k=0;k&lt;=j;k++)
            {
                if(dp[i-1][j-k]+a[i][k]&gt;=dp[i][j])
                {
                    dp[i][j]=dp[i-1][j-k]+a[i][k];
                    vis[i][j]=k;
                }
            }
        }
    }
    cout&lt;&lt;dp[n][m]&lt;&lt;endl;
    print(n,m);
    return 0;
}
    </pre>
    这是一个三重循环的动态规划，i外层代表当前公司，j代表要选的机器数，k代表还剩几台机器能够选。最后vis[i][j]记录公司选的机器数k，然后递归打印公司x和机器数vis[x][y]。
    </div>
    <!--  -->
    <!--  -->
    <!--  -->
</body>
<script src="../CanvasFor_index.js"></script>
<!-- <script src="./Canvas2.js"></script> -->
<script src="../Volume.js"></script>
<script src="../Unit.js"></script>
<script src="../ChangSpanColor.js"></script>
<script src="../a_blank.js"></script>
</html>