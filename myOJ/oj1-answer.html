<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <link rel="apple-touch-icon" href="../../../sqhgxsq/next/Material/logo.png">
    <link rel="icon" href="https://ys.mihoyo.com/main/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="https://ys.mihoyo.com/main/favicon.ico" type="image/x-icon">
    <meta name="renderer" content="webkit">
    <meta property="og:image" content="https://fastcdn.mihoyo.com/static-resource-v2/2023/12/20/e04bc0be964b4fc7056bc1128b35f200_4546122273706382871.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="keywords" content="OIer的错题集,ESC,ESC.html">
    <meta name="description" content="OIer的错题集,ESC,ESC.html">

    <!-- bing sitmap system -->
    <meta name="msvalidate.01" content="E636B33C63F884A1E40D913638E2424B" />

    <title>错题集 环上最大子段和题解</title>
    <style>
        textarea{
            width: 90%;
            height: 50vh;
        }
        input{
            margin: 10px;
        }
        button{
            margin: 10px;
        }
    </style>
     <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/themes/prism-okaidia.min.css" rel="stylesheet" />
     <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/prism.min.js"></script>
     <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-cpp.min.js"></script>
 </head>
 
</head>
<body>
    <a href="./hub.html">《 返回</a>
    <h3>环上最大子段和-题解</h3>
    对环上问题熟悉的选手可能知道环的常见处理方式是复制一倍，再当成区间问题解决。但复制一倍后无法利用上题思路转移，处理的虚拟子段经常会超过n，这明显是非法情况。<br>
    现在考虑答案的情况：作为答案的子段要么经过1-n的分界线，要么不经过1-n的分界线，刚好是非环上序列的最大子段和。在考虑前者答案的性质：最大子段和经过1-n的分界线，那么它在环上的补集恰是非环上序列的最小子段和（请读者自证）。<br>
    获得了这个巧妙的性质，便可以得知最终答案就是非环情况的最大子段和或者最小子段的补段和。代码如下：
    <textarea name="代码" id="">
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
#define maxn 300000
int n,w1,w2,sum,mi,ma;
int main(){
    cin&gt;&gt;n;
    for(int i=1,a;i&lt;=n;i++){
        cin&gt;&gt;a;
        sum+=a;
        ma=max(ma,w1=max(0,w1+ma));
        mi=min(mi,w2=max(0,w2+mi));
    }
    cout&lt;&lt;max(ma,sum-mi);
    return 0;
}
    </textarea>
</body>

</html>