<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <link rel="apple-touch-icon" href="../../../sqhgxsq/next/Material/logo.png">
    <link rel="icon" href="https://ys.mihoyo.com/main/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="https://ys.mihoyo.com/main/favicon.ico" type="image/x-icon">
    <meta name="renderer" content="webkit">
    <meta property="og:image" content="https://fastcdn.mihoyo.com/static-resource-v2/2023/12/20/e04bc0be964b4fc7056bc1128b35f200_4546122273706382871.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="keywords" content="OIer的错题集,ESC,ESC.html">
    <meta name="description" content="OIer的错题集,ESC,ESC.html">

    <!-- bing sitmap system -->
    <meta name="msvalidate.01" content="E636B33C63F884A1E40D913638E2424B" />
    <!--  -->
    <script>
        alert("这个页面没有进行分类，之前我想分类来着，但一想，这个页面打开直接看也很方便，就干脆不分类了。我单独做了一个分类页面\n\n                                 ——————您亲爱的站长")
    </script>

    <title>错题集</title>

    <link rel="stylesheet" href="./style.css">

    <!--  -->
    <style>
        @media screen and (max-width:600px) {
            .bg1{
        background-image: url("https://act-webstatic.mihoyo.com/event-static/2024/06/24/570fc67f4b580da77f9af206eb3bc0a5_7858946434453008095.jpg?x-oss-process=image/quality,Q_80/resize,m_lfit,s_700");
            }
        }
        @media screen and (min-width:601px){
            .bg1{
        background-image: url("https://act-webstatic.mihoyo.com/event-static/2024/06/24/94fe58803161e06dd1e2fcea8ba56a41_8214787202754590749.png?x-oss-process=image/quality,Q_80/resize,m_lfit,s_700");
    }
        }
    </style>
    <!--  -->
      
</head>
<body>
    <header id="_header">
        <!-- <div class="ph" id="h_1" onclick="window.open('./index.html')">
            NOI
        </div> -->
        <!-- <div class="ph" id="h_2" onclick="window.open('./PH.html')">
            物理
        </div> -->
        <!-- <div class="ph" id="h_3" onclick="window.open('./CM.html')">
            化学
        </div> -->
        <!-- <div class="ph" id="h_4" onclick="window.open('./BO.html')">
            生物
        </div> -->
        <!-- <div class="ph" id="h_5" onclick="window.open('https://oi-wiki.org/')">
            OIWiki
        </div> -->
    </header>
    
    <!--  -->
    <audio src="https://static-mp-54c94446-e6a2-431f-84c4-ed0d181ae263.next.bspapp.com/music/时暮的思眷.mp3" id="dd" autoplay style="display: none;"></audio>
    <!--  -->
    <div class="bg1"></div>
    <div class="bg2"></div>
    <div class="bg3"></div>
    <div class="bg4"></div>
    <div class="bg5"></div>
    <div class="bg6"></div>
    <div class="bg7"></div>
    <div class="bg8"></div>
    <!--  -->


    <div class="op">
        <h1>下拉查看OI错题</h1>
    </div>


    <br>
    <h1>错题集</h1>
    <br>
    <hr style="z-index: 1;">
    <br>
    <!--  -->
    <div class="t1"><img src="https://upload-bbs.miyoushe.com/upload/2024/10/22/286158760/60fcdfbd4e12245f4d69315c48a80154_7170574471892578999.png" alt="johnson" onclick="window.open('https:\/\/upload-bbs.miyoushe.com\/upload\/2024\/10\/22\/286158760\/60fcdfbd4e12245f4d69315c48a80154_7170574471892578999.png')"></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P4779">P4779 【模板】单源最短路径（标准版）</a><a href="https://www.luogu.com.cn/problem/list?difficulty=3">普及/提高-</a>不愧是模板题，我也是直接秒了！看好了，板子是这么背的！<a href="https://upload-bbs.miyoushe.com/upload/2024/10/22/286158760/bc91f2048feafc821d94d2184a1939fc_3137352780557072498.png">单源最短路模板</a></div>
    <div class="t1"><img src="https://upload-bbs.miyoushe.com/upload/2024/10/21/286158760/4be9add32577548a072645ce77498592_4896357184329688696.jpg" alt="">我要省一，呜呜呜！我也是赌上去了！</div>
    <div class="t1">AC(Accepted)保佑我CSP-S复赛400pts！！！<img src="https://upload-bbs.miyoushe.com/upload/2024/10/22/286158760/d4264f3bf787c0d054258a9bddd5c129_6098923047941144383.png" alt="AC"></div>
    <div class="t1">树上与图上动态规划<img src="https://upload-bbs.miyoushe.com/upload/2024/11/17/198629752/7b76bd0a6d782eda3db201ed13b2b19e_4822780433215427247.png" alt="树上与图上动态规划"></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1220">P1220 关路灯</a><a href="https://www.luogu.com.cn/problem/list?difficulty=5">提高+/省选-</a><b>好题中的好题！</b>填表法就是利用状态转移方程和上一个状态来推导出现在的状态（相当于知道已知条件，将答案填入）。刷表法就是利用当前的状态，把有关联的下一状态都推出来。这道题可以反向思考，<p>f<sub>i,j</sub>表示我将i~j的灯都关掉，剩下的灯的总功率。</p>当然，这道题没有这么简单，而是<p>f<sub>i,j,0</sub>表示怪掉i~j的灯后老张站在左端点，反之f<sub>i,j,1</sub>老张站在右端点。</p><pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
using namespace std;
#define maxn 2000
int a[maxn],b[maxn],sum[maxn],n,m,c;
int f[maxn][maxn][2];
int main(){
    cin&gt;&gt;n&gt;&gt;c;
    memset(f,0x3f,sizeof(f));
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;a[i]&gt;&gt;b[i];
        sum[i]=sum[i-1]+b[i];
    }
    f[c][c][0]=f[c][c][1]=0;
    for(int L=1;L&lt;n;L++){
        for(int i=1;i+L&lt;=n;i++){
            int j=i+L;
            f[i][j][0]=min(f[i+1][j][0]+(a[i+1]-a[i])*(sum[i]+sum[n]-sum[j]),f[i+1][j][1]+(a[j]-a[i])*(sum[i]+sum[n]-sum[j]));
            f[i][j][1]=min(f[i][j-1][0]+(a[j]-a[i])*(sum[i-1]+sum[n]-sum[j-1]),f[i][j-1][1]+(a[j]-a[j-1])*(sum[i-1]+sum[n]-sum[j-1]));
        }
    }
    cout&lt;&lt;min(f[1][n][0],f[1][n][1]);
    return 0;
}
</pre><i>参考资料：<a href="https://www.luogu.com.cn/problem/solution/P1220">题解区@z2415445508</a></i></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P4342">P4342 [IOI1998] Polygon</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a><p>f<sub>i,j</sub>表示区间i~j可以获得的最大得分，这道题真的好难啊，看了题解，需要枚举很多情况。当然，如果数学好的话，很快就能枚举出来。</p><pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
using namespace std;
#define maxn 3000
int n,ans=-0x3f3f3f3f;
int a[maxn];
int f[maxn][maxn],g[maxn][maxn];
char c[maxn];
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;c[i]&gt;&gt;a[i];
        a[i+n]=a[i];
        c[i+n]=c[i];
    }
    memset(f,-0x3f,sizeof(f));
    memset(g,0x3f,sizeof(g));
    for(int i=1;i&lt;=(n&lt;&lt;1);i++){
        f[i][i]=g[i][i]=a[i];
    }
    for(int L=1;L&lt;=n;L++){
        for(int i=1;i+L&lt;=(n&lt;&lt;1);i++){
            int j=i+L;
            for(int k=i;k&lt;j;k++){
                if(c[k+1]=='x'){
                    f[i][j]=max(f[i][j],max(f[i][k]*f[k+1][j],max(g[i][k]*g[k+1][j],max(f[i][k]*g[k+1][j],g[i][k]*f[k+1][j]))));
                    g[i][j]=min(g[i][j],min(f[i][k]*f[k+1][j],min(g[i][k]*g[k+1][j],min(f[i][k]*g[k+1][j],g[i][k]*f[k+1][j]))));
                }
                else if(c[k+1]=='t'){
                    f[i][j]=max(f[i][j],f[i][k]+f[k+1][j]);
                    g[i][j]=min(g[i][j],g[i][k]+g[k+1][j]);
                }
            }
        }
    }
    for(int i=1;i&lt;=n;i++){
        ans=max(ans,f[i][i+n-1]);
    }
    cout&lt;&lt;ans&lt;&lt;'\n';
    for(int i=1;i&lt;=n;i++){
        if(f[i][i+n-1]==ans){
            cout&lt;&lt;i&lt;&lt;" ";
        }
    }
    return 0;
}
    </pre>这道题的难点应该就在如何理解删除一条边了。<I>参考资料：<a href="https://www.luogu.com.cn/problem/solution/P4342">题解区@Kalista</a></I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1070">P1070 [NOIP2009 普及组] 道路游戏</a><a href="https://www.luogu.com.cn/problem/list?difficulty=5">提高+/省选-</a>这道题有点难，没看懂。<p>f<sub>i</sub>表示第i时刻收集到的最大值，就这么就完啦？</p>简直无敌！<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
#define maxn 2000
int g[maxn][maxn],n,m,p,cost[maxn],f[maxn],ans,t;
int main(){
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;p;
    for(int i=1;i&lt;=n;i++){
        for(int j=1;j&lt;=m;j++){
            cin&gt;&gt;g[i][j]; <span>//第i条边，j时刻</span>
        }
    }
    for(int i=1;i&lt;=n;i++){ <span>//每个点的花费 </span>
        cin&gt;&gt;cost[i];
    }
    for(int i=1;i&lt;=m;i++){ <span>//初始化 </span>
        f[i]=-1e9; <span>//由于有可能有负数解 </span>
    }
    for(int i=1;i&lt;=m;i++){ <span>//枚举时间 </span>
        for(int j=1;j&lt;=n;j++){ <span>//枚举点 </span>
            ans=-cost[j]+f[i-1];
            for(int k=0;k&lt;p&&i+k&lt;=m;k++){ <span>//枚举走的步数 </span>
                t=j+k&gt;n?((j+k)%n):j+k; <span>//处理环 </span>
                ans+=g[t][i+k];
                f[i+k]=max(f[i+k],ans);<span>//更新 </span>
            }
        }
    }
    cout&lt;&lt;f[m];
    return 0;
}
    </pre><i>
        参考资料：<a href="https://www.luogu.com.cn/problem/solution/P1070">题解区@Hzxleo4</a>
    </i></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1063">P1063 [NOIP2006 提高组] 能量项链</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a>这道题的样例给的很有迷惑性，给的并不清楚，这道题是一道区间合并的题目，还是区间动态规划。<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
#define int long long
#define maxn 2000
int n,a[maxn],f[maxn][maxn];
signed main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;a[i];
        a[i+n]=a[i];
    }
    int ans=0;
    for(int L=1;L&lt;n;L++){
        for(int i=1;i+L&lt;=2*n;i++){
            int j=i+L;
            for(int k=i;k&lt;j;k++){
                f[i][j]=max(f[i][j],f[i][k]+f[k+1][j]+a[i]*a[k+1]*a[j+1]);
            }
            ans=max(ans,f[i][j]);
        }
    }
    cout&lt;&lt;ans;
    return 0;
}
    </pre><I>参考资料：<a href="https://www.luogu.com.cn/problem/solution/P1063">题解区@voilin</a></I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P3146">P3146 [USACO16OPEN] 248 G</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a>区间DP，一定注意边界条件，而且它跟普通区间DP不一样，看代码：<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
#define maxn 2048
int n,a[maxn],f[maxn][maxn],ans;
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;a[i];
        if(a[i]==a[i-1]){
            f[i-1][i]=a[i]+1;
        }
        f[i][i]=a[i];
        ans=max(ans,max(a[i],f[i-1][i]));
    }
    for(int L=2;L&lt;n;L++){
        for(int i=1;i+L&lt;=n;i++){
            int j=i+L;
            for(int k=i;k&lt;j;k++){
                if(f[i][k]==f[k+1][j]&&f[i][k]){
                    f[i][j]=max(f[i][j],f[i][k]+1);
                    ans=max(ans,f[i][j]);
                }
            }
        }
    }
    cout&lt;&lt;ans;
    return 0;
}
    </pre><I>参考资料：<a href="https://www.luogu.com.cn/problem/solution/P3146">题解区@xiejinhao</a></I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P4290">P4290 [HAOI2008] 玩具取名</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a><p>这就是一个高维DP+区间动规的一个好题！f<sub>i,j,k</sub>表示从i到j可以合成k。同样的，我们考虑最基础的情况，那就是长度只有2的情况，那么就是输入时给到我们的串的长度，我们来创建一个新数组w<sub>i,j,k</sub>代表字母i和j可以合成k，注意，这里与f的ijk不同哦！那么这样，就好办了。接下来讨论特殊情况也就是区间长度为1时自己和自己可以合成自己。接下来区间枚举，枚举长度、左端点和右端点、中间分割线、左区间能合成什么、右区间能合成什么。最后如果满足f<sub>i,k,x</sub>==true&&f<sub>k+1,j,y</sub>==true&&w<sub>x,y,p</sub>==true，那么也就意味着f<sub>i,j,k</sub>==true</p>翻译过来就是：如果i到k能被合成为x，并且如果k+1到y能被合成为y，并且x和y能合成p，则i到j能被合成为k。Code：<pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
#define maxn 300
bool f[maxn][maxn][maxn];
int cnt[10];
string s;
bool w[maxn][maxn][maxn];
int change(char x){
    if(x=='W')return 1;
    if(x=='I')return 2;
    if(x=='N')return 3;
    if(x=='G')return 4;
    return 0;
}
int main(){
    for(int i=1;i&lt;=4;i++)cin&gt;&gt;cnt[i];
    for(int i=1;i&lt;=4;i++){
        for(int j=1;j&lt;=cnt[i];j++){
            char a,b;
            cin&gt;&gt;a&gt;&gt;b;
            w[change(a)][change(b)][i]=1;//×Ö·ûa¡¢b¿ÉÒÔ×ª»¯³Éi 
        }
    }
    cin&gt;&gt;s;
    int n=s.length();
    s=" "+s;
    for(int i=1;i&lt;=n;i++){
        f[i][i][change(s[i])]=1;
    }
    for(int L=1;L&lt;n;L++){
        for(int i=1;i+L&lt;=n;i++){
            int j=i+L;
            for(int k=i;k&lt;j;k++){
                for(int p=1;p&lt;=4;p++){
                    for(int x=1;x&lt;=4;x++){
                        for(int y=1;y&lt;=4;y++){
                            if(f[i][k][x]&&f[k+1][j][y]&&w[x][y][p]){
                                f[i][j][p]=1;
                            }
                        }
                    }
                }
            }
        }
    }
    if(f[1][n][1]){
        cout&lt;&lt;'W';f[1][n][5]=1;
    }
    if(f[1][n][2]){
        cout&lt;&lt;'I';f[1][n][5]=1;
    }
    if(f[1][n][3]){
        cout&lt;&lt;'N';f[1][n][5]=1;
    }
    if(f[1][n][4]){
        cout&lt;&lt;'G';f[1][n][5]=1;
    }
    if(!f[1][n][5]){
        cout&lt;&lt;"The name is wrong!";
    }
    return 0;
}
    </pre><I>参考资料：<a href="https://www.luogu.com.cn/problem/solution/P4290">题解区@yu__xuan</a></I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P4170">P4170 [CQOI2007] 涂色</a><a href="https://www.luogu.com.cn/problem/list?difficulty=5">提高+/省选-</a>我第一次居然拿到了70pts！我感觉我又行了！这道题一眼丁真模板题！<p>f<sub>i,j</sub>表示从i到j的最小次数，考虑s的长度只有2，那么只有2种情况。<br>1. s<sub>i</sub>==s<sub>j</sub>，这样的话很简单，只需要取f<sub>i+1,j</sub>和f<sub>i,j-1</sub>两个中较小的一个继承给f<sub>i,j</sub>即可。<br>2. s<sub>i</sub>≠s<sub>j</sub>，此时就要考虑从f<sub>i+1,j</sub>和f<sub>i,j-1</sub>两个中选较小的一个加一给f<sub>i,j</sub>，但真的是这样吗？我举不出反例诶，比如aba，输出2，正确！ababa输出3，正确！abbbaab输出3，正确！那为什么还WA了呢？？？这就很奇怪，因此对于第二种情况，题解给出的还是类似Floyd求相邻点对的最小和。</p>Code:<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
#define maxn 3000
string s;
int f[maxn][maxn];
int main(){
    cin&gt;&gt;s;
    int n=s.length();
    s=" "+s;
    f[1][1]=1;
    for(int i=2;i&lt;=n;i++){
        f[i][i]=1;
        f[i-1][i]=(s[i-1]!=s[i])+1;
    }
    for(int L=2;L&lt;n;L++){
        for(int i=1;i+L&lt;=n;i++){
            int j=i+L;
            if(s[i]==s[j])f[i][j]=min(f[i+1][j],f[i][j-1]);
<span>//			else f[i][j]=min(f[i+1][j]+1,f[i][j-1]+1);</span>
            else{
                f[i][j]=0x3f3f3f3f;
                for(int k=i;k&lt;j;k++){
                    f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]);
                }
            }
        }
    }
    cout&lt;&lt;f[1][n];
    return 0;
}
</pre><I>参考资料：<a href="https://www.luogu.com.cn/problem/solution/P4170">题解区@FZzzz</a></I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1140">P1140 相似基因</a><a href="https://www.luogu.com.cn/problem/list?difficulty=3">普及/提高-</a><p>动态规划的题目基本上都是“f<sub>i</sub>表示前i个满足要求时的答案"。<br>因为这道题有2个串，很容易想到”f<sub>i,j</sub>表示a串的前i个碱基和b串的前j个碱基的相似度”</p>之后就很好写了，看代码：<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
#define maxn 2000
int g[10][10]={
    {0,0, 0, 0, 0, 0},
    {0,5,-1,-2,-1,-3},
    {0,-1,5,-3,-2,-4},
    {0,-2,-3,5,-2,-2},
    {0,-1,-2,-2, 5,-1},
    {0,-3,-4,-2,-1, 0},
};
int n,m,a[maxn],b[maxn],dp[maxn][maxn];
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        char c;
        cin&gt;&gt;c;
        switch(c){
            case 'A':{
                a[i]=1;
                break;
            }
            case 'C':{
                a[i]=2;
                break;
            }
            case 'G':{
                a[i]=3;
                break;
            }
            case 'T':{
                a[i]=4;
                break;
            }
        }
    }
    cin&gt;&gt;m;
    for(int i=1;i&lt;=m;i++){
        char c;
        cin&gt;&gt;c;
        switch(c){
            case 'A':{
                b[i]=1;
                break;
            }
            case 'C':{
                b[i]=2;
                break;
            }
            case 'G':{
                b[i]=3;
                break;
            }
            case 'T':{
                b[i]=4;
                break;
            }
        }
    }
    
    for(int i=1;i&lt;=n;i++){
        dp[i][0]=dp[i-1][0]+g[a[i]][5];
    }
    for(int i=1;i&lt;=m;i++){
        dp[0][i]=dp[0][i-1]+g[5][b[i]];
    }
    
    for(int i=1;i&lt;=n;i++){
        for(int j=1;j&lt;=m;j++){
            dp[i][j]=max(dp[i-1][j-1]+g[a[i]][b[j]],max(dp[i-1][j]+g[a[i]][5],dp[i][j-1]+g[5][b[j]]));
        }
    }
    cout&lt;&lt;dp[n][m];
    return 0;
}
    </pre>谢谢大佬，没有大佬我AC不了的。<I>参考资料：<a href="https://www.luogu.com.cn/problem/solution/P1140">题解区@zhy137036</a></I></div>
    <div class="t1"><a href="./myOJ/oj1.html">环上最大子段和</a><a href="https://www.luogu.com.cn/problem/list?difficulty=1">入门</a>这道题很简单，考虑环内最大子段在1-n这条链内的情况，那么最大子段和就是最大子段和，但如果不在1-n，而是一段在y-n，一段在1-x怎么办？那我们反过来考虑，直接求x-y就好了，那么x-y就是最小子段和。答案就是最大子段和或最小子段的补段和了。<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
#define maxn 300000
int n,w1,w2,sum,mi,ma;
int main(){
    cin&gt;&gt;n;
    for(int i=1,a;i&lt;=n;i++){
        cin&gt;&gt;a;
        sum+=a;
        ma=max(ma,w1=max(0,w1+ma));
        mi=min(mi,w2=max(0,w2+mi));
    }
    cout&lt;&lt;max(ma,sum-mi);
    return 0;
}
    </pre><I>参考资料：<a href="./myOJ/oj1-answer.html">OJ题解区</a></I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1880">P1880 [NOI1995] 石子合并</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a>这道题是在原先的链式石子合并的基础上变成了环，实际上只需要稍微改动即可，既然是环，就先破环成链，也就是复制一份接到原来的数组后面变成长度为2*n的数组。则<b>一定存在一个断点，使整个链取到最大值或最小值</b>，那么我们就枚举断点，将环变成链来动态DP。<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
using namespace std;
#define maxn 1000
int a[maxn],f[maxn][maxn],n,w[maxn][maxn],g[maxn][maxn];
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;a[i];
    }
    for(int i=1;i&lt;=n;i++){
        a[i+n]=a[i];
    }
    for(int i=1;i&lt;=2*n;i++){
        for(int j=i;j&lt;=2*n;j++){
            w[i][j]=w[i][j-1]+a[j];
        }
    }
    int minans=0x3f3f3f3f;
    for(int k=0;k&lt;n;k++){
        for(int L=1;L&lt;n;L++){
            for(int i=1+k;i+L&lt;=n+k;i++){
                int j=i+L;
                f[i][j]=0x3f3f3f3f;
                for(int p=i;p&lt;j;p++){
                    f[i][j]=min(f[i][j],f[i][p]+f[p+1][j]);
                }
                f[i][j]+=w[i][j];
            }
        }
        minans=min(minans,f[1+k][n+k]);
    }
    cout&lt;&lt;minans&lt;&lt;'\n';
    
    int maxans=-0x3f3f3f3f;
    for(int k=0;k&lt;n;k++){
        for(int L=1;L&lt;n;L++){
            for(int i=1+k;i+L&lt;=n+k;i++){
                int j=i+L;
                f[i][j]=-0x3f3f3f3f;
                for(int p=i;p&lt;j;p++){
                    f[i][j]=max(f[i][j],f[i][p]+f[p+1][j]);
                }
                f[i][j]+=w[i][j];
            }
        }
        maxans=max(maxans,f[1+k][n+k]);
    }
    cout&lt;&lt;maxans;
    return 0;
}
</pre>代码中的最外层循环就是枚举断点，然后内层循环和链式石子合并的代码一样，就只是改了一个for的范围和max和min。<I>参考资料：无</I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P3205">P3205 [HNOI2010] 合唱队</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a>这道题是区间DP的一道难题，考虑到几种情况。<b>f<sub>i,j,0</sub>表示第i个人从左边进来的方案数</b><b>f<sub>i,j,1</sub>表示第j个人从右边进来的方案数</b>因为你的每一次决策都会产生方案数，因此：<b>当右端点的数大于左端点且上一个插入在左端时</b><b>当左端点的数小于右端点且上一个插入在右端时</b>这两种情况也要加上。最后代码如下：<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
#define maxn 1500
#define mod 19650827
int n,a[maxn],f[maxn][maxn][2];
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;a[i];
    }
    for(int i=1;i&lt;=n;i++){
        f[i][i][0]=1;
    }
    for(int L=1;L&lt;n;L++){
        for(int i=1,j=i+L;j&lt;=n;i++,j++){
            if(a[i]&lt;a[i+1])f[i][j][0]+=f[i+1][j][0];
            if(a[i]&lt;a[j]){
                f[i][j][0]+=f[i+1][j][1];
                f[i][j][1]+=f[i][j-1][0];
            }
            if(a[j]&gt;a[j-1])f[i][j][1]+=f[i][j-1][1];
            f[i][j][0]%=mod;
            f[i][j][1]%=mod;
        }
    }
    cout&lt;&lt;(f[1][n][0]+f[1][n][1])%mod;
    return 0;
}
</pre><I>参考资料：<a href="https://www.luogu.com.cn/problem/solution/P3205">题解区@帅到报警</a>、<a href="https://www.luogu.com.cn/problem/solution/P3205">题解区@kradcigam</a></I></div>
    <div class="t1"><a href="https://codeforces.com/problemset/problem/607/B">B. Zuma</a><a href="https://www.luogu.com.cn/problem/list?difficulty=5">提高+/省选-</a>这道题区间DP，f[i][j]表示从i到j的石子最小消除次数，跟石子合并那道题是差不多的。<br>如果长度为1或2，消除它只需要1步，否则划分成两个子串，类似石子合并那道题枚举中间点k。<b>如果这两个颜色不相同 枚举断点 答案是消掉左半区间最少步数加上消掉右半边区间最少步数 取最小值 如果能更优那么在上一步已经处理过了</b><b>Code：</b><pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
using namespace std;
#define maxn 1000
int f[maxn][maxn];
int n;
int c[maxn];
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;c[i];
    }
    memset(f,0x3f,sizeof(f));
    for(int L=0;L&lt;=n;L++){
        for(int i=1;i+L&lt;=n;i++){
            int j=i+L;
            if(c[i]==c[j]){
                f[i][j]=(L&lt;2)?1:min(f[i][j],f[i+1][j-1]);
            }
            for(int k=i;k&lt;j;k++){
                f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]);
            }
        }
    }
    cout&lt;&lt;f[1][n];
    return 0;
}
    </pre><I>参考资料：<a href="https://www.luogu.com.cn/problem/solution/CF607B">题解区@installb</a></I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1775">P1775 石子合并（弱化版）</a><a href="https://www.luogu.com.cn/problem/list?difficulty=3">普及/提高-</a>这道题其实是将f[i][j]划分为两个子区间，然后计算子区间合并带来的价值。如图：<img src="https://upload-bbs.miyoushe.com/upload/2024/11/15/198629752/6fd92c7fa60bde003337a033801e6dd4_1022333349892268241.png" alt="">这就类似Floyd最短路了。<b>Code:</b><pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
#define maxn 2000
int f[maxn][maxn];
int n;
int a[maxn],w[maxn][maxn];
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;a[i];
        if(i&lt;=1)continue;
        f[i-1][i]=a[i-1]+a[i];
    }
    for(int i=1;i&lt;=n;i++){
        for(int j=i;j&lt;=n;j++){
            w[i][j]=w[i][j-1]+a[j];
        }
    }
    for(int L=1;L&lt;n;L++){
        for(int i=1;i+L&lt;=n;i++){
            int j=i+L;
            f[i][j]=0x3f3f3f3f;
            for(int k=i;k&lt;j;k++){
                f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]);
            }
            f[i][j]+=w[i][j];
        }
    }
    cout&lt;&lt;f[1][n];
    return 0;
}            
    </pre><I>参考资料：<a href="https://www.luogu.com.cn/problem/solution/P1775">题解区@expnoi</a></I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1435">P1435 [IOI2000] 回文字串</a><a href="https://www.luogu.com.cn/problem/list?difficulty=3">普及/提高-</a>这段时间你真的努力了吗？？？这道题也可以用区间DP来做，f[i][j]表示从字符串第i个位置到第j个位置所构成的子串变成回文串所需要的最少插入字符数。考虑三个情况。<b>1.f[i][j]可能是f[i][j-1]+1，考虑把s[j]接在这个串的左边。</b><b>2.f[i][j]可能是f[i+1][j]+1，考虑把s[i]接在这个串的右边。</b><b>3.假如s[i]==s[j]就表明f[i][j]可以从f[i+1][j-1]转移过来取最大值。</b>为什么这么操作？看个图就知道了：<img src="https://upload-bbs.miyoushe.com/upload/2024/11/15/198629752/edcbb435ee39a27d726ca02c8d97d72f_4206213026224012494.png" alt=""><pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
#define maxn 3000
string s;
int f[maxn][maxn],n;
int main(){
    cin&gt;&gt;s;
    n=s.length();
    s=" "+s;
    for(int i=2;i&lt;=n;i++){
        if(s[i]!=s[i-1]){
            f[i-1][i]=1;
        }
    }
    for(int L=2;L&lt;=n;L++){
        for(int i=1;i+L&lt;=n;i++){
            int j=i+L;
            f[i][j]=min(f[i+1][j]+1,f[i][j-1]+1);
            if(s[i]==s[j]){
                f[i][j]=min(f[i+1][j-1],f[i][j]);
            }
        }
    }
    cout&lt;&lt;f[1][n];
    return 0;
}
</pre>这里的L指的是i到j的长度为L，但为什么要枚举长度，因为这玩意需要倒着推，因此不枚举长度的话答案做不到及时更新，因此还有一种写法，那就是枚举两个端点。<b>Code:</b><pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
#define maxn 3000
string s;
int f[maxn][maxn],n;
int main(){
    cin&gt;&gt;s;
    n=s.length();
    s=" "+s;
    for(int i=2;i&lt;=n;i++){
        if(s[i]!=s[i-1]){
            f[i-1][i]=1;
        }
    }
    for(int j=3;j&lt;=n;j++){
        for(int i=j-2;i&gt;=1;i--){
            f[i][j]=min(f[i+1][j]+1,f[i][j-1]+1);
            if(s[i]==s[j]){
                f[i][j]=min(f[i+1][j-1],f[i][j]);
            }
        }
    }
    cout&lt;&lt;f[1][n];
    return 0;
}
</pre>没错，这要就好多了，让左端点i往左遍历，j不动就好了。我也不知道为啥这道题为啥非得倒着推。<I>参考资料：无</I></div>
    <div class="t1">区间DP<img src="https://upload-bbs.miyoushe.com/upload/2024/11/15/198629752/6f35ee82e36e69a6b1b53edae937ccaf_5737850775742159817.png" alt="区间DP"></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P3147">P3147 [USACO16OPEN] 262144 P</a><a href="https://www.luogu.com.cn/problem/list?difficulty=5">提高+/省选-</a>这道题的状态转移方程很难推。dp[i][j]表示以j为左端点，i为右端点合并的数的值。<b>Code:</b><pre>
#include &lt;iostream&gt;
using namespace std;
int n,dp[60][400000],ans;
int main(){
    cin&gt;&gt;n;
    for(int i=1,v;i&lt;=n;i++){
        cin&gt;&gt;v;
        dp[v][i]=i+1;
    }
    for(int i=2;i&lt;=59;i++){
        for(int j=1;j&lt;=n;j++){
            if(!dp[i][j]){
                dp[i][j]=dp[i-1][dp[i-1][j]];
            }
            if(dp[i][j]){
                ans=i;
            }
        }
    }
    cout&lt;&lt;ans;
    return 0;
}
    </pre><p>代码中的i的上限是58，原因是题目中要求的i的数值范围是1~40，再加上2<sup>18</sup>=262144，因此就是40+18=58。</p><I>
        参考资料：<a href="https://www.luogu.com.cn/problem/solution/P3147">题解区@3493441984zz</a><a href="https://www.luogu.com.cn/problem/solution/P3147">题解区@曹老师</a>
    </I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P4310">P4310 绝世好题</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a>这道题要注意位运算的优先级，位运算的优先级是很低的，在if判断的时候一定要用括号括起来！<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
#define maxn 200000
int a[maxn],ans,n,dp[32];
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;a[i];
    }
    
    for(int i=1;i&lt;=n;i++){
        int sum=0;
        for(int j=0;j&lt;=30;j++){
            if(a[i]&(1&lt;&lt;j)!=0){
                sum=max(sum,dp[j]+1);
            }
        }
        for(int j=0;j&lt;=30;j++){
            if(a[i]&(1&lt;&lt;j)!=0){
                dp[j]=sum;
            }
        }
    }
    
    for(int i=0;i&lt;=30;i++){
        ans=max(ans,dp[i]);
    }
    cout&lt;&lt;ans;
    return 0;
}
    </pre><b>相邻两数位与不为0，等价于两数存在一个二进制位都为1。</b>因此动态规划进行查找拼接即可。<I>参考资料：<a href="https://blog.csdn.net/zjgmartin/article/details/108560248">CSDN题解</a></I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1541">P1541 [NOIP2010 提高组] 乌龟棋</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a>这道题是多重背包的题目，因为里面有四种物品，因此要开四个维度的dp。<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
using namespace std;
long long dp[50][50][50],n,m;
int a[1000],b[5],c;
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];
    for(int i=1;i&lt;=m;i++)cin&gt;&gt;c,b[c]++;
    memset(dp,-0x3f,sizeof(dp));
    dp[0][0][0]=0;
    for(int i=0;i&lt;=b[1];i++){
        for(int j=0;j&lt;=b[2];j++){
            for(int k=0;k&lt;=b[3];k++){
                for(int p=0;p&lt;=b[4];p++){
                    int t=a[i+2*j+3*k+4*p+1];
                    if(j)dp[j][k][p]=max(dp[j-1][k][p],dp[j][k][p]);
                    if(k)dp[j][k][p]=max(dp[j][k-1][p],dp[j][k][p]);
                    if(p)dp[j][k][p]=max(dp[j][k][p-1],dp[j][k][p]);
                    dp[j][k][p]+=t;
                }
            }
        }
    }
    cout&lt;&lt;dp[b[2]][b[3]][b[4]];
    return 0;
}
</pre><I>参考资料：<a href="https://www.luogu.com.cn/problem/solution/P1541">题解区@Ousmane_Dembele</a></I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P2340">P2340 [USACO03FALL] Cow Exhibition G</a><a href="https://www.luogu.com.cn/problem/list?difficulty=3">普及/提高-</a>这道题就是01背包的变式，其中智商表示体积，情商表示价值，奶牛个数表示容量。<b>Code:</b><pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
using namespace std;
int s[500],f[500],dp[999999];
int n,ans;
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;s[i]&gt;&gt;f[i];
    }
    memset(dp,-0x3f,sizeof(dp));
    dp[400000]=0;
    for(int i=1;i&lt;=n;i++){
        if(s[i]&gt;=0){
            for(int j=800000;j&gt;=s[i];j--){
                dp[j]=max(dp[j],dp[j-s[i]]+f[i]);
            }
        }
        else{
            for(int j=0;j&lt;=800000+s[i];j++){
                dp[j]=max(dp[j],dp[j-s[i]]+f[i]);
            }
        }
    }
    for(int i=400000;i&lt;=800000;i++){
        if(dp[i]&gt;=0){
            ans=max(ans,dp[i]+i-400000);
        }
    }
    cout&lt;&lt;ans;
    return 0;
}
    </pre>那个400000是偏移量，是为了让下标能正常访问负数。最后要减去这个偏移量。其中dp[i][j] 表示前 i 只奶牛中，总智商为 j 时情商的最大值，最后的答案要加上智商，并且取最大值。<I>参考资料：<a href="https://www.luogu.com.cn/problem/solution/P2340">题解区@学而思李老师</a>、<a href="https://www.luogu.com.cn/problem/solution/P2340">题解区@狸狸养的敏敏</a></I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1833">P1833 樱花</a><a href="https://www.luogu.com.cn/problem/list?difficulty=3">普及/提高-</a>这就是一个混合背包问题，但是之前一本通上面学的都忘完了呜呜呜。<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
using namespace std;
#define int long long
#define maxn 40000
int T,n,dp[maxn],w[maxn],v[maxn],op[maxn];
signed main(){
    int a,b,c,d;
    scanf("%d:%d %d:%d",&a,&b,&c,&d);
    T=c*60+d-(a*60+b);
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;w[i]&gt;&gt;v[i]&gt;&gt;op[i];
    }
    for(int i=1;i&lt;=n;i++){ <span>//这就是一个混合背包问题，对于每一个去判断一下就好了 </span>
        if(op[i]==0){
            for(int j=w[i];j&lt;=T;j++){ <span>//完全背包 </span>
                dp[j]=max(dp[j],dp[j-w[i]]+v[i]);
            }
        }
        else{
            for(int j=1;j&lt;=op[i];j++){ <span>//01背包和多重背包 </span>
                for(int k=T;k&gt;=w[i];k--){
                    dp[k]=max(dp[k],dp[k-w[i]]+v[i]);
                }
            }
        }
    }
    cout&lt;&lt;dp[T];
    return 0;
}
    </pre><I>参考资料：信息学奥赛一本题p357</I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1435">P1435 [IOI2000] 回文字串</a><a href="https://www.luogu.com.cn/problem/list?difficulty=3">普及/提高-</a><b>喜提AC一枚~</b>我以为我会WA，结果一遍AC了！这道题需要将原来的串复制一份，然后翻转。这样就转化为了最长公共子序列(LCS)问题，然后求最长公共子序列(LCS)，最后用原串长度减去LCS就是答案啦！<pre>
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
using namespace std;
const int maxn = 3e3;
int dp[maxn][maxn];
string s,a,b;
int main(){
    cin&gt;&gt;s;
    s=" "+s;
    a=s;
    for(int i=s.length();i&gt;=1;i--){
        b+=s[i];
    }
    b=" "+b;
    for(int i=1;i&lt;=s.length();i++){
        for(int j=1;j&lt;=s.length();j++){
            if(a[i]==b[j]){
                dp[i][j]=dp[i-1][j-1]+1;
            }
            else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
        }
    }
    cout&lt;&lt;s.length()-1-dp[s.length()][s.length()];
    return 0;
}
</pre><I>参考资料：<a href="https://www.luogu.com.cn/problem/solution/P1435">题解区@gyf12138</a></I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1004">P1004 [NOIP2000 提高组] 方格取数</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a>这道题是四维dp，用dp[i][j][k][p]表示两个坐标(i,j)和(k,p)，别忘了如果两人走了同一个点，那么我们要让两人其中一人"让步"。<b>Code:</b><pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
using namespace std;
int n,ans;
int g[20][20],vg[20][20];
int dp[20][20][20][20];
int main(){
    cin&gt;&gt;n;
    int x,y,w;
    while(cin&gt;&gt;x&gt;&gt;y&gt;&gt;w&&(x!=0||y!=0||w!=0)){
        g[x][y]=w;
    }
    for(int i=1;i&lt;=n;i++){
        for(int j=1;j&lt;=n;j++){
            for(int k=1;k&lt;=n;k++){
                for(int p=1;p&lt;=n;p++){
                    dp[i][j][k][p]=max(dp[i-1][j][k-1][p],
                    max(dp[i-1][j][k][p-1],
                    max(dp[i][j-1][k-1][p],
                    dp[i][j-1][k][p-1])))+g[i][j]+g[k][p];

                    if(i==k&&j==p)dp[i][j][k][p]-=g[i][j];
                    <span>//当相等的时候就让其中一人让步</span>
                    <span>//说白了就是让其中一人把刚吃的吐出来</span>
                }
            }
        }
    }
    cout&lt;&lt;dp[n][n][n][n];
    return 0;
}
</pre><I>参考资料：<a href="https://www.luogu.com.cn/problem/solution/P1004">题解区@road</a></I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1544">P1544 三倍经验</a><a href="https://www.luogu.com.cn/problem/list?difficulty=3">普及/提高-</a>这道题也很难，但我起码把式子推出来了一点，本题是分层图。状态转移刚开始很好想，但细节非常多。<pre>
#include &lt;iostream&gt;
using namespace std;
#define int long long
int n,k,ans=-3e9;
int g[200][200],f[200][200][200];
signed main(){
    cin&gt;&gt;n&gt;&gt;k;
    for(int i=1;i&lt;=n;i++){
        for(int j=0;j&lt;=n;j++){
            for(int p=0;p&lt;=k;p++){
                f[i][j][p]=-3e9;
            }
        }
    }
    for(int i=1;i&lt;=n;i++){
        for(int j=1;j&lt;=i;j++){
            cin&gt;&gt;g[i][j];
            for(int p=0;p&lt;=k&&p&lt;=i;p++){
                f[i][j][p]=max(f[i-1][j-1][p],f[i-1][j][p])+g[i][j];
                if(p&gt;=1){
                    f[i][j][p]=max(f[i][j][p],max(f[i-1][j-1][p-1],f[i-1][j][p-1])+g[i][j]*3);
                }
            }
        }
    }
    for(int i=1;i&lt;=n;i++){
        for(int j=0;j&lt;=k;j++){
            ans=max(ans,f[n][i][j]);
        }
    }
    cout&lt;&lt;ans;
    return 0;
}
    </pre><I>参考资料：<a href="https://www.luogu.com.cn/problem/solution/P1544">题解区@QianRan_GG</a></I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P2679">P2679 [NOIP2015 提高组] 子串</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a>这道题很难啊，呜呜呜。设f[i][j][k]表示仅考虑A的前i个字符，B匹配到第j个字符，用了k个子串，且A[i]为最后一个匹配字符的方案数。<pre>
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
using namespace std;
#define int long long
#define mod 1000000007
int n,m,k,f[1010][1010],sum[1010][1010];
string A,B;
signed main(){
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;
    cin&gt;&gt;A&gt;&gt;B;
    A=" "+A;B=" "+B;
    f[0][0]=1;
    for(int i=1;i&lt;=n;i++){
        for(int j=m;j&gt;=1;j--){
            for(int p=k;p&gt;=1;p--){
                if(A[i]==B[j]){
                    sum[j][p]=sum[j-1][p]+f[j-1][p-1];
                }
                else sum[j][p]=0;
                f[j][p]=(f[j][p]+sum[j][p]%mod)%mod;
            }
        }
    }
    cout&lt;&lt;f[m][k];
    return 0;
}
    </pre>这个题解说了个什么啊？听不懂啊。<I>
        参考资料：<a href="https://blog.csdn.net/qq_50332374/article/details/125732674">CSDN题解。</a>
    </I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1439">P1439 【模板】最长公共子序列</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a>这道题的转移方程很好想，就是<code>dp[i][j]=max(dp[i][j-1],max(dp[i-1][j],dp[i-1][j-1]+(a[i]==b[j])));</code>状态压缩以后就是这个<code>dp[j]=max(dp[j-1],max(dp[j],dp[j-1]+(a[i]==b[j])));</code>但是最多只能拿60分。60分的解法：<pre>
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
#define maxn 200000
int dp[maxn];
int a[maxn],b[maxn],n;
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;a[i];
    }
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;b[i];
    }
    for(int i=1;i&lt;=n;i++){
        for(int j=1;j&lt;=n;j++){
            dp[j]=max(dp[j-1],max(dp[j],dp[j-1]+(a[i]==b[j])));
        }
    }
    cout&lt;&lt;dp[n];
    return 0;
}
    </pre>然而AC的正解要难得多，我都看不懂，问了Ai之后模模糊糊能看懂一点。<pre>
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
#define maxn 200000
int idx[maxn],dp[maxn];
int a[maxn],b[maxn],n;
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;a[i];
        idx[a[i]]=i;
    }
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;b[i];
        dp[i]=0x3f3f3f3f;
    }
    int len=0;
    dp[0]=0;
    for(int i=1;i&lt;=n;i++){
        if(idx[b[i]]&gt;dp[len]){
            dp[++len]=idx[b[i]];
        }
        else{
            int l=0,r=len,mid;
            while(l&lt;r){
                mid=l+r&gt;&gt;1;
                if(dp[mid]&gt;idx[b[i]]) r=mid;
                else l=mid+1;
            }
            dp[l]=min(dp[l],idx[b[i]]);
        }
    }
    cout&lt;&lt;len;
    return 0;
}
    </pre><I>参考资料：<a href="https://www.luogu.com.cn/problem/solution/P1439">题解区@皎月半洒花</a></I>看了kkk大佬的题解之后我觉得还是差不多能接受。<pre>
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
#define maxn 200000
int idx[maxn],dp[maxn];
int a[maxn],b[maxn],n,ans,c[maxn];
void ins(int k,int x){
    for(;k&lt;maxn;k+=k&(-k)){
        c[k]=max(c[k],x);
    }
}
int ask(int k){
    int sum=0;
    for(;k;k-=k&(-k)){
        sum=max(c[k],sum);
    }
    return sum;
}
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;a[i];
    }
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;b[i];
        idx[b[i]]=i;
    }
    for(int i=1;i&lt;=n;i++){
        dp[i]=ask(idx[a[i]])+1; <span>//查询以b[i]结尾的最长子序列长度 </span>
        ins(idx[a[i]],dp[i]); <span>//把b[i]的下标更新为dp的长度。</span>
        ans=max(ans,dp[i]);
    }
    cout&lt;&lt;ans;
    return 0;
}
    </pre><I>参考资料：深进p234</I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1874">P1874 快速求和</a><a href="https://www.luogu.com.cn/problem/list?difficulty=3">普及/提高-</a>这道题啥玩意啊？看不懂，题解感觉很高级，学到了！num数组的用法非常牛啊，代码如下: <pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
using namespace std;
const int INF = 0x7f7f7f7f7f;
int s,n;
int dp[50][100010],t,num[50][50];
string S; 
int main(){
    cin&gt;&gt;S&gt;&gt;t;
    n=S.length();
    memset(dp,127,sizeof(dp));
    dp[0][0]=-1;
    for(int i=1;i&lt;=n;i++){
        for(int j=1;j&lt;=i;j++){
            if(num[j][i-1]&gt;t){
                num[j][i]=INF;
            }
            else{
                num[j][i]=num[j][i-1]*10+S[i-1]-'0';
            }
        }
    }
    for(int i=1;i&lt;=n;i++){
        for(int s=0;s&lt;=t;s++){
            for(int j=i-1;j&gt;=0&&num[j+1][i]&lt;=t;j--){
                if(s&gt;=num[j+1][i]){
                    dp[i][s]=min(dp[i][s],dp[j][s-num[j+1][i]]+1);
                }
            }
        }
    }
    cout&lt;&lt;(dp[n][t]&lt;50?dp[n][t]:-1);
    return 0;
}
</pre><I>参考资料：无</I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P4933">P4933 大师</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a>这道题很多细节要处理。还有dp数组的第二维一定要开大点。<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
#define maxn 24000
#define mod 998244353
int n,h[maxn],dp[1010][maxn*2],ans;
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;h[i];
        for(int j=1;j&lt;i;j++){
            (dp[i][h[i]-h[j]+maxn]+=(dp[j][h[i]-h[j]+maxn]+1))%=mod;
            (ans+=(dp[j][h[i]-h[j]+maxn]+1))%=mod;
        }
    }
    cout&lt;&lt;(ans+n)%mod;
    return 0;
}
    </pre>状态转移方程好推，但是不好写对。处理负数的公差时，我使用了添加偏移量的方式来保证下标可以访问负数的方差。ans最后+n是因为每一个数单独也构成美观方案。<I>参考资料：无</I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P2285">P2285 [HNOI2004] 打鼹鼠</a><a href="https://www.luogu.com.cn/problem/list?difficulty=3">普及/提高-</a>这道题是线性动态规划解决，跟普通动态规划是一样的，就是需要我去变通一下。<br>状态转移的条件限制是曼哈顿距离不超过时间差。<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
#define maxn 20000
int n,m,dp[maxn],ans;
int t[maxn],x[maxn],y[maxn];
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=m;i++){
        cin&gt;&gt;t[i]&gt;&gt;x[i]&gt;&gt;y[i];
        dp[i]=1;
        for(int j=1;j&lt;i;j++){
            if(dp[j]+1&gt;dp[i]&&abs(x[i]-x[j])+abs(y[i]-y[j])&lt;=abs(t[i]-t[j])){
                dp[i]=dp[j]+1;
            }
        }
        ans=max(ans,dp[i]);
    }
    cout&lt;&lt;ans;
    return 0;
}
    </pre><I>参考资料：无</I></div>
    <div class="t1">线性动态规划<img src="https://upload-bbs.miyoushe.com/upload/2024/11/13/198629752/f08cb666b85c196938594f8fe04cf757_4166902666156833568.png" alt="线性动态规划"></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1064">P1064 [NOIP2006 提高组] 金明的预算方案</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a>经典背包附件问题。还记得01背包的决策是什么吗？
<br>
        1.不选，然后去考虑下一个<br>
        
        2.选，背包容量减掉那个重量，总值加上那个价值。<br>
        
        这个题的决策是五个，分别是：<br>
        
        1.不选，然后去考虑下一个<br>
        
        2.选且只选这个主件<br>
        
        3.选这个主件，并且选附件1<br>
        
        4.选这个主件，并且选附件2<br>
        
        5.选这个主件，并且选附件1和附件2.<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
#define maxn 32000
int n,m;
int v,p,q;
int w[maxn];
int c[maxn];
int fw[maxn][3];
int fc[maxn][3];
int dp[maxn];
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=m;i++){
        cin&gt;&gt;v&gt;&gt;p&gt;&gt;q;
        if(!q){
            w[i]=v;
            c[i]=v*p;
        }
        else{
            fw[q][0]++;
            fw[q][fw[q][0]]=v;
            fc[q][fw[q][0]]=v*p;
        }
    }
    for(int i=1;i&lt;=m;i++){
        for(int j=n;w[i]!=0&&j&gt;=w[i];j--){
            dp[j]=max(dp[j],dp[j-w[i]]+c[i]);
            if(j&gt;=w[i]+fw[i][1]){
                dp[j]=max(dp[j],dp[j-w[i]-fw[i][1]]+c[i]+fc[i][1]);
            }
            if(j&gt;=w[i]+fw[i][2]){
                dp[j]=max(dp[j],dp[j-w[i]-fw[i][2]]+c[i]+fc[i][2]);
            }
            if(j&gt;=w[i]+fw[i][1]+fw[i][2]){
                dp[j]=max(dp[j],dp[j-w[i]-fw[i][1]-fw[i][2]]+c[i]+fc[i][1]+fc[i][2]);
            }
        }
    }
    cout&lt;&lt;dp[n];
    return 0;
}
    </pre><I>参考资料：<a href="https://www.luogu.com.cn/problem/solution/P1064">题解区@ShawnZhou</a></I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P3842">P3842 [TJOI2007] 线段</a><a href="https://www.luogu.com.cn/problem/list?difficulty=3">普及/提高-</a>这道题中有一个概念“要求沿途走过所有的线段”。她的意思不是让你碰一下这个线的某个位置就算是穿过了，而是让你从这个线的某一端走到另一端保证这个线的各个位置你都走过。这样一来就好说了。<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int maxn = 2e4+10;
int n,m,dp[2][maxn],a[maxn],l[maxn],r[maxn],len[maxn];
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;l[i]&gt;&gt;r[i];
        len[i]=r[i]-l[i];
    }
    dp[0][1]=r[1]-1+len[1];
    dp[1][1]=r[1]-1;
    for(int i=2;i&lt;=n;i++){
        dp[0][i]=min(dp[0][i-1]+abs(r[i]-l[i-1]),dp[1][i-1]+abs(r[i-1]-r[i]))+len[i]+1;
        dp[1][i]=min(dp[0][i-1]+abs(l[i-1]-l[i]),dp[1][i-1]+abs(r[i-1]-l[i]))+len[i]+1;
    }
    cout&lt;&lt;min(dp[0][n]+n-l[n],dp[1][n]+n-r[n]);
    return 0;
}
</pre><I>参考资料：<a href="https://www.luogu.com.cn/problem/solution/P3842">题解区@aakennes</a></I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1077">P1077 [NOIP2012 普及组] 摆花</a><a href="https://www.luogu.com.cn/problem/list?difficulty=3">普及/提高-</a>这道题是有限背包，3重循环，最外层循环不要从0开始，别忘了循环外面还有提前初始化dp[0][0]=1。<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int mod = 1e6+7;
int n,m,w[100100],dp[1000][1000];
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;w[i];
    }
    dp[0][0]=1;
    for(int i=1;i&lt;=n;i++){
        for(int j=0;j&lt;=m;j++){
            for(int k=0;k&lt;=min(j,w[i]);k++){
                dp[i][j]=(dp[i][j]+dp[i-1][j-k])%mod;
            }
        }
    }
    cout&lt;&lt;dp[n][m];
    return 0;
}
    </pre><I>参考资料：<a href="https://www.luogu.com.cn/problem/solution/P1077">题解区@Godのfather</a></I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1616">P1616 疯狂的采药</a><a href="https://www.luogu.com.cn/problem/list?difficulty=2">普及-</a>这是完全背包问题，注意j的取值范围，还有数组要开大一点，10^7的数据范围，否则会RE。<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
#define int long long
int t,m,w[10000010],dp[10000010],v[10010000];
signed main(){
    cin&gt;&gt;t&gt;&gt;m;
    for(int i=1;i&lt;=m;i++){
        cin&gt;&gt;w[i]&gt;&gt;v[i];
    }
    for(int i=1;i&lt;=m;i++){
        for(int j=w[i];j&lt;=t;j++){
            dp[j]=max(dp[j],dp[j-w[i]]+v[i]);
        }
    }
    cout&lt;&lt;dp[t];
    return 0;
}
    </pre><I>参考资料：无</I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1049">P1049 [NOIP2001 普及组] 装箱问题</a><a href="https://www.luogu.com.cn/problem/list?difficulty=2">普及-</a>0-1背包的解法我忘了，因此这道题WA了2次。这道题是背包的模板题，很简单。<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
#define int long long
#define maxn 20300
int V,n,w[maxn],dp[maxn];
int max(int x,int y){
    return x&gt;y?x:y;
}
signed main(){
    cin&gt;&gt;V&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i];
    
    for(int i=0;i&lt;=n;i++){
        for(int j=V;j&gt;=w[i];j--){
            dp[j]=max(dp[j],dp[j-w[i]]+w[i]);
        }
    }
    cout&lt;&lt;V-dp[V];
    return 0;
}
    </pre>其中，dp[j]表示背包容量为j时能装的最大体积，dp[j-w[i]]表示当装了第i个物品的话剩余容量能装的最大体积。因此状态转移方程就出来了<code>dp[j]=max(dp[j],dp[j-w[i]]+w[i])</code><I>参考资料：<a href="https://www.luogu.com.cn/problem/solution/P1049">题解区@vegetabird</a></I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1802">P1802 5 倍经验日</a><a href="https://www.luogu.com.cn/problem/list?difficulty=2">普及-</a>说实话这道题有点唐。这道题我调了半天，发现是x的区间没有把0算进去。我甚至把for循环遍历药水数量的范围扩大到了3500，想着暴力AC，结果AC了，后来发现我能AC的原因是取值把x算进去了，所以AC了。<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
#define int long long
#define maxn 4000

<span>//dp[i][j]表示用i瓶药水打j个人。 </span>
int n,x,dp[maxn][maxn],los[maxn],win[maxn],usc[maxn];
signed main(){
    cin&gt;&gt;n&gt;&gt;x;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;los[i]&gt;&gt;win[i]&gt;&gt;usc[i];
    }
    for(int i=0;i&lt;=x;i++){
        for(int j=1;j&lt;=n;j++){
            if(i-usc[j]&gt;=0){ <span>//如果药水数量足够，那么我考虑要不要使用药水打人 </span>
                dp[i][j]=max(dp[i][j-1]+los[j],dp[i-usc[j]][j-1]+win[j]);
            }
            else{ <span>//否则我只能不用药水打人 </span>
                dp[i][j]=dp[i][j-1]+los[j];
            }
        }
    }
    cout&lt;&lt;dp[x][n]*5;
    return 0;
}
</pre>注意不要把状态压缩，这个貌似不能压。<I>参考资料：无</I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1115">P1115 最大子段和</a><a href="https://www.luogu.com.cn/problem/list?difficulty=2">普及-</a>这道题需要注意，ans有可能是负数，因此dp和ans都要初始化负无穷！<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
#define maxn 300010
#define int long long
int a[maxn],dp[maxn],n,ans=-0x3f3f3f3f;
signed main(){
    cin&gt;&gt;n;
    dp[0]=-0x3f3f3f3f;
    for(int i=1;i&lt;=n;i++){
        dp[i]=-0x3f3f3f3f;
        cin&gt;&gt;a[i];
        dp[i]=max(dp[i-1]+a[i],a[i]);
        ans=max(ans,dp[i]);
    }
    cout&lt;&lt;ans;
    return 0;
}
    </pre><I>参考资料：无</I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P4017">P4017 最大食物链计数</a><a href="https://www.luogu.com.cn/problem/list?difficulty=3">普及/提高-</a>这道题考虑建反向边，因为我们要找的是路径和，肯定是从后往前求前缀，所以要建反向边。<s>（为自己WA找的理由）</s><pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;
#define maxn 50010
#define mod 80112002
int n,m,ind[maxn],oud[maxn],dp[maxn],ans;
vector&lt;int&gt; e[maxn];

int dfs(int x){
    if(dp[x]) return dp[x];
    int sum=0;
    for(int y:e[x]){
        sum=(sum+dfs(y))%mod;
    }
    return dp[x]=sum;
}

int main(){
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1,u,v;i&lt;=m;i++){
        cin&gt;&gt;u&gt;&gt;v;
        e[v].push_back(u);
        ind[v]++;
        oud[u]++;
    }
    for(int i=1;i&lt;=n;i++){
        if(ind[i]==0)dp[i]=1;
    }
    for(int i=1;i&lt;=n;i++){
        dfs(i);
    }
    for(int i=1;i&lt;=n;i++){
        if(oud[i]==0){
            ans=(ans+dp[i])%mod;
        }
    }
    cout&lt;&lt;ans;
    return 0;
}
</pre>这道题需要用记忆化搜索+拓扑排序，其实主要还是记忆化搜索，拓扑排序只是给我们一个启发：从入度为0的点出发，到终点出度为0的点的路径。加法原理求路径条数就好了。<I>参考资料：无</I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1434">P1434 [SHOI2002] 滑雪</a><a href="https://www.luogu.com.cn/problem/list?difficulty=3">普及/提高-</a>这道题我用了一个十分弱智的解法卡过去了。<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
int r,c,g[1000][1000];
int dp[1000][1000];
int sum;

bool InRange(int x,int y){
    return (x&gt;=1&&x&lt;=r)&&(y&gt;=1&&y&lt;=c);
}
int main(){
    cin&gt;&gt;r&gt;&gt;c;
    for(int i=1;i&lt;=r;i++){
        for(int j=1;j&lt;=c;j++){
            cin&gt;&gt;g[i][j];
            dp[i][j]=1;
        }
    }
    sum=1;
    for(int k=1;k&lt;=r*c/2;k++)
    for(int i=1;i&lt;=r;i++){
        for(int j=1;j&lt;=c;j++){
            if(InRange(i+1,j)){
                if(g[i+1][j]&lt;g[i][j]){
                    if(dp[i+1][j]+1&gt;dp[i][j]){
                        dp[i][j]=dp[i+1][j]+1;
                        sum=max(sum,dp[i][j]);
                    }
                }
            }
            if(InRange(i-1,j)){
                if(g[i-1][j]&lt;g[i][j]){
                    if(dp[i-1][j]+1&gt;dp[i][j]){
                        dp[i][j]=dp[i-1][j]+1;
                        sum=max(sum,dp[i][j]);
                    }
                }
            }
            if(InRange(i,j+1)){
                if(g[i][j+1]&lt;g[i][j]){
                    if(dp[i][j+1]+1&gt;dp[i][j]){
                        dp[i][j]=dp[i][j+1]+1;
                        sum=max(sum,dp[i][j]);
                    }
                }
            }
            if(InRange(i,j-1)){
                if(g[i][j-1]&lt;g[i][j]){
                    if(dp[i][j-1]+1&gt;dp[i][j]){
                        dp[i][j]=dp[i][j-1]+1;
                        sum=max(sum,dp[i][j]);
                    }
                }
            }
        }
    }
    cout&lt;&lt;sum;
    return 0;
}
    </pre>看一下代码就知道，这确实是状态转移，但是这个状态转移似乎有点问题，因为你需要重复多次这样的转移才能得到最终答案，因此我在外层套了一个k的循环，k太小会导致得不到答案，k太大会导致超时，只有刚刚正好才能AC，因为这道题我是卡过去的。正解是记忆化搜索，但是要注意边界条件的判断<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
int r,c,g[1000][1000];
int dp[1000][1000];
int sum;

bool InRange(int x,int y){
    return (x&gt;=1&&x&lt;=r)&&(y&gt;=1&&y&lt;=c);
}

int dfs(int x,int y){
    if(dp[x][y]) return dp[x][y];
    int ans=0;
    if(InRange(x,y+1))if(g[x][y]&gt;g[x][y+1]) ans=max(ans,dfs(x,y+1));
    if(InRange(x,y-1))if(g[x][y]&gt;g[x][y-1]) ans=max(ans,dfs(x,y-1));
    if(InRange(x+1,y))if(g[x][y]&gt;g[x+1][y]) ans=max(ans,dfs(x+1,y));
    if(InRange(x-1,y))if(g[x][y]&gt;g[x-1][y]) ans=max(ans,dfs(x-1,y));
    return dp[x][y]=ans+1;
}

int main(){
    cin&gt;&gt;r&gt;&gt;c;
    for(int i=1;i&lt;=r;i++){
        for(int j=1;j&lt;=c;j++){
            cin&gt;&gt;g[i][j];
        }
    }
    for(int i=1;i&lt;=r;i++){
        for(int j=1;j&lt;=c;j++){
            if(dp[i][j])continue;
            sum=max(sum,dfs(i,j));
        }
    }
    cout&lt;&lt;sum;
    return 0;
}
</pre><I>参考资料：无</I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P2196">P2196 [NOIP1996 提高组] 挖地雷</a><a href="https://www.luogu.com.cn/problem/list?difficulty=3">普及/提高-</a>这道题很简单，就是细节有点多，你要忍一下~~~<img src="https://upload-bbs.miyoushe.com/upload/2024/11/13/198629752/71a8e1e084cbf84d1270fba8325b3e71_8601608978769144660.png" alt="提交记录"><p>第一次WA是因为dp没有初始化，第二次WA是因为ans没有初始化，第三次WA是因为<s>我很不屑</s>第四次WA是因为p没有初始化，第五次都初始化了就AC了。</p><pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
#define int long long
int n,a[100001],g[1000][1000],dp[1000],ps[1000];
int stk[10000],top;
int ans,p;
signed main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;a[i];
        dp[i]=a[i];
        if(dp[i]&gt;ans){
            ans=dp[i];
            p=i;
        }
    }
    
    for(int i=1;i&lt;=n;i++){
        for(int j=i+1;j&lt;=n;j++){
            cin&gt;&gt;g[i][j];
        }
    }
    for(int i=1;i&lt;=n;i++){
        for(int j=i+1;j&lt;=n;j++){
            if(g[i][j]){
                if(dp[i]+a[j]&gt;dp[j]){
                    dp[j]=dp[i]+a[j];
                    if(dp[j]&gt;ans){
                        ans=dp[j];
                        p=j;
                    }
                    ps[j]=i;
                }
            }
        }
    }
    while(p){
        stk[++top]=p;
        p=ps[p];
    }
    while(top){
        cout&lt;&lt;stk[top--]&lt;&lt;" ";
        if(!top)cout&lt;&lt;"\n";
    }
    cout&lt;&lt;ans;
    return 0;
}
</pre>这道题其实完全可以用搜索的。<I>
    参考资料：无
</I></div>
    <div class="t1">什么是动态规划<img src="https://upload-bbs.miyoushe.com/upload/2024/11/13/198629752/2a32dce3f7c2c8baa8450742cb129bc8_2577598402035893172.png" alt="什么是动态规划"></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P7737">P7737 [NOI2021] 庆典</a><a href="https://www.luogu.com.cn/problem/list?difficulty=6">省选/NOI-</a>这道题是tarjan缩点转DAG+虚树。但我不会，而且它还卡常，导致得少用vector要不然TLE。<pre>
#include&lt;bits/stdc++.h&gt;//JZM yyds!!
#define ll long long
#define MAXN 300005
#define uns unsigned
using namespace std;
inline ll read(){
	ll x=0;bool f=1;char s=getchar();
	while((s&lt;'0'||s&gt;'9')&&s&gt;0){if(s=='-')f^=1;s=getchar();}
	while(s&gt;='0'&&s&lt;='9')x=(x&lt;&lt;1)+(x&lt;&lt;3)+s-'0',s=getchar();
	return f?x:-x;
}
int n,m,Q,k;
int u1,v1,u2,v2;
vector&lt;int&gt;G[MAXN],G_[MAXN],G__[MAXN];

int dfn[MAXN],NN,low[MAXN],bl[MAXN];
bool ist[MAXN];
stack&lt;int&gt;st;
int du[MAXN],num,siz[MAXN];

int fa[MAXN],f[MAXN][25],hd[MAXN],tl[MAXN],dp[MAXN],dep[MAXN],IN;

inline void tarjan(int x){
	low[x]=dfn[x]=++NN,st.push(x),ist[x]=1;
	for(uns i=0;i&lt;G__[x].size();i++){
		int v=G__[x][i];
		if(!dfn[v])tarjan(v),low[x]=min(low[x],low[v]);
		else if(ist[v])low[x]=min(low[x],dfn[v]);
	}
	if(low[x]==dfn[x]){num++;
		while(!st.empty()&&dfn[st.top()]&gt;=dfn[x])
			bl[st.top()]=num,ist[st.top()]=0,st.pop();
	}
}
queue&lt;int&gt;q;
int root;
inline void topu(){
	for(int i=1;i&lt;=num;i++)if(!du[i])q.push(i),root=i;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(uns i=0;i&lt;G_[u].size();i++){
			int v=G_[u][i];du[v]--;
			if(!du[v])
				G[u].push_back(v),fa[v]=u,q.push(v);
		}
	}
}
inline void dfs(int x){
	hd[x]=++IN,f[x][0]=fa[x];
	dp[x]=dp[fa[x]]+siz[x],dep[x]=dep[fa[x]]+1;
	for(int i=1;i&lt;20;i++)f[x][i]=f[f[x][i-1]][i-1];
	for(uns i=0;i&lt;G[x].size();i++)dfs(G[x][i]);
	tl[x]=IN;
}
inline int lca(int u,int v){
	if(dep[u]&lt;dep[v])swap(u,v);
	for(int i=19;i&gt;=0;i--)if(dep[f[u][i]]&gt;=dep[v])u=f[u][i];
	if(u!=v){
		for(int i=19;i&gt;=0;i--)
			if(f[u][i]!=f[v][i])u=f[u][i],v=f[v][i];
		u=fa[u];
	}
	return u;
}
vector&lt;int&gt;a,b;
inline void addedge(int u,int v){
	bool ok=0;
	for(uns i=0;i&lt;a.size();i++)
		if(hd[u]&gt;=hd[a[i]]&&hd[u]&lt;=tl[a[i]])ok=1;
	if(ok){
		int h=0;
		for(uns i=0;i&lt;a.size()&&h&gt;=0;i++){
			if(hd[v]&gt;=hd[a[i]]&&hd[v]&lt;=tl[a[i]])h=-1;
			if(h&gt;=0&&hd[a[i]]&gt;hd[v]&&hd[a[i]]&lt;=tl[v])h=1,a[i]=v;
		}
		for(uns i=0;i&lt;a.size();i++){
			bool ok=1;
			for(uns j=0;j&lt;i;j++)if(a[j]==a[i])ok=0;
			if(!ok)a.erase(a.begin()+i,a.begin()+i+1),i--;
		}
		if(h==0)a.push_back(v);
	}
	
	ok=0;
	for(uns i=0;i&lt;b.size();i++)
		if(hd[b[i]]&gt;=hd[v]&&hd[b[i]]&lt;=tl[v])ok=1;
	if(ok){
		int h=0;
		for(uns i=0;i&lt;b.size()&&h==0;i++){
			if(hd[b[i]]&gt;=hd[u]&&hd[b[i]]&lt;=tl[u])h=-1;
			if(h==0&&hd[u]&gt;hd[b[i]]&&hd[u]&lt;=tl[b[i]])h=1,b[i]=u;
		}
		if(h==0)b.push_back(u);
	}
}
signed main()
{
// 	freopen("celebration.in","r",stdin);
// 	freopen("celebration.out","w",stdout);
	n=read(),m=read(),Q=read(),k=read();
	for(int i=1;i&lt;=m;i++){
		int u=read(),v=read();
		G__[u].push_back(v);
	}
	for(int i=1;i&lt;=n;i++)if(!dfn[i])tarjan(i);
	for(int x=1;x&lt;=n;x++){
		siz[bl[x]]++;
		for(uns i=0;i&lt;G__[x].size();i++){
			int v=G__[x][i];
			if(bl[v]!=bl[x])
				G_[bl[x]].push_back(bl[v]),du[bl[v]]++;
		}
	}
	topu(),dfs(root);
	for(int D=1;D&lt;=Q;D++){
		int s=read(),t=read();
		a.clear(),b.clear(),u1=v1=u2=v2=0;
		a.push_back(bl[s]),b.push_back(bl[t]);
		if(k&gt;0)u1=bl[read()],v1=bl[read()];
		if(k&gt;1)u2=bl[read()],v2=bl[read()];
		if(u1==v1)u1=v1=0;
		if(u2==v2)u2=v2=0;
		if(u1)addedge(u1,v1);
		if(u2)addedge(u2,v2);
		if(u1)addedge(u1,v1);
		int ans=0;
		for(uns i=0;i&lt;a.size();i++){
			for(uns j=0;j&lt;b.size();j++){
				int c=a[i],d=b[j];
				if(hd[d]&gt;=hd[c]&&hd[d]&lt;=tl[c]){
					int lc=fa[c],glc;
					for(uns l=0;l&lt;j;l++){
						glc=lca(b[l],d);
						if(dep[glc]&gt;dep[lc])lc=glc;
					}
					ans+=dp[d]-dp[lc];
				}
			}
		}
		printf("%d\n",ans);
	}
	return 0;
}
</pre><I>
    参考资料：<a href="https://www.luogu.com.cn/problem/solution/P7737">题解区@OUYE2020</a>
</I>代码足足好几行，我忘了，反正很长。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P4819">P4819 [中山市选] 杀人游戏</a><a href="https://www.luogu.com.cn/problem/list?difficulty=6">省选/NOI-</a>这道题需要结合数学期望+tarjan缩点完成，具体怎么完成的我还是不明白呜呜呜。<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
using namespace std;
const int N = 1e5+10;
const int M = 3e5+10;
int n,m;
vector&lt;int&gt; edge[N];
int low[N],dfn[N],tim,stk[N],top,scc[N],cnt;
bool vis[N];
inline void tarjan(int u){
    stk[++top]=u;
    vis[u]=1;
    low[u]=dfn[u]=++tim;
    for(int v:edge[u]) {
        if(!dfn[v]){
            tarjan(v);
            low[u]=min(low[u],low[v]);
        }
        else if(vis[v]){
            low[u]=min(low[u],dfn[v]);
        }
    }
    if(low[u]==dfn[u]){
        scc[u]=++cnt;
        while(stk[top]!=u){
            scc[stk[top]]=cnt;
            vis[stk[top--]]=0;
        }
        vis[u]=0;top--;
    }
}
int in[N],siz[N],tot;
vector&lt;int&gt; g[N];
bool vise[M];
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1,u,v;i&lt;=m;i++){
        cin&gt;&gt;u&gt;&gt;v;
        edge[u].push_back(v);
    }
    for(int i=1;i&lt;=n;i++){
        if(!dfn[i])tarjan(i);
    }
    for(int i=1;i&lt;=n;i++){
        siz[scc[i]]++;
    }
    for(int i=1;i&lt;=n;i++){
        for(int j:edge[i]){
            if(scc[i]==scc[j]||vise[scc[j]]) continue;
            g[scc[i]].push_back(scc[j]);
            vise[scc[j]]=1;in[scc[j]]++;
        }
        for(int j:edge[i]) vise[scc[j]]=0;
    }
    bool flag = 1;
    for(int i=1;i&lt;=cnt;i++){
        if(!in[i]) tot++;
        if(in[i]||siz[i]&gt;1) continue;
        if(flag==0) continue;
        bool pp = 1;
        for(int j:g[i]){
            if(in[j]&lt;=1){
                pp=0;
                break;
            }
        }
        if(pp) tot--,flag=0;
    }
    printf("%.6lf",1.0*(n-tot)/n);
    return 0;
}
</pre><I>
    参考资料：<a href="https://www.cnblogs.com/adolf-stalin/p/17732917.html">博客园题解</a>
</I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P3825">P3825 [NOI2017] 游戏</a><a href="https://www.luogu.com.cn/problem/list?difficulty=6">省选/NOI-</a>这道题需要2-SAT算法解决。我仍然不会，因此是抄的。<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
using namespace std;
#define int long long
const int N=1e5+9;
struct Edge{
    int to,nxt;
}edge[N&lt;&lt;1];
struct In{
    int a,b;
    char x,y;
}in[N];
int head[N&lt;&lt;1],dfn[N&lt;&lt;1],low[N&lt;&lt;1],scc[N&lt;&lt;1];
bool vis[N&lt;&lt;1];
int a[N],bits[N];
int n,d,m,ecnt,cnt,tot;
stack&lt;int&gt; stk;
void add(int u,int v){
    edge[++ecnt]=(Edge){v,head[u]};
    head[u]=ecnt;
}
void tarjan(int u){
    dfn[u]=low[u]=++tot;
    vis[u]=1;
    stk.push(u);
    for(int i=head[u];i;i=edge[i].nxt){
        int v=edge[i].to;
        if(!dfn[v]){
            tarjan(v);
            low[u]=min(low[u],low[v]);
        }
        else{
            if(vis[v]){
                low[u]=min(low[u],dfn[v]);
            }
        }
    }
    if(low[u]==dfn[u]){
        int v;
        ++cnt;
        do{
            v=stk.top();
            stk.pop();
            vis[v]=0;
            scc[v]=cnt;
        }while(v!=u);
    }
}
bool two_sat(){
    for(int i=1;i&lt;=2*n;i++){
        if(!dfn[i])tarjan(i);
    }
    for(int i=1;i&lt;=n;i++){
        if(scc[i]==scc[i+n])return 0;
    }
    return 1;
}
void init(){
    memset(vis,0,sizeof(vis));
    memset(scc,0x3f,sizeof(scc));
    memset(dfn,0,sizeof(dfn));
    memset(low,0,sizeof(low));
    memset(head,0,sizeof(head));
    while(!stk.empty()){
        stk.pop();
    }
    tot=cnt=ecnt=0;
}
bool sol(){
    cin&gt;&gt;n&gt;&gt;d;
    string s;
    cin&gt;&gt;s;s=" "+s;
    int sum=0;
    for(int i=1;i&lt;s.size();i++){
        if(s[i]=='x'){
            a[i]=sum++;
        }
    }
    cin&gt;&gt;m;
    for(int i=1;i&lt;=m;i++){
        cin&gt;&gt;in[i].a&gt;&gt;in[i].x&gt;&gt;in[i].b&gt;&gt;in[i].y;
    }
    for(int now=0;now&lt;(1&lt;&lt;d);now++){
        init();
        for(int i=1;i&lt;=m;i++){
            int na=in[i].x-'A',nb=in[i].y-'A';
            int l=in[i].a,r=in[i].b;
            if(s[in[i].a]=='x'){
                if(now&(1&lt;&lt;a[in[i].a])){
                    if(na==1) continue;
                    if(na==2) l+=n;
                }
                else{
                    if(na==2) continue;
                    if(na==1) l+=n;
                }
            }
            else{
                if(s[in[i].a]-'a'==na){
                    continue;
                }
                if(s[in[i].a]=='a'){
                    if(na==2) l+=n;
                }
                if(s[in[i].a]=='b'){
                    if(na==2) l+=n;
                }
                if(s[in[i].a]=='c'){
                    if(na==1) l+=n;
                }
            }
            if(s[in[i].b]=='x'){
                if(now&(1&lt;&lt;a[in[i].b])){
                    if(nb==1){
                        add(l,(l==in[i].a)?(l+n):(l-n));
                        continue;
                    }
                    if(nb==2){
                        r+=n;
                    }
                }
                else{
                    if(nb==2){
                        add(l,(l==in[i].a)?(l+n):(l-n));
                        continue;
                    }
                    if(nb==1){
                        r+=n;
                    }
                }
            }
            else{
                if(s[in[i].b]-'a'==nb){
                    add(l,(l==in[i].a)?(l+n):(l-n));
                    continue;
                }
                if(s[in[i].b]=='a'){
                    if(nb==2) r+=n;
                }
                if(s[in[i].b]=='b'){
                    if(nb==2) r+=n;
                }
                if(s[in[i].b]=='c'){
                    if(nb==1) r+=n;
                }
            }
            add(l,r);
            if(l==in[i].a){
                l+=n;
            }
            else{
                l-=n;
            }
            if(r==in[i].b){
                r+=n;
            }
            else{
                r-=n;
            }
            add(r,l);
        }
        if(two_sat()){
            for(int i=1;i&lt;=n;i++){
                if(s[i]=='x'){
                    if(now&(1&lt;&lt;a[i])){
                        if(scc[i]&lt;scc[i+n]){
                            cout&lt;&lt;"A";
                        }
                        else{
                            cout&lt;&lt;"C";
                        }
                    }
                    else{
                        if(scc[i]&lt;scc[i+n]){
                            cout&lt;&lt;"A";
                        }
                        else{
                            cout&lt;&lt;"B";
                        }
                    }
                }
                if(s[i]=='a'){
                    if(scc[i]&lt;scc[i+n]){
                        cout&lt;&lt;"B";
                    }
                    else{
                        cout&lt;&lt;"C";
                    }
                }
                if(s[i]=='b'){
                    if(scc[i]&lt;scc[i+n]){
                        cout&lt;&lt;"A";
                    }
                    else{
                        cout&lt;&lt;"C";
                    }
                }
                if(s[i]=='c'){
                    if(scc[i]&lt;scc[i+n]){
                        cout&lt;&lt;"A";
                    }
                    else{
                        cout&lt;&lt;"B";
                    }
                }
            }
            cout&lt;&lt;"\n";
            return 1;
        }
    }
    return 0;
}
signed main(){
    if(!sol()){
        cout&lt;&lt;"-1";
    }
    return 0;
}
    </pre><I>
        参考资料：<a href="https://www.cnblogs.com/yexinqwq/p/17219177.html">博客园大佬</a>
    </I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P5025">P5025 [SNOI2017] 炸弹</a><a href="https://www.luogu.com.cn/problem/list?difficulty=6">省选/NOI-</a>这道题是tarjan+线段树优化。具体怎么写我不知道，抄的。<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
using namespace std;
#define ll long long
#define mid ((l+r)&gt;&gt;1)
#define ls k&lt;&lt;1
#define rs k&lt;&lt;1|1
const int N = 5e5+10,M=2e6+10,mod=1e9+7;
struct node{
    int l,r;
}a[M];
ll x[N],r[N];
int dfn[M],low[M],scc[M];
int id[M],le[M],ri[M];
int n,nd,tot,cnt,ans;
stack&lt;int&gt; s;
vector&lt;int&gt; e[M],G[M];
bool vis[M];
void build(int k,int l,int r){
    a[k]={l,r};
    nd=max(nd,k);
    if(l==r){
        id[l]=k;
        return;
    }
    build(ls,l,mid);
    build(rs,mid+1,r);
    e[k].push_back(ls);
    e[k].push_back(rs);
}
void link(int k,int l,int r,int L,int R,int v){
    if(L&lt;=l&&R&gt;=r){
        if(k==v){
            return;
        }
        e[v].push_back(k);
        return;
    }
    if(L&lt;=mid){
        link(ls,l,mid,L,R,v);
    }
    if(R&gt;mid){
        link(rs,mid+1,r,L,R,v);
    }
}
void tarjan(int x){
    dfn[x]=low[x]=++tot;
    s.push(x),vis[x]=1;
    for(int y:e[x]){
        if(!dfn[y]){
            tarjan(y);
            low[x]=min(low[x],low[y]);
        }
        else if(vis[y]){
            low[x]=min(low[x],dfn[y]);
        }
    }
    if(dfn[x]==low[x]){
        cnt++;
        int v;
        do{
            v=s.top();
            s.pop();
            vis[v]=0;
            scc[v]=cnt;
            le[cnt]=min(le[cnt],a[v].l);
            ri[cnt]=max(ri[cnt],a[v].r);
        }while(v!=x);
    }
}
void dfs(int u){
    vis[u]=1;
    for(int v:G[u]){
        if(vis[v]){
            le[u]=min(le[u],le[v]);
            ri[u]=max(ri[u],ri[v]);
            continue;
        }
        dfs(v);
        le[u]=min(le[u],le[v]);
        ri[u]=max(ri[u],ri[v]);
    }
}
int query(int x){
    int u=scc[id[x]];
    return ri[u]-le[u]+1;
}
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;x[i]&gt;&gt;r[i];
    }
    memset(le,0x3f,sizeof(le));
    build(1,1,n);
    for(int i=1;i&lt;=n;i++){
        int L=lower_bound(x+1,x+n+1,x[i]-r[i])-x;
        int R=upper_bound(x+1,x+n+1,x[i]+r[i])-x-1;
        link(1,1,n,L,R,id[i]);
        a[id[i]]={L,R};
    }
    tarjan(1);
    for(int i=1;i&lt;=nd;i++){
        for(int j=0;j&lt;e[i].size();j++){
            int u=e[i][j];
            if(scc[u]==scc[i]){
                continue;
            }
            G[scc[i]].push_back(scc[u]);
        }
    }
    for(int i=1;i&lt;=cnt;i++){
        sort(G[i].begin(),G[i].end());
        unique(G[i].begin(),G[i].end());
    }
    memset(vis,0,sizeof(vis));
    for(int i=1;i&lt;=cnt;i++){
        if(!vis[i]) dfs(i);
    }
    for(int i=1;i&lt;=n;i++){
        ans=(ans+1ll*query(i)*i)%mod;
    }
    cout&lt;&lt;ans;
    return 0;
}
</pre><I>
    参考资料：<a href="https://www.cnblogs.com/YHxo/p/16806249.html">博客园大佬</a>
</I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P2341">P2341 [USACO03FALL / HAOI2006] 受欢迎的牛 G</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a>强连通分量的大小就是答案。难就难在怎么看出来这玩意跟强连通分量有关系。我还是抄的，不过这个感觉好简单。<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
using namespace std;
const int N = 2e5;
int n,m,a,b;
int dfn[N],low[N],tot;
int stk[N],instk[N],top;
int scc[N],siz[N],cnt;
vector&lt;int&gt; e[N];
void tarjan(int x){
    dfn[x]=low[x]=++tot;
    stk[++top]=x;instk[x]=1;
    for(int y:e[x]){
        if(!dfn[y]){
            tarjan(y);
            low[x]=min(low[x],low[y]);
        }
        else if(instk[y]){
            low[x]=min(low[x],dfn[y]);
        }
    }
    if(low[x]==dfn[x]){
        ++cnt;
        int y;
        do{
            y=stk[top--];
            instk[y]=0;
            scc[y]=cnt;
            ++siz[cnt];
        }while(y!=x);
    }
}
int du[N];
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    while(m--){
        cin&gt;&gt;a&gt;&gt;b;
        e[a].push_back(b);
    }
    for(int i=1;i&lt;=n;i++){
        if(!dfn[i])tarjan(i);
    }
    for(int i=1;i&lt;=n;i++){
        for(int j:e[i]){
            if(scc[i]-scc[j]){
                du[scc[i]]++;
            }
        }
    }
    int ans=0;
    for(int i=1;i&lt;=cnt;i++){
        if(!du[i]){
            if(ans){
                puts("0");
                return 0;
            }
            ans=i;
        }
    }
    cout&lt;&lt;siz[ans];
    return 0;
}
</pre><I>
    参考资料：<a href="https://www.cnblogs.com/bifanwen/p/12581880.html">博客园题解</a>
</I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1262">P1262 间谍网络</a><a href="https://www.luogu.com.cn/problem/list?difficulty=5">提高+/省选-</a>这道题我也不会，因此也是抄的。这道题需要dfs+tarjan缩点。<pre>
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
#define maxn 3005
#define maxm 8005
int n,p,r;
int hd[maxn],nxt[maxm],to[maxm],tot=1;
int dfn[maxn],low[maxn],num,stk[maxn],tp,c[maxn],cnt;
int pr[maxn],f[maxn];
int x,y;
bool vs[maxn],v[maxn];

void add(int x,int y){
    nxt[++tot]=hd[x];
    hd[x]=tot;
    to[tot]=y;
}
void tarjan(int x){
    dfn[x]=low[x]=++tot;
    stk[++tp]=x;
    for(int i=hd[x];i;i=nxt[i]){
        if(!dfn[to[i]]){
            tarjan(to[i]),low[x]=min(low[x],low[to[i]]);
        }
        else if(!c[to[i]]){
            low[x]=min(low[x],dfn[to[i]]);
        }
    }
    if(low[x]==dfn[x]){
        c[x]=++cnt;
        f[cnt]=pr[x];
        while(stk[tp]!=x){
            f[cnt]=min(f[cnt],pr[stk[tp]]),c[stk[tp--]]=cnt;
        }
        tp--;
    }
}
void dfs(int x){
    v[x]=1;
    for(int i=hd[x];i;i=nxt[i]){
        if(!v[to[i]]){
            dfs(to[i]);
        }
    }
}
int main(){
    cin&gt;&gt;n&gt;&gt;p;
    for(int i=1;i&lt;=n;i++){
        pr[i]=2147483647;
    }
    for(int i=1;i&lt;=p;i++){
        cin&gt;&gt;x&gt;&gt;y;pr[x]=y;
    }
    cin&gt;&gt;r;
    for(int i=1;i&lt;=r;i++){
        cin&gt;&gt;x&gt;&gt;y;
        add(x,y);
    }
    for(int i=1;i&lt;=n;i++){
        if(pr[i]&lt;2147483647&&!v[i]){
            dfs(i);
        }
    }
    for(int i=1;i&lt;=n;i++){
        if(!v[i]){
            cout&lt;&lt;"NO\n"&lt;&lt;i&lt;&lt;'\n';
            return 0;
        }
    }
    for(int i=1;i&lt;=n;i++){
        if(!c[i]){
            tarjan(i);
        }
    }
    for(int i=1;i&lt;=n;i++){
        for(int j=hd[i];j;j=nxt[j]){
            if(c[i]!=c[to[j]]){
                vs[c[to[j]]]=1;
            }
        }
    }
    int ans=0;
    for(int i=1;i&lt;=cnt;i++){
        if(!vs[i]){
            ans+=f[i];
        }
    }
    cout&lt;&lt;"YES\n"&lt;&lt;ans;
    return 0;
}
</pre><I>
    参考资料：<a href="https://www.cnblogs.com/louhancheng/p/10160699.html">博客园@louhc</a>
</I></div>
    <div class="t1"><a href="https://codeforces.com/problemset/submit?csrf_token=ee0fad0734e5a1432fc96e5c2954dac6">E. Tourists</a><a href="https://www.luogu.com.cn/problem/list?difficulty=6">省选/NOI-</a>这道题不会，我抄的博客园大佬的题解，大佬的代码实在是太恶心人了，变量起的啥玩意啊，而且size还引发了二义性导致CE了我￥%@&！<pre>
#include &lt;cmath&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
using namespace std;
const int N = 2e5+5;
const int M = 4e5+5;
const int INF = 1e9;
struct node{
    int u[M],v[M],nxt[M];
    int cnt,head[N];
    void init(){
        cnt=0;
        memset(head,0,sizeof(head));
    }
    void add(int U,int V){
        u[++cnt]=U;
        v[cnt]=V;
        nxt[cnt]=head[U];head[U]=cnt;
    }
}e,g;
int n,m,T,w[N];
int dfn[N],low[N],to[N],t,l;
stack&lt;int&gt; q;
void tarjan(int u,int f){
    dfn[u]=low[u]=++t;
    for(int i=g.head[u];i;i=g.nxt[i]){
        int v=g.v[i];
        if(!dfn[v]){
            q.push(i);tarjan(v,u);
            low[u]=min(low[u],low[v]);
            if(low[v]&gt;=dfn[u]){
                int num;l++;
                do{
                    num=q.top();q.pop();
                    int x=g.u[num],y=g.v[num];
                    if(to[x]!=l){
                        to[x]=l;
                        e.add(x,l+n);e.add(l+n,x);
                    }
                    if(to[y]!=l){
                        to[y]=l;
                        e.add(y,l+n);e.add(l+n,y);
                    }
                }while(num!=i);
            }
        }
        else if(low[u]&gt;dfn[v]&&f!=v){
            q.push(i);low[u]=dfn[v];
        }
    }
}
inline bool is_square(int x){
    return x&gt;n;
}
multiset&lt;int&gt; minn[N];
int tot,fa[N],pos[N],idx[N],siz[N],son[N],dep[N],top[N],val[N];
void dfs1(int u){
    siz[u]=1;
    for(int i=e.head[u];i;i=e.nxt[i]){
        int v=e.v[i];
        if(fa[u]==v)continue;
        fa[v]=u,dep[v]=dep[u]+1;
        if(is_square(u))minn[u].insert(w[v]);
        dfs1(v);siz[u]+=siz[v];
        if(!son[u]||siz[son[u]]&lt;siz[v]) son[u]=v;
    }
}
void dfs2(int u,int anc){
    pos[u]=++tot;
    idx[tot]=u;top[u]=anc;
    if(!son[u])return;
    dfs2(son[u],anc);
    for(int i=e.head[u];i;i=e.nxt[i]){
        int v=e.v[i];
        if(v==fa[u]||v==son[u])continue;
        dfs2(v,v);
    }
}
inline void init(){
    dep[1]=1;
    dfs1(1);
    dfs2(1,1);
}
int tr[N&lt;&lt;2];
void build(int a,int l,int r){
    if(l==r){
        tr[a]=(is_square(idx[l]))?*minn[idx[l]].begin():w[idx[l]];
        return;
    }
    int mid=l+r&gt;&gt;1;
    build(a&lt;&lt;1,l,mid);build(a&lt;&lt;1|1,mid+1,r);
    tr[a]=min(tr[a&lt;&lt;1],tr[a&lt;&lt;1|1]);
}
inline int query(int a,int l,int r,int ll,int rr){
    if(rr&lt;l||ll&gt;r)return INF;
    if(ll&lt;=l&&r&lt;=rr)return tr[a];
    int mid=l+r&gt;&gt;1;
    return min(query(a&lt;&lt;1,l,mid,ll,rr),query(a&lt;&lt;1|1,mid+1,r,ll,rr));
}
inline void modify(int a,int l,int r,int x){
    if(x&lt;l||r&lt;x)return;
    if(l==r){
        tr[a]=(is_square(idx[l]))?*minn[idx[l]].begin():w[idx[l]];
        return;
    }
    int mid=l+r&gt;&gt;1;
    modify(a&lt;&lt;1,l,mid,x);modify(a&lt;&lt;1|1,mid+1,r,x);
    tr[a]=min(tr[a&lt;&lt;1],tr[a&lt;&lt;1|1]);
}
inline int qry(int x,int y){
    int ans=INF;
    while(top[x]!=top[y]){
        if(dep[top[x]]&lt;dep[top[y]])swap(x,y);
        ans=min(ans,query(1,1,n+l,pos[top[x]],pos[x]));
        x=fa[top[x]];
    }
    if(dep[x]&gt;dep[y])swap(x,y);
    ans=min(ans,query(1,1,n+l,pos[x],pos[y]));
    return is_square(x)?min(ans,query(1,1,n+l,pos[fa[x]],pos[fa[x]])):ans;
}
inline void mdy(int x,int y){
    if(fa[x]){
        minn[fa[x]].insert(y);
        minn[fa[x]].erase(minn[fa[x]].find(w[x]));
        modify(1,1,n+l,pos[fa[x]]);
    }
    w[x]=y;
    modify(1,1,n+l,pos[x]);
}
int main(){
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;T;
    for(int i=1;i&lt;=n;i++)cin&gt;&gt;w[i];
    for(int i=1;i&lt;=m;i++){
        int u,v;
        cin&gt;&gt;u&gt;&gt;v;
        g.add(u,v);
        g.add(v,u);
    }
    tarjan(1,0);
    init();build(1,1,n+l);
    for(int i=1;i&lt;=T;i++){
        char c;
        int x,y;
        cin&gt;&gt;c&gt;&gt;x&gt;&gt;y;
        if(c=='C')mdy(x,y);
        if(c=='A')cout&lt;&lt;qry(x,y)&lt;&lt;'\n';
    }
    return 0;
}
    </pre><I>参考资料：<a href="https://www.cnblogs.com/luyouqi233/p/12269428.html">博客园@LuYouQi233</a></I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P4606">P4606 [SDOI2018] 战略游戏</a><a href="https://www.luogu.com.cn/problem/list?difficulty=6">省选/NOI-</a>这道题是虚树+圆方树解的，大佬很轻松就搞定了，但我不会。<pre>
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
using namespace std;
const int N = 2e5+10;
int T,n,m,q,dfc,cnt,ans,p[N],dfn[N],low[N],s[N];
int pn,dis[N],dep[N],fa[N],top[N],siz[N],son[N];
vector&lt;int&gt; G[N],H[N];
stack&lt;int&gt; S;
void tarjan(int x){
    dfn[x]=low[x]=++dfc;
    S.push(x);
    for(int y:H[x]){
        if(!dfn[y]){
            tarjan(y);
            low[x]=min(low[x],low[y]);
            if(low[y]==dfn[x]){
                int k;
                ++n;
                do{
                    k=S.top();S.pop();
                    G[n].push_back(k);
                    G[k].push_back(n);
                }while(k!=y);
                G[n].push_back(x);
                G[x].push_back(n);
            }
        }
        else{
            low[x]=min(low[x],dfn[y]);
        }
    }
}
void dfs1(int x){
    dfn[x]=++dfc;
    siz[x]=1;
    dep[x]=dep[fa[x]]+1;
    dis[x]=dis[fa[x]]+(x&lt;=pn);
    for(int y:G[x]){
        if(y==fa[x])continue;
        fa[y]=x;
        dfs1(y);
        siz[x]+=siz[y];
        if(siz[y]&gt;siz[son[x]]) son[x]=y;
    }
}
void dfs2(int x){
    if(son[x]){
        top[son[x]]=top[x];
        dfs2(son[x]);
    }
    for(int y:G[x]){
        if(y==fa[x]||y==son[x]) continue;
        top[y]=y;
        dfs2(y);
    }
}
int LCA(int x,int y){
    while(top[x]!=top[y]){
        if(dep[top[x]]&lt;dep[top[y]]) swap(x,y);
        x=fa[top[x]];
    }
    return dep[x]&lt;dep[y]?x:y;
}
void Add(int x){
    if(!cnt){
        s[++cnt]=x;
        return;
    }
    int lca=LCA(x,s[cnt]);
    while(cnt&gt;1&&dep[s[cnt-1]]&gt;dep[lca]){
        ans+=dis[s[cnt]]-dis[s[cnt-1]];
        cnt--;
    }
    if(dep[s[cnt]]&gt;dep[lca]){
        ans+=dis[s[cnt]]-dis[lca];
        cnt--;
    }
    if(s[cnt]!=lca){
        s[++cnt]=lca;
    }
    s[++cnt]=x;
}
bool cmp(int x,int y){
    return dfn[x]&lt;dfn[y];
}
int main(){
    cin&gt;&gt;T;
    while(T--){
        cin&gt;&gt;n&gt;&gt;m;
        dfc=0,pn=n;
        for(int i=1;i&lt;=2*n;i++){
            H[i].clear();
            G[i].clear();
            dfn[i]=low[i]=son[i]=0;
        }
        for(int i=1;i&lt;=m;i++){
            int x,y;
            cin&gt;&gt;x&gt;&gt;y;
            H[x].push_back(y);
            H[y].push_back(x);
        }
        tarjan(1);dfc=0;
        dfs1(1);top[1]=1;
        dfs2(1);
        cin&gt;&gt;q;
        while(q--){
            cin&gt;&gt;m;
            for(int i=1;i&lt;=m;i++){
                cin&gt;&gt;p[i];
            }
            sort(p+1,p+m+1,cmp);
            cnt=ans=0;
            for(int i=1;i&lt;=m;i++){
                Add(p[i]);
            }
            while(cnt&gt;1){
                ans+=dis[s[cnt]]-dis[s[cnt-1]];
                cnt--;
            }
            cout&lt;&lt;ans-m+(LCA(p[1],p[m])&lt;=pn)&lt;&lt;'\n';
        }
    }
    return 0;
}
</pre><I>
    参考资料：<a href="https://www.cnblogs.com/QuantAsk/p/14386276.html">博客园大佬的题解，十分简洁</a>
</I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P3469">P3469 [POI2008] BLO-Blockade</a><a href="https://www.luogu.com.cn/problem/list?difficulty=5">提高+/省选-</a>tarjan割点的模板题，但我不会，所以抄的，不过题解挺容易理解的。<pre>
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
using namespace std;
const int N = 100010;
#define int long long
struct node{
    int to,nxt;
}e[N&lt;&lt;4];

int head[N&lt;&lt;4],tot;
void add(int u,int v){
    e[tot].to=v;
    e[tot].nxt=head[u];
    head[u]=tot++;
}
int n,m;
int vis[N],dfn[N],low[N],cnt,flag[N];
int res = 0;
vector&lt;int&gt; son[N];
int sontree[N];
void tarjan(int u,int fa){
    sontree[u]=1;
    vis[u]=1;
    dfn[u]=low[u]=++cnt;
    int child=0;
    int sum=0;
    for(int i=head[u];i+1;i=e[i].nxt){
        int v=e[i].to;
        if(!vis[v]){
            child++;
            tarjan(v,u);
            sontree[u]+=sontree[v];
            low[u]=min(low[u],low[v]);
            if(low[v]&gt;=dfn[u]){
                sum+=sontree[v];
                son[u].push_back(sontree[v]);
                if(u!=fa)flag[u]=1;
            }
        }
        else if(v!=fa){
            low[u]=min(low[u],dfn[v]);
        }
    }
    if(u==fa&&child&gt;1&&!flag[u]){
        flag[u]=1;
    }
    if(flag[u]){
        if(n-sum-1!=0) son[u].push_back(n-sum-1);
    }
}
signed main(){
    cin&gt;&gt;n&gt;&gt;m;
    memset(head,-1,sizeof(head));
    while(m--){
        int u,v;
        cin&gt;&gt;u&gt;&gt;v;
        add(u,v);
        add(v,u);
    }
    tarjan(1,1);
    for(int i=1;i&lt;=n;i++){
        int ans=2*(n-1);
        if(flag[i]&&son[i].size()&gt;1){
            for(int j=0;j&lt;son[i].size();j++){
                for(int k=j+1;k&lt;son[i].size();k++){
                    ans+=2*(son[i][j]*son[i][k]);
                }
            }
        }
        cout&lt;&lt;ans&lt;&lt;'\n';
    }
    return 0;
}
    </pre><I>
        参考资料：<a href="https://www.cnblogs.com/wabi/p/16750826.html">博客园·tarjan求割点</a>
    </I></div>
    <div class="t1"><a href="https://codeforces.com/problemset/problem/1000/E">E. We Need More Bosses</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a>这道题不难，tarjan缩点后重新建图，然后跑2遍dfs求直径就好了。<pre>
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;
const int N = 300200;
int dfn[N],low[N],co[N],col,num;
int st[N],top;
bool vis[N];
vector&lt;int&gt; G[N&lt;&lt;1],G2[N&lt;&lt;1];
int n,m;
int maxdis,maxv;
void tarjan(int x,int fa){
    dfn[x]=low[x]=++num;
    st[++top]=x;vis[x]=1;
    for(int v:G[x]){
        if(v==fa)continue;
        if(!dfn[v]){
            tarjan(v,x);
            low[x]=min(low[x],low[v]);
        }
        else if(vis[v]){
            low[x]=min(low[x],dfn[v]);
        }
    }
    if(dfn[x]==low[x]){
        col++;
        while(1){
            int y=st[top--];
            vis[y]=0;
            co[y]=col;
            if(y==x)break;
        }
    }
}
void dfs(int u,int f,int dis){
    if(maxdis&lt;dis){
        maxdis=dis;
        maxv=u;
    }
    for(int v:G2[u]){
        if(v==f)continue;
        dfs(v,u,dis+1);
    }
}
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    while(m--){
        int u,v;
        cin&gt;&gt;u&gt;&gt;v;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    tarjan(1,0);
    for(int i=1;i&lt;=n;i++){
        for(int j:G[i]){
            if(co[i]!=co[j]){
                G2[co[i]].push_back(co[j]);
            }
        }
    }
    dfs(1,-1,0);
    maxdis=0;
    dfs(maxv,-1,0);
    cout&lt;&lt;maxdis;
    return 0;
}
    </pre>虽然不难，但是我没做出来，抄的题解，挺好理解的。<I>参考资料：<a href="https://www.cnblogs.com/Nepenthe8/p/14313617.html">博客园·tarjan缩点、树上直径</a></I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P2863">P2863 [USACO06JAN] The Cow Prom S</a>tarjan算法模板题。<b>朴素版：</b><pre>
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;
const int N = 10010;
int n,m,a,b;
vector&lt;int&gt; e[N];
int dfn[N],low[N],tot;
int stk[N],instk[N],top;
int scc[N],siz[N],cnt;
void tarjan(int x){
    dfn[x]=low[x]=++tot;
    stk[++top]=x;instk[x]=1;
    for(int y:e[x]){
        if(!dfn[y]){
            tarjan(y);
            low[x]=min(low[x],low[y]);
        }
        else if(instk[y]){
            low[x]=min(low[x],dfn[y]);
        }
    }
    if(dfn[x]==low[x]){
        int y;
        ++cnt;
        do{
            y=stk[top--];
            instk[y]=0;
            scc[y]=cnt;
            ++siz[cnt];
        }while(y!=x);
    }
}
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    while(m--){
        cin&gt;&gt;a&gt;&gt;b;
        e[a].push_back(b);
    }
    for(int i=1;i&lt;=n;i++){
        if(!dfn[i])tarjan(i);
    }
    int ans=0;
    for(int i=1;i&lt;=cnt;i++){
        if(siz[i]&gt;1)ans++;
    }
    cout&lt;&lt;ans;
    return 0;
}
    </pre><b>使用STL栈版:</b><pre>
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
using namespace std;
const int N = 10010;
int n,m,a,b;
vector&lt;int&gt; e[N];
int dfn[N],low[N],tot;
stack&lt;int&gt; stk;
int scc[N],siz[N],cnt;
void tarjan(int x){
    dfn[x]=low[x]=++tot;
    stk.push(x);
    for(int y:e[x]){
        if(!dfn[y]){
            tarjan(y);
            low[x]=min(low[x],low[y]);
        }
        else if(!scc[y]){
            low[x]=min(low[x],dfn[y]);
        }
    }
    if(dfn[x]==low[x]){
        ++cnt;
        while(1){
            int y=stk.top();
            stk.pop();
            scc[y]=cnt;
            ++siz[cnt];
            if(y==x)break;
        }
    }
}
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    while(m--){
        cin&gt;&gt;a&gt;&gt;b;
        e[a].push_back(b);
    }
    for(int i=1;i&lt;=n;i++){
        if(!dfn[i])tarjan(i);
    }
    int ans=0;
    for(int i=1;i&lt;=cnt;i++){
        if(siz[i]&gt;1)ans++;
    }
    cout&lt;&lt;ans;
    return 0;
}
    </pre><I>参考资料：<a href="https://www.cnblogs.com/dx123/p/16320476.html">董晓算法·强连通分量tarjan算法</a></I></div>
    <div class="t1">连通性问题<img src="https://upload-bbs.miyoushe.com/upload/2024/11/11/198629752/d6f9c1b61fc3c93a83fb3a4e83bf2ce4_4286196103297992497.png" alt="连通性问题"></div>
    <div class="t1"><a href="https://codeforces.com/problemset/problem/1120/D">D. Power Tree</a><a href="https://www.luogu.com.cn/problem/list?difficulty=6">省选/NOI-</a>一题多解，但我不会解。<b>法1.区间转差分的思想+最小生成树</b><b>法2.DP</b><pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
using namespace std;
const int N = 1e6+5;
int n,dfc,id_lf,c[N],u[N],v[N],fa[N],lf[N],rf[N],dfn[N],num[N];
vector&lt;int&gt; G[N];
struct J{
    int u,v,w,id;
}e[N];
int find(int x){
    return x==fa[x]?x:fa[x]=find(fa[x]);
}
void unite(int x,int y){
    fa[find(y)]=find(x);
}
void dfs1(int x,int p){
    bool is_lf=1;
    for(int i=0;i&lt;G[x].size();i++){
        int y=G[x][i];
        if(y^p)is_lf=0,dfs1(y,x);
    }
    if(is_lf)num[x]=++id_lf;
}
void dfsa(int x,int p){
    dfn[++dfc]=x;
    for(int i=0;i&lt;G[x].size();i++){
        int y=G[x][i];
        if(y^p)dfsa(y,x);
    }
    rf[x]=num[dfn[dfc]];
}
void dfsb(int x,int p){
    dfn[++dfc]=x;
    for(int i=0;i&lt;G[x].size();i++){
        int y=G[x][i];
        if(y^p)dfsb(y,x);
    }
    lf[x]=num[dfn[dfc]];
}
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)cin&gt;&gt;c[i];
    for(int i=1;i&lt;n;i++)cin&gt;&gt;u[i]&gt;&gt;v[i];
    for(int i=1;i&lt;n;i++)G[u[i]].push_back(v[i]),G[v[i]].push_back(u[i]);
    dfs1(1,0);
    for(int i=1;i&lt;=id_lf+1;i++)fa[i]=i;
    dfsa(1,0);
    for(int i=1;i&lt;=n;i++)G[i].clear();
    for(int i=n-1;i;i--)G[u[i]].push_back(v[i]),G[v[i]].push_back(u[i]);
    dfc=0;dfsb(1,0);
    for(int i=1;i&lt;=n;i++)e[i].u=lf[i],e[i].v=rf[i]+1,e[i].w=c[i],e[i].id=i;
    sort(e+1,e+n+1,[](J a,J b){return a.w&lt;b.w;});
    vector&lt;int&gt; st;
    long long sum=0;
    for(int i=1;i&lt;=n;i++){
        int j=i-1;
        while(j&lt;n&&e[j+1].w==e[i].w){
            j++;
            if(find(e[j].u)!=find(e[j].v))st.push_back(e[j].id);
        }
        j=i-1;
        while(j&lt;n&&e[j+1].w==e[i].w){
            j++;
            if(find(e[j].u)!=find(e[j].v))unite(e[j].u,e[j].v),sum+=e[j].w;
        }
        i=j;
    }
    cout&lt;&lt;sum&lt;&lt;' '&lt;&lt;st.size()&lt;&lt;'\n';
    sort(st.begin(),st.end());
    for(int i=0;i&lt;st.size();i++){
        cout&lt;&lt;st[i]&lt;&lt;' ';
    }
    return 0;
}
</pre><I>参考资料：<a href="https://www.cnblogs.com/impyl/p/16101016.html">博客园一题多解大佬！</a></I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P3623">P3623 [APIO2008] 免费道路</a><a href="https://www.luogu.com.cn/problem/list?difficulty=6">省选/NOI-</a>这就很让人无语，题目很难，翻译过来应该是: <b>给定n个点m条边，边权为0或1的图，求一棵边权和为k的最小生成树。若不存在则输出no solution。</b><pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
using namespace std;
#define no_solution printf("no solution\n")
#define maxn 202020
int n,m,k,fa[maxn],tot,cnt;
struct edge{
    int u,v,w;
}e[maxn],ans[maxn];
bool cmp1(edge e1,edge e2){
    return e1.w&gt;e2.w;
}
bool cmp2(edge e1,edge e2){
    return e1.w&lt;e2.w;
}
int find(int x){
    if(fa[x]==x)return x;
    return fa[x]=find(fa[x]);
}
bool Union(int x,int y){
    x=find(x),y=find(y);
    if(x==y)return 0;
    fa[x]=y;
    return 1;
}
void init(){
    cnt=tot=0;
    for(int i=1;i&lt;=n;i++)fa[i]=i;
}
void check(){
    int tmp=find(1);
    for(int i=2;i&lt;=n;i++){
        int f=find(i);
        if(f!=tmp){
            no_solution;
            exit(0);
        }
        tmp=f;
    }
}
int main(){
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;
    for(int i=1;i&lt;=m;i++){
        cin&gt;&gt;e[i].u&gt;&gt;e[i].v&gt;&gt;e[i].w;
    }
    init();sort(e+1,e+m+1,cmp1);
    for(int i=1;i&lt;=m;i++){
        if(Union(e[i].u,e[i].v)&&e[i].w==0){
            tot++,e[i].w=-1;
        }
    }
    if(tot&gt; k){
        no_solution;
        return 0;
    };
    check();
    init();
    sort(e+1,e+m+1,cmp2);
    for(int i=1;i&lt;=m;i++){
        int f1=find(e[i].u),f2=find(e[i].v);
        if(f1==f2)continue;
        if(e[i].w==1||tot&lt;k){
            ans[++cnt]=e[i];fa[f1]=f2;
            if(e[i].w&lt;1){
                tot++,e[i].w=0;
            }
        }
    }
    if(tot&lt;k){
        no_solution;
        return 0;
    }
    check();
    for(int i=1;i&lt;=cnt;i++){
        if(ans[i].w==-1)ans[i].w=0;
        cout&lt;&lt;ans[i].u&lt;&lt;" "&lt;&lt;ans[i].v&lt;&lt;" "&lt;&lt;ans[i].w&lt;&lt;'\n';
    }
    return 0;
}
    </pre>由于我是蒟蒻，所以这道题我不会写，抄的题解，而且也没看懂。<I>
        参考资料：<a href="https://www.luogu.com.cn/problem/solution/P3623">题解区@Gypsophila</a>、<a href="https://www.cnblogs.com/Kan-kiz/p/10783561.html">博客园@Kan_kiz</a>
    </I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P2700">P2700 逐个击破</a><a href="https://www.luogu.com.cn/problem/list?difficulty=3">普及/提高-</a>这道题好难！先用ans求出所有边权和，然后求最大生成树，ans不断减去最大生成树的边，最后输出ans就行了，如果vis[a]和vis[b]都是目标节点，那么就continue跳过，否则加入最大生成树。<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
using namespace std;
#define maxn 3000000
#define int long long
struct edge{
    int u,v,w;
    bool operator &lt; (const edge &a)const{
        return w&gt;a.w;
    }
}e[maxn];
int fa[maxn],ans,n,k,vis[maxn];
int find(int x){
    if(fa[x]==x)return x;
    return fa[x]=find(fa[x]);
}
void kruskal(){
    for(int i=1;i&lt;=n;i++){
        fa[i]=i;
    }
    sort(e+1,e+n);
    for(int i=1;i&lt;n;i++){
        int x=find(e[i].u);
        int y=find(e[i].v);
        if(vis[x]&&vis[y])continue;
        fa[x]=y;
        ans-=e[i].w;
        if(vis[x])vis[y]=1;
        else if(vis[y])vis[x]=1;
    }
}
signed main(){
    cin&gt;&gt;n&gt;&gt;k;
    for(int i=1,x;i&lt;=k;i++){
        cin&gt;&gt;x;vis[x]=1;
    }
    for(int i=1;i&lt;n;i++){
        cin&gt;&gt;e[i].u&gt;&gt;e[i].v&gt;&gt;e[i].w;
        ans+=e[i].w;
    }
    kruskal();
    cout&lt;&lt;ans;
    return 0;
}
    </pre><I>参考资料：<a href="https://www.luogu.com.cn/problem/solution/P2700">题解区@顾z</a></I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1967">P1967 [NOIP2013 提高组] 货车运输</a><a href="https://www.luogu.com.cn/problem/list?difficulty=5">提高+/省选-</a>这道题一眼就能看出来是求最大生成树，然后求最大生成树上面的链路上的最小值，但是有一个问题，这道题的题解是用LCA和倍增来做，我很疑惑倍增难道不会跳过~吗？来自群聊大佬的回答：“用RMQ在跳之前先查一下自己这个位置与跳跃目标位置的区间最小值就好了，这样就不会跳过头了”。但我还是不懂，因为RMQ没学过。<pre>
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
using namespace std;
#define maxn 10005
#define inf 99999999
struct Edge1{
    int x,y,dis;
}edge1[50005];
struct Edge2{
    int to,nxt,w;
}edge2[100005];
int cnt,n,m,head[maxn],deep[maxn],f[maxn],fa[maxn][21],w[maxn][21];
bool vis[maxn];
void addedge(int from,int to,int w){
    edge2[++cnt].nxt=head[from];
    edge2[cnt].to=to;
    edge2[cnt].w=w;
    head[from]=cnt;
    return;
}
bool cmp(Edge1 x,Edge1 y){
    return x.dis&gt;y.dis;
}
int find(int x){
    if(f[x]!=x)f[x]=find(f[x]);
    return f[x];
}
void kruskal(){
    sort(edge1+1,edge1+m+1,cmp);
    for(int i=1;i&lt;=n;i++){
        f[i]=i;
    }
    for(int i=1;i&lt;=m;i++){
        if(find(edge1[i].x)!=find(edge1[i].y)){
            f[find(edge1[i].x)]=find(edge1[i].y);
            addedge(edge1[i].x,edge1[i].y,edge1[i].dis);
            addedge(edge1[i].y,edge1[i].x,edge1[i].dis);
        }
    }
}
void dfs(int node){
    vis[node]=1;
    for(int i=head[node];i;i=edge2[i].nxt){
        int to=edge2[i].to;
        if(vis[to])continue;
        deep[to]=deep[node]+1;
        fa[to][0]=node;
        w[to][0]=edge2[i].w;
        dfs(to);
    }
}
int lca(int x,int y){
    if(find(x)!=find(y))return -1;
    int ans=inf;
    if(deep[x]&gt;deep[y])swap(x,y);
    for(int i=20;i&gt;=0;i--){
        if(deep[fa[y][i]]&gt;=deep[x]){
            ans=min(ans,w[y][i]);
            y=fa[y][i];
        }
    }
    if(x==y)return ans;
    for(int i=20;i&gt;=0;i--){
        if(fa[x][i]!=fa[y][i]){
            ans=min(ans,min(w[x][i],w[y][i]));
            x=fa[x][i];
            y=fa[y][i];
        }
    }
    ans=min(ans,min(w[x][0],w[y][0]));
    return ans;
}
int main(){
    int x,y,z,q;
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=m;i++){
        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;
        edge1[i].x=x;
        edge1[i].y=y;
        edge1[i].dis=z;
    }
    kruskal();
    for(int i=1;i&lt;=n;i++){
        if(!vis[i]){
            deep[i]=1;
            dfs(i);
            fa[i][0]=i;
            w[i][0]=inf;
        }
    }
    for(int i=1;i&lt;=20;i++){
        for(int j=1;j&lt;=n;j++){
            fa[j][i]=fa[fa[j][i-1]][i-1];
            w[j][i]=min(w[j][i-1],w[fa[j][i-1]][i-1]);
        }
    }
    cin&gt;&gt;q;
    for(int i=1;i&lt;=q;i++){
        cin&gt;&gt;x&gt;&gt;y;
        cout&lt;&lt;lca(x,y)&lt;&lt;'\n';
    }
    return 0;
}
    
    </pre><I>参考资料：<a href="https://www.luogu.com.cn/problem/solution/P1967">题解区@crazydave</a></I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1550">P1550 [USACO08OCT] Watering Hole G</a><a href="https://www.luogu.com.cn/problem/list?difficulty=3">普及/提高-</a>一遍AK，不过也是在大佬的提醒下我才一遍过的。要多连一条边，类比超级源点，从地下向地上所有田地连一条边代表水井就好了。<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
using namespace std;
#define maxn 300000
struct edge{
    int u,v,w;
    bool operator &lt; (const edge &a)const{
        return w&lt;a.w;
    }
}e[maxn];
int n,m;
int fa[maxn],ans;
int find(int x){
    if(fa[x]==x)return x;
    return fa[x]=find(fa[x]);
}
void build(int x,int y,int z){
    m++;
    e[m].u=x;
    e[m].v=y;
    e[m].w=z;
}
void kruskal(){
    for(int i=1;i&lt;=n;i++){
        fa[i]=i;
    }
    sort(e+1,e+m+1);
    for(int i=1;i&lt;=m;i++){
        int x=find(e[i].u);
        int y=find(e[i].v);
        if(x!=y){
            fa[x]=y;
            ans+=e[i].w;
        }
    }
}
int main(){
    cin&gt;&gt;n;
    for(int i=1,x;i&lt;=n;i++){
        cin&gt;&gt;x;
        build(0,i,x);
    }
    for(int i=1,x;i&lt;=n;i++){
        for(int j=1;j&lt;=n;j++){
            cin&gt;&gt;x;
            if(i&lt;j)build(i,j,x);
        }
    }
    kruskal();
    cout&lt;&lt;ans;
    return 0;
}
    </pre><I>参考资料：<a href="https://www.luogu.com.cn/problem/solution/P1550">题解区@Mr_QwQ</a></I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1195">P1195 口袋的天空</a><a href="https://www.luogu.com.cn/problem/list?difficulty=3">普及/提高-</a>因为一个判断给我整红温了。这道题挺简单，说百了就是给你n个点，让你从这n个点中之选择n-k个构造最小生成树，而最难的就是这个判断到底是cnt&lt;=n-k还是cnt&lt;n-k，以及最后的return到底是cnt==n-k还是cnt&gt;=n-k？？？看了题解才知道，原来是这样：<pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
using namespace std;
#define maxn 300000
int n,m,k;
struct edge{
    int u,v,w;
    bool operator &lt; (const edge &a)const{
        return w&lt;a.w;
    }
}e[maxn];
int fa[maxn],cnt,ans;
int find(int x){
    if(fa[x]==x){
        return x;
    }
    return fa[x]=find(fa[x]);
}
bool kruskal(){
    for(int i=1;i&lt;=n;i++){
        fa[i]=i;
    }
    sort(e+1,e+m+1);
    for(int i=1;i&lt;=m&&cnt&lt;n-k;i++){
        int x=find(e[i].u);
        int y=find(e[i].v);
        if(x!=y){
            fa[x]=y;
            cnt++;
            ans+=e[i].w;
        }
    }
    return cnt&gt;=n-k;
}
int main(){
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;
    for(int i=1;i&lt;=m;i++){
        cin&gt;&gt;e[i].u&gt;&gt;e[i].v&gt;&gt;e[i].w;
    }
    if(kruskal()){
        cout&lt;&lt;ans;
    }
    else{
        cout&lt;&lt;"No Answer";
    }
    return 0;
}
    </pre><I>参考资料：<a href="https://www.luogu.com.cn/problem/solution/P1195">题解区@yangrunze</a></I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1396">P1396 营救</a><a href="https://www.luogu.com.cn/problem/list?difficulty=3">普及/提高-</a>题解上面很简单就水过去了，但我暴力却只有20分。如下是满分代码：<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
using namespace std;
#define maxn 30000
int n,m,s,t;
struct edge{
    int u,v,w;
    bool operator &lt; (const edge &a)const{
        return w&lt;a.w;
    }
}e[maxn];
int fa[maxn];
int find(int x){
    if(fa[x]==x)return x;
    return fa[x]=find(fa[x]);
}
void kruskal(){
    sort(e+1,e+m+1);
    for(int i=1;i&lt;=n;i++){
        fa[i]=i;
    }
    for(int i=1;i&lt;=m;i++){
        int x=find(e[i].u);
        int y=find(e[i].v);
        if(x!=y){
            fa[x]=y;
        }
        if(find(s)==find(t)){
            cout&lt;&lt;e[i].w;
            return;
        }
    }
}
int main(){
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;
    for(int i=1;i&lt;=m;i++){
        cin&gt;&gt;e[i].u&gt;&gt;e[i].v&gt;&gt;e[i].w;
    }
    kruskal();
    return 0;
}
</pre><I>参考资料：<a href="https://www.luogu.com.cn/problem/solution/P1396">题解区@lzk5627</a></I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P4180">P4180 [BJWC2010] 严格次小生成树</a><a href="https://www.luogu.com.cn/problem/list?difficulty=5">提高+/省选-</a>怪不得我不会，因为太难了。<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;climits&gt;
#include &lt;algorithm&gt;
using namespace std;
#define ll long long
#define N 300100
const ll inf=0x3f3f3f3f3f3f3f3f;
int n,m;
struct node{
    int u,v,nxt;
    ll w;
}a[3*N],E[3*N];
bool cmp(node x,node y){
    return x.w&lt;y.w;
}
int p[N],eid,fa[N],f[N][23],d[N];
ll mx[N][22],cmx[N][22],W;
vector&lt;node&gt; G[3*N];
bool used[3*N];
void add(int u,int v,ll w){
    E[eid].u=u;
    E[eid].v=v;
    E[eid].nxt=p[u];
    E[eid].w=w;
    p[u]=eid++;
}
void init(){
    memset(mx,-1,sizeof(mx));
    memset(cmx,-1,sizeof(cmx));
    memset(p,-1,sizeof(p));
    eid=1;
    for(int i=1;i&lt;=n;i++){
        fa[i]=i;
    }
}
int find(int x){
    if(fa[x]==x){
        return fa[x];
    }
    return fa[x]=find(fa[x]);
}
void kruskal(){
    sort(a,a+m,cmp);
    for(int i=0;i&lt;m;i++){
        int fu=find(a[i].u),fv=find(a[i].v);
        if(fu!=fv){
            fa[fv]=fu;
            W+=a[i].w;
            add(a[i].u,a[i].v,a[i].w);
            add(a[i].v,a[i].u,a[i].w);
            used[i]=1;
        }
    }
}
void dfs(int u){
    d[u]=d[f[u][0]]+1;
    for(int i=p[u];i!=-1;i=E[i].nxt){
        int v=E[i].v;
        if(v!=f[u][0]){
            mx[v][0]=E[i].w;
            cmx[v][0]=-inf;
            f[v][0]=u;
            dfs(v);
        }
    }
}
void init_LCA(){
    for(int i=1;i&lt;=n;i++){
        fa[i]=0;
    }
    dfs(1);
    for(int j=1;(1&lt;&lt;j)&lt;=n;j++){
        for(int i=1;i&lt;=n;i++){
            f[i][j]=f[f[i][j-1]][j-1];
            mx[i][j]=max(mx[i][j-1],mx[f[i][j-1]][j-1]);
            cmx[i][j]=max(cmx[i][j-1],cmx[f[i][j-1]][j-1]);
            if(mx[i][j-1]&gt;mx[f[i][j-1]][j-1]){
                cmx[i][j]=max(cmx[i][j],mx[f[i][j-1]][j-1]);
            }
            if(mx[i][j-1]&lt;mx[f[i][j-1]][j-1]){
                cmx[i][j]=max(cmx[i][j],mx[i][j-1]);
            }
        }
    }
}
ll LCA(int x,int y,ll w){
    if(d[x]&lt;d[y]){
        swap(x,y);
    }
    ll maxv=-inf;
    for(int i=20;i&gt;=0;--i){
        if(d[f[x][i]]&gt;=d[y]){
            if(mx[x][i]!=w){
                maxv=max(maxv,mx[x][i]);
            }
            else{
                maxv=max(maxv,cmx[x][i]);
            }
            x=f[x][i];
        }
    }
    if(x==y){
        return maxv;
    }
    for(int i=20;i&gt;=0;i--){
        if(f[x][i]!=f[y][i]){
            if(mx[x][i]!=w){
                maxv=max(maxv,mx[x][i]);
            }
            else{
                maxv=max(maxv,cmx[x][i]);
            }
            if(mx[y][i]!=w){
                maxv=max(maxv,mx[y][i]);
            }
            else{
                maxv=max(maxv,cmx[y][i]);
            }
            x=f[x][i];
            y=f[y][i];
        }
    }
    if(mx[x][0]!=w){
        maxv=max(maxv,mx[x][0]);
    }
    else{
        maxv=max(maxv,cmx[x][0]);
    }
    if(mx[y][0]!=w){
        maxv=max(maxv,mx[y][0]);
    }
    else{
        maxv=max(maxv,cmx[y][0]);
    }
    return maxv;
}
ll getlen(int u,int v,ll w){
    ll maxv=LCA(u,v,w);
    return W+w-maxv;
}
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=0;i&lt;m;i++){
        cin&gt;&gt;a[i].u&gt;&gt;a[i].v&gt;&gt;a[i].w;
    }
    init();
    kruskal();
    init_LCA();
    ll ans=inf;
    for(int i=0;i&lt;m;i++){
        if(!used[i]){
            ans=min(ans,getlen(a[i].u,a[i].v,a[i].w));
        }
    }
    cout&lt;&lt;ans;
    return 0;
}
    </pre><I>参考资料：<a href="https://www.cnblogs.com/Ryan-juruo/p/15222816.html">博客园@Ryan-Liu</a></I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P5651">P5651 基础最短路练习题</a><a href="https://www.luogu.com.cn/problem/list?difficulty=3">普及/提高-</a>虽然说是最短路练习题，但其实你也可以用最小生成树来解，这里面还存在负边，也就是说异或起来还需要考虑负数的情况。其实我也不会，我暴力打了40pts。100分正解如下：<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;
#define maxn 1000000
int n,m,Q;
struct edge{
    int v,w;
};
struct node{
    int dis,u;
    bool operator &lt; (const node &a)const{
        return dis&lt;a.dis;
    }
};
vector&lt;edge&gt; e[maxn];
int dis[maxn],vis[maxn],cnt;
void dij(int s){
    memset(dis,0x3f,sizeof(dis));
    memset(vis,0,sizeof(vis));
    dis[s]=0;
    priority_queue&lt;node&gt; q;
    q.push({0,s});
    while(!q.empty()){
        int u=q.top().u;
        q.pop();
        if(vis[u])continue;
        vis[u]=1;
        for(auto ed:e[u]){
            int v=ed.v,w=ed.w;
            if(dis[v]&gt;=dis[u]^w||cnt==m){
                dis[v]=dis[u]^w;
                q.push({-dis[v],v});
            }
        }
    }
}
int main(){
    scanf("%d%d%d",&n,&m,&Q);
    for(int i=1,u,v,w;i&lt;=m;i++){
        scanf("%d%d%d",&u,&v,&w);
        e[u].push_back({v,w});
        e[v].push_back({u,w});
        if(w&lt;=1)cnt++;
    }
    dij(1);
    while(Q--){
        int x,y;
        scanf("%d%d",&x,&y);
        printf("%d\n",dis[x]^dis[y]);
    }
    return 0;
}
</pre>容易想到的是对于每次询问都求一遍以x为起点y为终点的最短路，但其实只需要求一次以1为起点的最短路，然后用dis[x]^dis[y]就是x->y的最短路了。具体原理我也不清楚。<I>参考资料：<a href="https://www.luogu.com.cn/problem/solution/P5651">题解区@爷，无限霸气</a></I></div>
    <div class="t1"><a href="https://codeforces.com/problemset/problem/472/D">D. Design Tutorial: Inverse the Problem</a><a href="https://www.luogu.com.cn/problem/list?difficulty=5">提高+/省选-</a>这道题因为数组没开大导致超时也是无敌了。这道题也是一道最小生成树模板题，但是我却不会。<pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;
#define maxn 2010
#define inf 2147483647
int mp[maxn][maxn],dis[maxn],vis[maxn],lst[maxn],head[maxn];
int n,tot;
struct node{
    int nxt,to,val;
}edge[maxn*2];
void add(int u,int v,int w){
    edge[tot].nxt=head[u];
    edge[tot].to=v;
    edge[tot].val=w;
    head[u]=tot;
    ++tot;
}
void prim(){
    for(int i=1;i&lt;=n;i++)dis[i]=inf;
    for(int i=2;i&lt;=n;i++){
        dis[i]=mp[1][i];
        lst[i]=1;
    }
    dis[1]=0;
    vis[1]=1;
    for(int i=1;i&lt;n;i++){
        int x=0,Min=inf;
        for(int j=1;j&lt;=n;j++){
            if(!vis[j]&&dis[j]&lt;Min){
                Min=dis[j];
                x=j;
            }
        }
        if(!x)break;
        vis[x]=1;
        add(x,lst[x],dis[x]);
        add(lst[x],x,dis[x]);
        for(int j=1;j&lt;=n;j++){
            if(!vis[j]&&dis[j]&gt;mp[x][j]){
                dis[j]=mp[x][j];
                lst[j]=x;
            }
        }
    }
}
void dfs(int x,int fa){
    for(int i=head[x];i!=-1;i=edge[i].nxt){
        int y=edge[i].to;
        int z=edge[i].val;
        if(y==fa)continue;
        dis[y]=dis[x]+z;
        dfs(y,x);
    }
}
int main(){
    memset(head,-1,sizeof(head));
    scanf("%d",&n);
    for(int i=1;i&lt;=n;i++){
        for(int j=1;j&lt;=n;j++){
            scanf("%d",&mp[i][j]);
            if(i!=j&&mp[i][j]==0){
                puts("NO");
                return 0;
            }
            if(i==j&&mp[i][j]!=0){
                puts("NO");
                return 0;
            }
        }
    }
    prim();
    for(int i=1;i&lt;=n;i++){
        dis[i]=0;
        dfs(i,0);
        for(int j=1;j&lt;=n;j++){
            if(dis[j]!=mp[i][j]){
                puts("NO");
                return 0;
            }
        }
    }
    puts("YES");
    return 0;
}
</pre>大家的题解都是用链式前向星写的，但我不太习惯那种写法。这道题似乎只能用prim的朴素版来解。<I>参考资料：<a href="https://www.luogu.com.cn/problem/solution/CF472D">题解区@_Shine__</a></I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1194">P1194 买礼物</a><a href="https://www.luogu.com.cn/problem/list?difficulty=3">普及/提高-</a>这道题就是一道最小生成树模板题。可惜我不会，因此又是抄题解。注意建边的时候除了将给的矩阵的边建完后还要连一条从0向所有点的边。<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
using namespace std;
#define maxn 300000
int n,m,k;
struct edge{
    int u,v,w;
    bool operator &lt; (const edge &a)const{
        return w&lt;a.w;
    }
}e[maxn];
int fa[maxn],ans,cnt;
int find(int x){
    if(fa[x]==x){
        return x;
    }
    return fa[x]=find(fa[x]);
}
void build(int x,int y,int z){
    k++;
    e[k].u=x;
    e[k].v=y;
    e[k].w=z;
}
bool kruskal(){
    sort(e+1,e+k+1);
    for(int i=0;i&lt;=m;i++){
        fa[i]=i;
    }
    for(int i=1;i&lt;=k;i++){
        int x=find(e[i].u);
        int y=find(e[i].v);
        if(x!=y){
            fa[x]=y;
            ans+=e[i].w;
            cnt++;
        }
    }
    return cnt==n-1;
}
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1,x;i&lt;=m;i++){
        for(int j=1;j&lt;=m;j++){
            cin&gt;&gt;x;
            if(i&lt;j&&x){
                build(i,j,x);
            }
        }
    }
    for(int i=1;i&lt;=m;i++){
        build(0,i,n);
    }
    kruskal();
    cout&lt;&lt;ans;
    return 0;
}
</pre>这是Kruskal求最小生成树。<I>参考资料：<a href="https://www.luogu.com.cn/problem/solution/P1194">题解区@青丝、暮成雪</a></I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P3366">P3366 【模板】最小生成树</a><a href="https://www.luogu.com.cn/problem/list?difficulty=3">普及/提高-</a>最小生成树的代码和Dijkstra有点像，代码很好打。<b>Prim算法求最小生成树</b>1.普通版：<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;
#define inf 1e9
#define N 6000
int n,m,ans,cnt;
struct edge{
    int v,w;
};
vector&lt;edge&gt; e[N];
int d[N],vis[N];
bool prim(int s){
    for(int i=0;i&lt;=n;i++){
        d[i]=inf;
    }
    d[s]=0;
    for(int i=1;i&lt;=n;i++){
        int u=0;
        for(int j=1;j&lt;=n;j++){
            if(!vis[j]&&d[j]&lt;d[u]){
                u=j;
            }
        }
        vis[u]=1;
        ans+=d[u];
        if(d[u]!=inf){
            cnt++;
        }
        for(auto ed:e[u]){
            int v=ed.v,w=ed.w;
            if(d[v]&gt;w){
                d[v]=w;
            }
        }
    }
    return cnt==n;
}
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1,u,v,w;i&lt;=m;i++){
        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
        e[u].push_back({v,w});
        e[v].push_back({u,w});
    }
    if(prim(1)){
        cout&lt;&lt;ans;
    }
    else{
        cout&lt;&lt;"orz";
    }
    return 0;
}
</pre>2.堆优化版：<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
using namespace std;
#define inf 1e9
#define N 6000
int n,m,ans,cnt;
struct edge{
    int v,w;
};
struct node{
    int dis,u;
    bool operator &lt; (const node &a)const{
        return dis &lt; a.dis;
    }
};
vector&lt;edge&gt; e[N];
int d[N],vis[N];
priority_queue&lt;node&gt; q;
bool prim(int s){
    for(int i=1;i&lt;=n;i++){
        d[i]=inf;
    }
    d[s]=0;
    q.push({0,s});
    while(!q.empty()){
        int u=q.top().u;
        q.pop();
        if(vis[u])continue;
        vis[u]=1;
        ans+=d[u];
        cnt++;
        for(auto ed:e[u]){
            int v=ed.v,w=ed.w;
            if(d[v]&gt;w){
                d[v]=w;
                q.push({-d[v],v});
            }
        }
    }
    return cnt==n;
}
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1,u,v,w;i&lt;=m;i++){
        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
        e[u].push_back({v,w});
        e[v].push_back({u,w});
    }
    if(prim(1)){
        cout&lt;&lt;ans;
    }
    else{
        cout&lt;&lt;"orz";
    }
    return 0;
}
</pre><br><b>Kruskal算法求最小生成树</b><pre>
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
#define N 300000
int n,m;
struct edge{
    int u,v,w;
    bool operator &lt; (const edge &a)const{
        return w&lt;a.w;
    }
}e[N];
int fa[N],ans,cnt;
int find(int x){
    if(fa[x]==x){
        return x;
    }
    return fa[x]=find(fa[x]);
}
bool kruskal(){
    sort(e,e+m);
    for(int i=1;i&lt;=n;i++){
        fa[i]=i;
    }
    for(int i=1;i&lt;=m;i++){
        int x=find(e[i].u);
        int y=find(e[i].v);
        if(x!=y){
            fa[x]=y;
            ans+=e[i].w;
            cnt++;
            
        }
    }
    return cnt==n-1;
}
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=m;i++){
        cin&gt;&gt;e[i].u&gt;&gt;e[i].v&gt;&gt;e[i].w;
    }
    if(kruskal()){
        cout&lt;&lt;ans;
    }
    else{
        cout&lt;&lt;"orz";
    }
    return 0;
}
</pre><I>
    参考资料：博客园@董晓算法( <a href="https://www.cnblogs.com/dx123/p/16320452.html">最小生成树 Prim 算法</a>、<a href="https://www.cnblogs.com/dx123/p/16320454.html">最小生成树 Kruskal 算法</a> )
</I></div>
    <div class="t1">最小生成树<img src="https://upload-bbs.miyoushe.com/upload/2024/11/07/198629752/1bd42f0f2b49815d4a3d44d64a1b4a2c_6009894409766654602.png" alt="最小生成树"></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P2047">P2047 [NOI2007] 社交网络</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a><s>抄答案也得仔仔细细的抄哦~</s>这道题真的不简单呐！仍然是Floyd，解决点对问题，题目很好理解，但是代码一定要仔细，要不然很容易爆零！<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;
#define maxn 200
#define int long long
int n,m;
int g[maxn][maxn];
double I[maxn];
int C[maxn][maxn];
int inf=0x7f7f7f7f;
signed main(){
    cin&gt;&gt;n&gt;&gt;m;
    memset(g,0x7f,sizeof(g));
    inf=g[1][1];
    for(int i=1,a,b,c;i&lt;=m;i++){
        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
        g[a][b]=g[b][a]=c;
        C[a][b]=C[b][a]=1;
    }
    for(int k=1;k&lt;=n;k++){
        for(int i=1;i&lt;=n;i++){
            for(int j=1;j&lt;=n;j++){
                if(g[i][k]==inf&&g[k][j]==inf)continue;
                if(g[i][j]&gt;g[i][k]+g[k][j]){
                    g[i][j]=g[i][k]+g[k][j];
                    C[i][j]=C[i][k]*C[k][j];
                    continue;
                }
                if(g[i][j]==g[i][k]+g[k][j]){
                    C[i][j]+=C[i][k]*C[k][j];
                }
            }
        }
    }
    for(int k=1;k&lt;=n;k++){
        for(int i=1;i&lt;=n;i++){
            for(int j=1;j&lt;=n;j++){
                if(i==k||j==k||i==j)continue;
                if(g[i][j]==g[i][k]+g[k][j]){
                    I[k]+=(1.0*C[i][k]*C[k][j])/C[i][j];
                }
            }
        }
    }
    for(int i=1;i&lt;=n;i++){
        printf("%.3lf\n",I[i]);
    }
    return 0;
}
    
</pre><I>参考资料：<a href="https://www.luogu.com.cn/problem/solution/P2047">题解区@Ning_Mew</a></I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P2419">P2419 [USACO08JAN] Cow Contest S</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a><s>典中典的一个Floyd图论题目</s>这道题可以使用Floyd，不过思路有点超前，不太好想。<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;
#define maxn 300
int n,m;
int g[maxn][maxn]; 
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1,u,v;i&lt;=m;i++){
        cin&gt;&gt;u&gt;&gt;v;
        g[u][v]=1;
    }
    for(int k=1;k&lt;=n;k++){
        for(int i=1;i&lt;=n;i++){
            for(int j=1;j&lt;=n;j++){
                if(g[i][k]&&g[k][j]){
                    g[i][j]=1;
                }
            }
        }
    }
    int ans=0;
    for(int i=1;i&lt;=n;i++){
        int sum=0;
        for(int j=1;j&lt;=n;j++){
            if(g[i][j]||g[j][i]){
                sum++;
            }
        }
        if(sum==n-1)ans++;
    }
    cout&lt;&lt;ans;
    return 0;
}
    </pre>同样利用的是Floyd处理点对的性质，来解决这种比较关系的题目。f[i][j]=f[i][j]|(f[i][k]&f[k][j])表示i能否走到j，即要么一开始i能到j,要么i能到k，k再能到j。那么这里表示的是i能否赢j。用floyed求出每个点与个点的关系，只要这个点和其他n-1个点的关系都确定了，就能确定他的排名。<I>参考资料：<a href="https://www.luogu.com.cn/problem/solution/P2419">题解区@xun薰</a></I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1037">P1037 [NOIP2002 普及组] 产生数</a><a href="https://www.luogu.com.cn/problem/list?difficulty=3">普及/提高-</a>呜呜呜，我连普及都不如了？？？这道题有两种解法，一种是爆搜，满分；另一只是Floyd。<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
using namespace std;
int tag[10][10];
int d[10];
int p[1000];
int main(){
    string a;
    int n;
    while(cin&gt;&gt;a&gt;&gt;n){
        int x,y;
        for(int i=0;i&lt;n;i++){
            cin&gt;&gt;x&gt;&gt;y;
            tag[x][y]=1;
        }
        for(int k=1;k&lt;=9;k++){
            for(int i=0;i&lt;=9;i++){
                for(int j=0;j&lt;=9;j++){
                    if(tag[i][k]&&tag[k][j])tag[i][j]=1;
                }
            }
        }
        for(int i=0;i&lt;=9;i++){
            tag[i][i]=1;
            for(int j=0;j&lt;=9;j++){
                if(tag[i][j]){
                    d[i]++;
                }
            }
        }
        int z=0;
        p[0]=1;
        for(int i=0;a[i];i++){
            z=0;
            int x=d[a[i]-'0'];
            for(int i=0;i&lt;500;i++){
                p[i]=(p[i]*x+z);
                z=p[i]/10;
                p[i]%=10;
            }
        }
        int i=500;
        while(p[i]==0)i--;
        for(;i&gt;=0;i--){
            cout&lt;&lt;p[i];
        }
        cout&lt;&lt;'\n';
    }
}
    </pre><I>参考资料：<a href="https://www.luogu.com.cn/problem/solution/P1037">题解区@zhangjiangnan</a></I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1119">P1119 灾后重建</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a>这道题能加深你对Floyd的理解。这道题考得就是你对中转点的认识。<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;
#define maxn 300
int g[maxn][maxn];
int n,m;
int t[maxn];
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    memset(g,0x3f,sizeof(g));
    for(int i=0;i&lt;n;i++){
        cin&gt;&gt;t[i];
    }
    for(int i=1,u,v,w;i&lt;=m;i++){
        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
        g[u][v]=g[v][u]=w;
    }
    int Q;
    cin&gt;&gt;Q;
    int k=0;
    for(int i=1,u,v,tim;i&lt;=Q;i++){
        cin&gt;&gt;u&gt;&gt;v&gt;&gt;tim;
        for(;t[k]&lt;=tim&&k&lt;n;k++){
            for(int ii=0;ii&lt;n;ii++){
                for(int jj=0;jj&lt;ii;jj++){
                    if(g[ii][jj]&gt;g[ii][k]+g[k][jj]){
                        g[jj][ii]=g[ii][jj]=g[ii][k]+g[k][jj];
                    }
                }
            }
        }
        if(t[u]&gt;tim||t[v]&gt;tim)cout&lt;&lt;-1&lt;&lt;'\n';
        else cout&lt;&lt;(g[u][v]&gt;=1e9?-1:g[u][v])&lt;&lt;'\n';
        //注意，如果你想在速度上追求极致，三目运算符尽量不要用，if语句都比它快。 
    }
    return 0;
}
</pre>看到k了吗？我直接让k不从0开始，那样会重复计算，我们让k继承上一次的运算结果继续运算。因为k的本质就是中转点，k不符合条件时就暂时退出，下一次询问的时候再回来。如果不这么做，那么只有50分，TLE超时。<s>看题解愣是没看出来~</s><I>
    参考资料：<a href="https://www.luogu.com.cn/problem/solution/P1119">题解区@Time_Rune</a>
</I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P3403">P3403 跳楼机（【模板】同余最短路）</a><a href="https://www.luogu.com.cn/problem/list?difficulty=5">提高+/省选-</a>这道题是模板题，同于最短路，类比差分约束，我们用最短路来模拟同余。我也不知道怎么回事，代码如下。<pre>
#include &lt;iostream&gt;
#include &lt;queue&gt;
using namespace std;
#define ll long long
#define maxn 100010
#define inf (1ull&lt;&lt;63)-1
ll h,x,y,z;
ll head[maxn&lt;&lt;1],tot;
ll dis[maxn],vis[maxn];
queue&lt;int&gt; q;
struct edge{
    ll to,nxt,w;
}e[maxn&lt;&lt;1];
void add(ll u,ll v,ll w){
    e[++tot]=edge{v,head[u],w};
    head[u]=tot;
}
void spfa(){
    dis[0]=0;
    vis[0]=1;
    q.push(0);
    while(!q.empty()){
        int u=q.front();
        q.pop();
        vis[u]=0;
        for(int i=head[u];i;i=e[i].nxt){
            int v=e[i].to,w=e[i].w;
            if(dis[v]&gt;dis[u]+w){
                dis[v]=dis[u]+w;
                if(!vis[v]){
                    q.push(v);
                    vis[v]=1;
                }
            }
        }
    }
}
int main(){
    cin&gt;&gt;h;
    cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;
    if(x==1||y==1||z==1){
        cout&lt;&lt;h;
        return 0;
    }
    --h;
    for(int i=0;i&lt;x;i++){
        add(i,(i+z)%x,z);
        add(i,(i+y)%x,y);
        dis[i]=inf;
    }
    spfa();
    ll ans=0;
    for(int i=0;i&lt;x;i++){
        if(h&gt;=dis[i])ans+=(h-dis[i])/x+1;
    }
    cout&lt;&lt;ans;
    return 0;
}
    </pre>2^63别忘了开unsigned long long！<I>
        参考资料：<a href="https://oi-wiki.org/graph/mod-shortest-path/">OIWiki同余最短路</a>
    </I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P6464">P6464 [传智杯 #2 决赛] 传送门</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a>这道题要注意时间复杂度，不要单纯的用Floyd，否则肯定会超时。如果你的想法是枚举边，然后Floyd，那么时间复杂度会是O(n^5)，因为Floyd是三次方，枚举边，是二次方。然而标程是O(n^4)，那么如何少一个循环是一个关键。先给出标程吧。<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;climits&gt;
#include &lt;cctype&gt;
using namespace std;
#define re register
int read(){
    int s=0,w=1;char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-')w=-1;
        ch=getchar();
    }
    while(isdigit(ch)){
        s=s*10+ch-'0';ch=getchar();
    }
    return s*w;
}
int n,m;
int g[120][120],dis[120][120],ans=0x3f3f3f3f;
signed main(){
    n=read();m=read();
    memset(g,-1,sizeof(g));
    for(re int i=1,u,v,w;i&lt;=m;i++){
        u=read(),v=read(),w=read();
        g[v][u]=g[u][v]=w;
    }
    for(re int k=1;k&lt;=n;k++){
        for(re int i=1;i&lt;=n;i++){
            for(re int j=1;j&lt;=n;j++){
                if(g[i][k]!=-1&&g[k][j]!=-1){
                    if(g[i][j]==-1||g[i][j]&gt;g[i][k]+g[k][j]){
                        g[i][j]=g[i][k]+g[k][j];
                    }
                }
            }
        }
    }
    for(re int i=1;i&lt;=n;i++){
        for(re int j=1;j&lt;=n;j++){
            
            for(int x=1;x&lt;=n;x++){
                for(int y=1;y&lt;=n;y++){
                    dis[x][y]=g[x][y];
                }
            }
            dis[i][j]=dis[j][i]=0;
            for(int x=1;x&lt;=n;x++){
                for(int y=1;y&lt;=n;y++){
                    if(dis[x][y]==-1||dis[x][y]&gt;dis[x][i]+dis[i][y]){
                        dis[x][y]=dis[x][i]+dis[i][y];
                    }
                }
            }
            for(int x=1;x&lt;=n;x++){
                for(int y=1;y&lt;=n;y++){
                    if(dis[x][y]==-1||dis[x][y]&gt;dis[x][j]+dis[j][y]){
                        dis[x][y]=dis[x][j]+dis[j][y];
                    }
                }
            }
            int sum=0;
            for(int x=1;x&lt;=n;x++){
                for(int y=1;y&lt;x;y++){
                    sum+=dis[x][y];
                }
            }
            ans=min(ans,sum);
        }
    }
    cout&lt;&lt;ans;
    return 0;
}
    </pre>快读其实没必要。我们发现，这里其实将Floyd的k分解成了i和j。具体原理我也不清楚。<I>参考文献：<a href="https://www.luogu.com.cn/problem/solution/P6464">题解区@_Fontainebleau_</a></I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P3275">P3275 [SCOI2011] 糖果</a><a href="https://www.luogu.com.cn/problem/list?difficulty=5">提高+/省选-</a>这道题卡SPFA，所以请不要用SPFA解决这道题。<s>当然，即便允许我也不会啊</s>这道题需要tarjan缩点+差分约束+拓扑排序才能解决。当然，我不会，所以抄的。<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
using namespace std;
#define add(L,X,Y)\
    l[++p]=L,to[p]=Y;\
    ne[p]=he[X],he[X]=p;\
    if(!tl[X])tl[X]=p;
const int N=100005,M=N*3;
int p,df,tot,he[N],tl[N],ne[M],to[M],rd[N],d[N];
int low[N],dfn[N],sz[N],f[N],st[N];
bool l[M];
void tarjan(int x){
    low[st[++p]=x]=dfn[x]=++df;
    for(int y,i=he[x];i;i=ne[i]){
        if(l[i])continue;
        if(!dfn[y=to[i]]){
            tarjan(y);
            low[x]=min(low[x],low[y]);
        }
        else if(!f[y]){
            low[x]=min(low[x],dfn[y]);
        }
    }
    if(low[x]==dfn[x]){
        ++tot;
        do ++sz[f[st[p]]=x];
        while(st[p--]!=x);
    }
}
int main(){
    int p=0,n,k,S,o,x,y,i,j,cnt=0;
    cin&gt;&gt;n&gt;&gt;k;S=n+1;
    long long ans=n;
    while(k--){
        cin&gt;&gt;o&gt;&gt;x&gt;&gt;y;
        switch(o){
            case 1:add(0,x,y);add(0,y,x);break;
            case 2:add(1,x,y);break;
            case 3:add(0,y,x);break;
            case 4:add(1,y,x);break;
            case 5:add(0,x,y);
        }
    }
    for(int i=1;i&lt;=n;i++){
        add(0,S,i);
    }
    tarjan(S);
    for(i=1;i&lt;=S;i++){
        x=f[i];
        for(j=he[i];j;j=ne[j]){
            y=to[j]=f[to[j]];
            if(x!=y)++rd[y];
            else if(l[j]){
                puts("-1");return 0;
            }
        }
    }
    for(i=1;i&lt;=S;i++){
        if(i!=f[i]){
            ne[tl[i]]=he[f[i]];
            he[f[i]]=he[i];
        }
    }
    st[p=1]=S;
    while(p){
        ++cnt;
        ans+=d[x=st[p--]]*sz[x];
        for(i=he[x];i;i=ne[i]){
            y=to[i];
            d[y]=max(d[y],d[x]+l[i]);
            if(!--rd[y])st[++p]=y;
        }
    }
    cout&lt;&lt;(cnt&lt;tot?-1:ans);
    return 0;
}
</pre>题解来自题解区。<a href="https://www.luogu.com.cn/problem/solution/P3275">@FlashHu</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1993">P1993 小 K 的农场</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a><s>这道题我过了，所以它是一道水题！</s>这道题需要用到差分约束，说白了就是将题目中的差值关系转化成建边的形式，那么怎么建边是一个关键。我们注意到: <ul>
        <li>农场 
            a 比农场 
            b 至少多种植了 
            c 个单位的作物；<b>等价于a-b&gt;=c</b></li>
        <li>
            农场 
a 比农场 
b 至多多种植了 
c 个单位的作物；<b>等价于a-b&lt;=c</b>
        </li>
        <li>
            农场 
a 与农场 
b 种植的作物数一样多。<b>等价于a==b</b>
        </li>
    </ul>而我们的最短路基本式是长这样：dis[v]>dis[u]+w;而上面那些是跟这不一样的，因此要转化一下。要注意的是v是子节点，u才是父节点。顺序千万不能错。转化后如下: <ul>
        <li>
            b&lt;=a-c;遇到这样的，直接建反向边转化成: b>=a+c;虽然在图论中成立，但数学上就不知道了。
        </li>
        <li>
            b&gt;=a+c;
        </li>
        <li>
            a&lt;=b+0; 和 b&lt;=a+0;
        </li>
    </ul>于是就建边就好了。<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;
#define maxn 100000
struct edge{
    int v,w;
};
vector&lt;edge&gt; e[maxn];
int dis[maxn],vis[maxn],cnt[maxn],n,m;
bool spfa(int s){
    memset(dis,0x3f,sizeof(dis));
    dis[s]=0;
    vis[s]=1;
    queue&lt;int&gt; q;
    q.push(s);
    cnt[s]++;
    while(!q.empty()){
        int u=q.front();
        q.pop();
        vis[u]=0;
        for(auto ed:e[u]){
            int v=ed.v,w=ed.w;
            if(dis[v]&gt;dis[u]+w){
                dis[v]=dis[u]+w;
                if(!vis[v]){
                    q.push(v);
                    vis[v]=1;
                    cnt[v]++;
                    if(cnt[v]&gt;n){
                        return 0;
                    }
                }
            }
        }
    }
    return 1;
}
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1,a,b,c,z;i&lt;=m;i++){
        cin&gt;&gt;z;
        if(z==1){
            cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
            e[a].push_back({b,-c});
        }
        else if(z==2){
            cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
            e[b].push_back({a,c});
        }
        else{
            cin&gt;&gt;a&gt;&gt;b;
            e[a].push_back({b,0});
            e[b].push_back({a,0});
        }
    }
    for(int i=1;i&lt;=n;i++){
        e[n+1].push_back({i,0});
    }
    if(spfa(n+1)){
        cout&lt;&lt;"Yes";
    }
    else{
        cout&lt;&lt;"No";
    }
    return 0;
}
    
</pre>其中你会发现我多建了n条通向n+1的边，这是因为n+1要作为超级源点使用，总之就是降低时间复杂度，边权为0。<I>参考文献：<a href="https://www.luogu.com.cn/problem/solution/P1993">题解区@SDqwq</a></I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1073">P1073 [NOIP2009 提高组] 最优贸易</a><a href="https://www.luogu.com.cn/problem/list?difficulty=5">提高+/省选-</a>这道题是分层图的问题，先说一下分层图的作用。<img src="https://upload-bbs.miyoushe.com/upload/2024/11/06/198629752/64e4888554c0988fdd507fe5deb084bf_1047287439941308302.webp" alt="分层图">如图，我们需要构建这么一个图，第一层代表初始状态，第二层代表我从第一层里面买入了一个东西，现在我到了第二层，我要在第二层选一个国家卖出这个东西，第三层表示我已经卖出了这个东西，现在我要找终点。<b>分层图是一种能解决图上决策问题的建图构造模式，可以结合最短路解决多种图上问题。</b>这道题我也是调了好长时间，把题解的spfa算法调成了dijkstra。<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;map&gt;
using namespace std;
#define maxn 100040
struct edge{
    int v,w;
};
struct node{
    int dis,u;
    bool operator &lt; (const node &a)const{
        return dis&gt;a.dis;
    }
};
vector&lt;edge&gt; e[maxn*3];
int n,m,dis[maxn*3],vis[maxn*3];
int t(int x,int i){
    return x+n*i;
}
void add(int x,int y){
    e[t(x,0)].push_back({t(y,0),0});
    e[t(x,1)].push_back({t(y,1),0});
    e[t(x,2)].push_back({t(y,2),0});
}
void dij(int s){
    for(int i=1;i&lt;=n*3;i++){
        dis[i]=-2147483647;
    }
    dis[s]=0;
    priority_queue&lt;node&gt; q;
    q.push({0,s});
    vis[s]=1;
    while(!q.empty()){
        int u=q.top().u;
        q.pop();
        vis[u]=0;
        for(auto ed:e[u]){
            int v=ed.v,d=ed.w;
            if(dis[v]&lt;dis[u]+d){
                dis[v]=dis[u]+d;
                if(!vis[v])q.push({dis[v],v}),vis[v]=1;
            }
        }
    }
}
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1,v;i&lt;=n;i++){
        cin&gt;&gt;v;
        e[t(i,0)].push_back({t(i,1),-v});
        e[t(i,1)].push_back({t(i,2),v});
    }
    for(int i=1,x,y,z;i&lt;=m;i++){
        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;
        if(z==1){
            add(x,y);
        }
        else{
            add(x,y);
            add(y,x);
        }
    }
    dij(t(1,0));
    cout&lt;&lt;dis[t(n,2)];
    return 0;
}
</pre>你会发现除了上面Dijkstra的部分以外，我新加了两个函数，一个叫t()，一个叫add()，t是为了快速为点分配图层而生，add是为了在多个层之间快速建边而生。主要还是图一个方便。其中在输入商品价格的时候我是将每个商品都由本层到向下一层的道路上加了边，而且是1->2层是负边，代表买入，2->3层是正边，代表卖出，而同一层的没有跨层的边，我将它们的权值设为了0，也就是add函数中的0。最后输出，我们只需要输出最后一层的节点n就是终点，dis[n*2]就是答案了。<I>参考文献：<a href="https://www.luogu.com.cn/problem/solution/P1073">题解区@fy1234567ok</a>、<a href="https://blog.samzhangjy.com/posts/layered-graph">Blog：浅谈分层图最短路</a></I></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1462">P1462 通往奥格瑞玛的道路</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a>这道题是二分+Dijkstra。只要看见题目中说<b>所有的最大值的最小值</b>那么我们就直接用二分，当然也得先判断一下单调性。<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;
#define maxn 200000
struct edge{
    int v,w;
};
struct node{
    int dis,u;
    bool operator &lt; (const node &a)const{
        return dis&gt;a.dis;
    }
};
vector&lt;edge&gt; e[maxn];
int dis[maxn],b,n,m,vis[maxn],c[maxn];
bool dij(int k){
    if(c[1]&gt;k)return 0;<span>//如果刚开始的钱就已经大于k，直接退出。</span>
    memset(dis,0x3f,sizeof(dis));
    memset(vis,0,sizeof(vis));
    dis[1]=0;
    priority_queue&lt;node&gt; q;
    q.push({0,1});
    while(!q.empty()){
        int u=q.top().u;
        q.pop();
        if(vis[u])continue;
        vis[u]=1;
        for(auto ed:e[u]){
            int v=ed.v,w=ed.w;<span>//这里是血量</span>
            if(dis[v]&gt;dis[u]+w&&c[v]&lt;=k){<span>//多加一条判断，经过的钱数不能大于k</span>
                dis[v]=dis[u]+w;
                q.push({dis[v],v});
            }
        }
    }
    if(dis[n]&gt;b){<span>//判断血量</span>
        return 0;
    }
    return 1;
}
int main(){
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;b;
    int l=0x3f3f3f3f,r=0,mid;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;c[i];
        l=min(c[i],l);
        r=max(c[i],r);
    }
    for(int i=1,x,y,w;i&lt;=m;i++){
        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;
        e[x].push_back({y,w});
        e[y].push_back({x,w});
    }
    if(!dij(2147483647)){
        cout&lt;&lt;"AFK";
        return 0;
    }
    while(l&lt;=r){
        mid=l+r&gt;&gt;1;
        if(dij(mid)){
            r=mid-1;
        }
        else{
            l=mid+1;
        }
    }
    cout&lt;&lt;l;
    return 0;
}
    </pre>这道题在Dijkstra的判断中加了一句，而且最后还加了句判断，代码中我标了出来。题解参考题解区还有CSDN。<a href="https://blog.csdn.net/Halo_7777777/article/details/103523834">CSDN</a><a href="https://www.luogu.com.cn/problem/solution/P1462">题解区</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1875">P1875 佳佳的魔法药水</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a>这道题是Dijkstra的魔改题，乍一看看过去无从下手，其实暗藏玄鸡。<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;
#define maxn 1200
int dis[maxn][maxn],vis[maxn],cnt[maxn],n,cost[maxn];
void dij(){
    for(int i=1;i&lt;=n;i++){
        int t=0;
        for(int j=1;j&lt;=n;j++){
            if(vis[j])continue;
            if(!t||cost[j]&lt;cost[t]){<span>//这里有一个!t别忘了哦~</span>
                <span>//初始状态当t==0时是可以更新的哦！</span>
                t=j;
            }
        }
        vis[t]=1;
        for(int j=1;j&lt;=n;j++){
            int d=dis[t][j];
            if(vis[j]&&d){
                if(cost[d]&gt;cost[t]+cost[j]){
                    cost[d]=cost[t]+cost[j];
                    cnt[d]=cnt[t]*cnt[j];
                }
                else if(cost[d]==cost[t]+cost[j]){
                    cnt[d]+=cnt[t]*cnt[j];
                }
            }
        }
    }
}
signed main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)cin&gt;&gt;cost[i];
    int x,y,z;
    while(cin&gt;&gt;x&gt;&gt;y&gt;&gt;z){
        x++,y++,z++;
        dis[x][y]=z;
        dis[y][x]=z;
    }
    for(int i=1;i&lt;=n;i++){
        cnt[i]=1;
    }
    dij();
    cout&lt;&lt;cost[1]&lt;&lt;' '&lt;&lt;cnt[1];
    return 0;
}
    </pre>用一个二维数组存储药水之间的合成关系，然后利用贪心思想找出每一种药水的最小配置方案，之后由已知往未知配。别忘了x++,y++,z++,否则cnt[1]和cost[1]指向的就不是0，而是1。还有贪心取最小花费的时候别忘了行开始t==0要允许也就是代码中标绿色注释的那个。具体详情见CSDN题解。<a href="https://blog.csdn.net/weixin_51797626/article/details/122589925">CSDN题解。</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1144">P1144 最短路计数</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a>这道题乍一看似乎有点问的不合理，明明都已经是最短路了怎么会有多个？其实是因为最短路有相同的。稍微对Dijkstra改造一下就好了。<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;
#define maxn 2000000
#define mod 100003
struct edge{
    int v,w;
};
struct node{
    int dis,u;
    bool operator &lt; (const node &a)const{
        return dis&gt;a.dis;
    }
};
vector&lt;edge&gt; e[maxn];
int dis[maxn],vis[maxn],cnt[maxn];
void dij(int s){
    memset(dis,0x3f,sizeof(dis));
    memset(vis,0,sizeof(vis));
    priority_queue&lt;node&gt; q;
    dis[s]=0;cnt[s]=1;
    q.push({0,s});
    while(!q.empty()){
        int u=q.top().u;
        q.pop();
        if(vis[u])continue;
        vis[u]=1;
        for(auto ed : e[u]){
            int v=ed.v,w=ed.w;
            if(dis[v]&gt;dis[u]+w){
                dis[v]=dis[u]+w;
                cnt[v]=cnt[u];
                cnt[v]%=mod;
                q.push({dis[v],v});
            }
            else if(dis[v]==dis[u]+w){
                cnt[v]+=cnt[u];
                cnt[v]%=mod;
            }
        }
    }
}
int n,m;
signed main(){
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1,x,y;i&lt;=m;i++){
        cin&gt;&gt;x&gt;&gt;y;
        e[x].push_back({y,1});
        e[y].push_back({x,1});
    }
    dij(1);
    for(int i=1;i&lt;=n;i++){
        cout&lt;&lt;cnt[i]&lt;&lt;'\n';
    }
    return 0;
}
</pre>其中cnt数组就是用来记录相同的最短路有多少个的。如果dis[v]==dis[u]+w了说明有相同的最短路，那么我们就在前面那个最短路的基础上累加就好了，为什么要累加，其实就是组合数学当中的加法原理。如果走了上面按那个判断，那么就覆盖。最后别忘了mod。<a href="https://www.luogu.com.cn/problem/solution/P1144">参考题解区@ZiDing_ByronFinlso的文章。</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/B3611">B3611 【模板】传递闭包</a><a href="https://www.luogu.com.cn/problem/list?difficulty=3">普及/提高-</a>为了理解传递闭包是什么勾八东西，我才做了这道题，简单的一批。但我仍然不知道什么是传递闭包，貌似只要能从某个点到达某个点就叫“存在传递闭包”。<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;climits&gt;
using namespace std;
#define maxn 500
#define int long long
int dis[maxn][maxn],b[maxn][maxn];
int n;
signed main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        for(int j=1;j&lt;=n;j++){
            cin&gt;&gt;dis[i][j];
            if(!dis[i][j]){
                dis[i][j]=0x3f3f3f3f;
            }
        }
    }
    for(int k=1;k&lt;=n;k++){
        for(int i=1;i&lt;=n;i++){
            for(int j=1;j&lt;=n;j++){
                dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
                if(dis[i][j]!=0x3f3f3f3f){
                    b[i][j]=1;
                }
            }
        }
    }
    for(int i=1;i&lt;=n;i++){
        for(int j=1;j&lt;=n;j++){
            cout&lt;&lt;b[i][j]&lt;&lt;' ';
        }cout&lt;&lt;'\n';
    }
    return 0;
}
    
</pre>没有题解，因为太简单了。我就是题解好吧，用Floyd就能解出来了。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P2910">P2910 [USACO08OPEN] Clear And Present Danger S</a><a href="https://www.luogu.com.cn/problem/list?difficulty=3">普及/提高-</a>这道题注意数据范围。另外要注意题目中的一句话：<b>约翰从1号小岛出发，最后到达n号小岛</b>f数组当中的第一个数字不一定是1，最后一个数字也不一定是n，因此最后还要ans+=dis[1][f[1]]和ans+=dis[f[m]][n];代码如下。<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;climits&gt;
using namespace std;
#define maxn 500
#define int long long
int dis[maxn][maxn];
int n,m,f[100000];
signed main(){
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=m;i++){
        cin&gt;&gt;f[i];
    }
    for(int i=1;i&lt;=n;i++){
        for(int j=1;j&lt;=n;j++){
            cin&gt;&gt;dis[i][j];
        }
    }
    for(int k=1;k&lt;=n;k++){
        for(int i=1;i&lt;=n;i++){
            for(int j=1;j&lt;=n;j++){
                if(i==j||i==k||j==k)continue;
                dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
            }
        }
    }
    int ans=0;
    for(int i=1;i&lt;m;i++){
        ans+=dis[f[i]][f[i+1]];
    }
    if(f[1]!=1)ans+=dis[1][f[1]];
    if(f[m]!=n)ans+=dis[f[m]][n];
    cout&lt;&lt;ans;
    return 0;
}
</pre>这次没有题解，没错，我就是题解！这道题使用Floyd解决最好。<b>Attention : Floyd算法中，k一定要作为最外层循环！
</b></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P2865">P2865 [USACO06NOV] Roadblocks G</a><a href="https://www.luogu.com.cn/problem/list?difficulty=5">提高+/省选-</a>真是巨坑啊！输入的n和m弄反了，导致我调了半天都没调对。我还以为我的算法错了呢，结果仔细检查才发现，n和m搞反了！！！<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;climits&gt;
using namespace std;
#define maxn 5000000
#define int long long
struct edge{
    int v,w;
};
struct node{
    int dis,v;
    bool operator &gt; (const node &a)const{
        return dis&gt;a.dis;
    }
};
vector&lt;edge&gt; e[maxn];
int dis[maxn],vis[maxn];
void dij(int s){
    memset(dis,0x3f,sizeof(dis));
    memset(vis,0,sizeof(vis));
    dis[s]=0;
    priority_queue&lt;node,vector&lt;node&gt;,greater&lt;node&gt; &gt; q;
    q.push({0,s});
    while(!q.empty()){
        int u=q.top().v;
        q.pop();
        if(vis[u])continue;
        vis[u]=1;
        for(auto ed:e[u]){
            int v=ed.v,w=ed.w;
            if(dis[v]&gt;dis[u]+w){
                dis[v]=dis[u]+w;
                q.push({dis[v],v});
            }
        }
    }
}
int n,m,dis1[maxn],disn[maxn];
signed main(){
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1,x,y,w;i&lt;=m;i++){
        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;
        e[x].push_back({y,w});
        e[y].push_back({x,w});
    }
    dij(1);
    memcpy(dis1,dis,sizeof(dis1));
    dij(n);
    memcpy(disn,dis,sizeof(disn));
    int ans=LONG_LONG_MAX;
    for(int i=1;i&lt;=m;i++){
        for(auto ed : e[i]){
            //i-&gt;ed w
            int x=dis1[i]+ed.w+disn[ed.v];
            if(x&gt;dis1[n]){
                ans=min(ans,x);
            }
        }
    }
    cout&lt;&lt;ans;
    return 0;
}
    
</pre>当时第一遍提交上去的就是这个，可能这个是我认为最好理解的一个了，可惜n和m写反了，导致只有10分，好在现在改过来了。如果要论简洁程度的话，那应该是下面这个了。<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;climits&gt;
using namespace std;
#define maxn 500000
#define int long long
struct edge{
    int v,w;
};
struct node{
    int dis,u;
    bool operator &lt; (const node &a)const{
        return dis&gt;a.dis;
    }
};
vector&lt;edge&gt; e[maxn];
int dis1[maxn],dis2[maxn];
void dij(int s){
    memset(dis1,0x3f,sizeof(dis1));
    memset(dis2,0x3f,sizeof(dis2));
    dis1[s]=0;
    priority_queue&lt;node&gt; q;
    q.push({0,s});
    while(!q.empty()){
        int u=q.top().u;
        int tmp=q.top().dis;
        q.pop();
        if(dis2[u]&lt;tmp)continue;
        for(auto ed:e[u]){
            int v=ed.v,w=ed.w;
            int dis=tmp+w;
            if(dis&lt;dis1[v]){
                swap(dis1[v],dis);
                q.push({dis1[v],v});
            }
            if(dis&lt;dis2[v]&&dis1[v]&lt;dis){
                dis2[v]=dis;
                q.push({dis2[v],v});
            }
        }
    }
}
int n,m;
signed main(){
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1,x,y,w;i&lt;=m;i++){
        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;
        e[x].push_back({y,w});
        e[y].push_back({x,w});
    }
    dij(1);
    cout&lt;&lt;dis2[n];
    return 0;
}
    
</pre>这个是我抄自CSDN的博客。<a href="https://blog.csdn.net/qq_50332374/article/details/119935438">次短路模板</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P5960">P5960 【模板】差分约束</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a>这道题有多解，只需要输出其中一个即可。这道题的差分约束有点类似于最短路当中的dis[v]>dis[u]+w;这样一个式子的变形，所以这就是为什么它会出现在最短路算法当中。<pre>
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;cstring&gt;
using namespace std;
#define int long long
#define maxn 200000
struct edge{
    int v,w,nxt;
}e[maxn];
int head[maxn],tot[maxn],vis[maxn],cnt,n,m;
int dis[maxn];
void addedge(int u,int v,int w){
    e[++cnt].v=v;
    e[cnt].w=w;
    e[cnt].nxt=head[u];
    head[u]=cnt;
}
bool spfa(int s){
    queue&lt;int&gt; q;
    memset(dis,0x3f,sizeof(dis));
    dis[s]=0;vis[s]=1;
    q.push(s);
    while(!q.empty()){
        int u=q.front();
        q.pop();
        vis[u]=0;
        for(int i=head[u];i;i=e[i].nxt){
            int v=e[i].v;
            if(dis[v]&gt;dis[u]+e[i].w){
                dis[v]=dis[u]+e[i].w;
                if(!vis[v]){
                    vis[v]=1,tot[v]++;
                    if(tot[v]==n+1)return 0;
                    q.push(v);
                }
            }
        }
    }
    return 1;
}
signed main(){
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;i++)addedge(0,i,0);
    for(int i=1;i&lt;=m;i++){
        int v,u,w;
        cin&gt;&gt;v&gt;&gt;u&gt;&gt;w;
        addedge(u,v,w);
    }
    if(!spfa(0)){
        cout&lt;&lt;"NO\n";
    }
    else{
        for(int i=1;i&lt;=n;i++)cout&lt;&lt;dis[i]&lt;&lt;' ';
    }
    return 0;
}
    </pre>题解在题解区。<a href="https://www.luogu.com.cn/problem/solution/P5960">@StudyingFather</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P3385">P3385 【模板】负环</a><a href="https://www.luogu.com.cn/problem/list?difficulty=3">普及/提高-</a>像这种模板题应该一遍过，但是我错了#9，没好好看题，是w>=0等于号忘记添加了。<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;
#define maxn 360000
#define int long long
struct edge{
    int v,w;
};
vector&lt;edge&gt; e[maxn];
int dis[maxn],cnt[maxn],vis[maxn];
bool spfa(int n,int s){
    queue&lt;int&gt; q;
    memset(vis,0,sizeof(vis));
    memset(cnt,0,sizeof(cnt));
    memset(dis,0x3f,sizeof(dis));
    dis[s]=0,vis[s]=1;
    q.push(s);
    while(!q.empty()){
        int u=q.front();
        q.pop();vis[u]=0;
        for(auto ed:e[u]){
            int v=ed.v,w=ed.w;
            if(dis[v]&gt;dis[u]+w){
                dis[v]=dis[u]+w;
                cnt[v]=cnt[u]+1;
                if(cnt[v]&gt;=n)return 0;
                if(!vis[v])q.push(v),vis[v]=1;
            }
        }
    }
    return 1;
}
int t,n,m;
signed main(){
    cin&gt;&gt;t;
    while(t--){
        for(auto &ed:e){
            ed.clear();
        }
        cin&gt;&gt;n&gt;&gt;m;
        for(int i=1,x,y,w;i&lt;=m;i++){
            cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;
            if(w&gt;=0) e[x].push_back({y,w}),e[y].push_back({x,w});
            else e[x].push_back({y,w});
        }
        bool isR=spfa(n,1);
        cout&lt;&lt;(isR?"NO":"YES")&lt;&lt;'\n';
    }
    return 0;
}
</pre>没有题解，因为太简单了。模板在OIWiki上面有。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1629">P1629 邮递员送信</a><a href="https://www.luogu.com.cn/problem/list?difficulty=3">普及/提高-</a>像这种普及的题，我还是好对付的，哈哈哈。一遍AC！Dijstra跑n遍就OK了，起码比Floyd快一点，别看我外面套了个大循环，但其实时间复杂度比Floyd好。<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
using namespace std;
#define maxn 300000
#define int long long
struct edge{
    int v,w;
};
struct node{
    int dis,v;
    bool operator &gt; (const node &a)const{
        return dis&gt;a.dis;
    }
};
vector&lt;edge&gt; e[maxn];
int dis[maxn],vis[maxn];
void dij(int s){
    memset(vis,0,sizeof(vis));
    memset(dis,0x3f,sizeof(dis));
    dis[s]=0;
    priority_queue&lt;node,vector&lt;node&gt;,greater&lt;node&gt; &gt; q;
    q.push({0,s});
    while(!q.empty()){
        int u=q.top().v;
        q.pop();
        if(vis[u])continue;
        vis[u]=1;
        for(auto ed:e[u]){
            int v=ed.v,w=ed.w;
            if(dis[v]&gt;dis[u]+w){
                dis[v]=dis[u]+w;
                q.push({dis[v],v});
            }
        }
    }
}
int n,m,ans;
signed main(){
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1,x,y,w;i&lt;=m;i++){
        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;
        e[x].push_back({y,w});
    }
    dij(1);
    for(int i=2;i&lt;=n;i++){
        ans+=dis[i];
    }
    for(int i=2;i&lt;=n;i++){
        dij(i);
        ans+=dis[1];
    }
    cout&lt;&lt;ans;
    return 0;
}
</pre>这次没有题解，没错，我就是题解！</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P2680">P2680 [NOIP2015 提高组] 运输计划</a><a href="https://www.luogu.com.cn/problem/list?difficulty=5">提高+/省选-</a>这道题注意数组开大一点。需要使用tarjan算法解决，还有lca。但是我不会呜呜呜。还有二分答案，<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
using namespace std;
#define maxn 300005
struct edge{
    int next,to,dis;
}e[2*maxn],q[2*maxn];
struct length{
    int len,lca,u,v;
}len[maxn];
int head[maxn],cnt,headq[maxn],dis[maxn],maxlen,n,m,a[maxn],ans,s[maxn],num,ret,f[maxn];
bool vis[maxn];
inline  void add_edge(int x,int y,int d){
    e[++cnt].next=head[x];
    e[cnt].to=y;
    e[cnt].dis=d;
    head[x]=cnt;
}
inline void add_que(int x,int y){
    q[++cnt].next=headq[x];
    q[cnt].to=y;
    headq[x]=cnt;
}
int find(int x){
    return f[x]==x?f[x]:f[x]=find(f[x]);
}
void dfs(int u,int pre){
    for(int i=head[u];i;i=e[i].next){
        int v=e[i].to;
        if(v==pre){
            continue;
        }
        dfs(v,u);
        s[u]+=s[v];
    }
    if(s[u]==num&&a[u]&gt;ret){
        ret=a[u];
    }
}
inline bool check(int x){
    memset(s,0,sizeof(s));
    num=ret=0;
    for(int i=1;i&lt;=m;i++){
        if(len[i].len&gt;x){
            s[len[i].u]++;
            s[len[i].v]++;
            s[len[i].lca]-=2;
            num++;
        }
    }
    dfs(1,0);
    if(maxlen-ret&gt;x){
        return 0;
    }
    return 1;
}
void tarjan(int u,int pre){
    for(int i=head[u];i;i=e[i].next){
        int v=e[i].to;
        if(v==pre){
            continue;
        }
        dis[v]=dis[u]+e[i].dis;
        tarjan(v,u);
        a[v]=e[i].dis;
        int f1=find(v);
        int f2=find(u);
        if(f1!=f2){
            f[f1]=find(f2);
        }
        vis[v]=1;
    }
    for(int i=headq[u];i;i=q[i].next){
        if(vis[q[i].to]){
            int p=(i+1)&gt;&gt;1;
            len[p].lca=find(q[i].to);
            len[p].len=dis[u]+dis[q[i].to]-2*dis[len[p].lca];
            maxlen=max(maxlen,len[p].len);
        }
    }
}
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;n;i++){
        int ai,bi,ti;
        cin&gt;&gt;ai&gt;&gt;bi&gt;&gt;ti;
        add_edge(ai,bi,ti);
        add_edge(bi,ai,ti);
    }
    for(int i=1;i&lt;=n;i++){
        f[i]=i;
    }
    cnt=0;
    for(int i=1;i&lt;=m;i++){
        int x,y;
        cin&gt;&gt;x&gt;&gt;y;
        len[i].u=x;
        len[i].v=y;
        add_que(x,y);
        add_que(y,x);
    }
    tarjan(1,0);
    int l=0,r=maxlen,mid;
    while(l&lt;=r){
        mid=(l+r)&gt;&gt;1;
        if(check(mid)){
            r=mid-1;
            ans=mid;
        }
        else{
            l=mid+1;
        }
    }
    cout&lt;&lt;ans;
    return 0;
}
</pre><a href="https://www.luogu.com.cn/problem/solution/P2680">题解区代码@communist</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P3398">P3398 仓鼠找 sugar</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a>这道题暴力解法可以拿40分，暴力搜索a到b的最短路，然后把最短路径用set记录下来，然后找c到d的最短路，记录路径，然后查找c到d的路径上的点在不在set中，如果存在一个，则直接break输出Y，否则输出N。结果超时40pts。正解需要lca求公共祖先，如果存在公共祖先，则有交点。<pre>
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#define maxn 200000
using namespace std;
struct edge{
    int v,pre;
}e[maxn&lt;1];
int n,t,fst[maxn],dep[maxn],dp[maxn][19];
int vis[maxn],lg[maxn];
int abs(int x){
    return x&gt;0?x:-x;
}
void swap(int &x,int &y){
    x^=y^=x^=y;
}
inline void addedge(int a,int b,int k){
    e[k]=(edge){b,fst[a]};
    fst[a]=k;
}
void build(int k,int d){
    vis[k]=1,dep[k]=d;
    for(int o=fst[k];o;o=e[o].pre){
        if(!vis[e[o].v])dp[e[o].v][0]=k,build(e[o].v,d+1);
    }
}
void prepare(int k){
    vis[k]=0;
    for(int i=1;i&lt;=lg[dep[k]];i++){
        dp[k][i]=dp[dp[k][i-1]][i-1];
    }
    for(int o=fst[k];o;o=e[o].pre){
        if(vis[e[o].v])prepare(e[o].v);
    }
}
void init(){
    cin&gt;&gt;n&gt;&gt;t;
    for(int i=1,a,b,c;i&lt;n;i++){
        cin&gt;&gt;a&gt;&gt;b;
        addedge(a,b,i);
        addedge(b,a,i+n);
    }
    build(1,0);
    for(int i=1;i&lt;=n;i++){
        lg[i]=lg[i-1]+((1&lt;(lg[i-1]+1))==i);
    }
    prepare(1);
}
int lca(int a,int b){
    if(dep[a]&lt;dep[b])swap(a,b);
    while(dep[a]&gt;dep[b])a=dp[a][lg[dep[a]-dep[b]]];
    if(a==b)return a;
    for(int i=lg[dep[a]];i&gt;=0;i--){
        if(dp[a][i]!=dp[b][i])a=dp[a][i],b=dp[b][i];
    }
    return dp[a][0];
}
inline int dis(int a,int b){
    int c=lca(a,b);
    return abs(dep[c]-dep[a])+abs(dep[c]-dep[b]);
}
void work(){
    for(int a,b,c,d,x,y;t;t--){
        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;
        x=lca(a,b),y=lca(c,d);
        if(dis(a,y)+dis(b,y)==dis(a,b)||dis(c,x)+dis(d,x)==dis(c,d))puts("Y");
        else puts("N");
    }
}
int main(){
    init();
    work();
    return 0;
}
</pre>正解代码在题解区。<a href="https://www.luogu.com.cn/problem/solution/P3398">@zhyh</a><b>进食后人：不要对着抄，否则TLE，因为有些函数返回值要改成void。</b></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P4408">P4408 [NOI2003] 逃学的小孩</a><a href="https://www.luogu.com.cn/problem/list?difficulty=5">提高+/省选-</a>唯一一个做出来的蓝题，纪念一下！OHHH~~~~.解法十分简单，2遍dij求出直径，然后再开2个dis数组枚举C点，然后求出max(min(disA[C],disB[C])+直径[A][B])就是答案了。<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
#define maxn 300000
#define int long long
struct edge{
    int v,w;
};
struct node{
    int dis,u;
    bool operator &gt; (const node &a)const {
        return dis&gt; a.dis;
    }
};
int dis[maxn];
vector&lt;edge&gt; e[maxn];
bool vis[maxn];
int n,m;
void dij(int s){
    memset(vis,0,sizeof(vis));
    dis[s]=0;
    priority_queue&lt;node,vector&lt;node&gt;,greater&lt;node&gt; &gt; q;
    q.push({0,s});
    while(!q.empty()){
        int u=q.top().u;
        q.pop();
        if(vis[u])continue;
        vis[u]=1;
        for(auto ed:e[u]){
            int v=ed.v,w=ed.w;
            if(dis[v]&gt;dis[u]+w){
                dis[v]=dis[u]+w;
                q.push({dis[v],v});
            }
        }
    }
}
int disA[maxn],disB[maxn];
signed main(){
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1,x,y,w;i&lt;=m;i++){
        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;
        e[x].push_back({y,w});
        e[y].push_back({x,w});
    }
    memset(dis,0x3f,sizeof(dis));
    dij(1);
    int maxp=0,p;
    for(int i=1;i&lt;=n;i++){
        if(dis[i]&gt;maxp){
            maxp=dis[i];p=i;
        }
    }
    memset(dis,0x3f,sizeof(dis));
    
    dij(p);
    int A=p;
    memcpy(disA,dis,sizeof(disA));
    maxp=0,p;
    for(int i=1;i&lt;=n;i++){
        if(dis[i]&gt;maxp){
            maxp=dis[i];p=i;
        }
    }
    memset(dis,0x3f,sizeof(dis));
    dij(p);
    memcpy(disB,dis,sizeof(disB));
    int B=p;
    
    int ans=0;
    for(int i=1;i&lt;=n;i++){
        ans=max(ans,min(disA[i],disB[i])+maxp);
    }
    cout&lt;&lt;ans;
    return 0;
}
    </pre>看来我的IQ还是够的。别忘了开long long。思路同题解区第一篇。<a href="https://www.luogu.com.cn/problem/solution/P4408">题解区@C3H5ClO</a>。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1351">P1351 [NOIP2014 提高组] 联合权值</a><a href="https://www.luogu.com.cn/problem/list?difficulty=3">普及/提高-</a>这道题是用树型结构解题，我们枚举每一个中转点就好了。<pre>
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;
#define maxn 400005
struct edge{
    int next;
    int to;
}a[maxn];
int edgenum,head[maxn],w[maxn];
int n,ans,maxx;
void add(int u,int v){
    a[++edgenum].next=head[u];
    a[edgenum].to=v;
    head[u]=edgenum;
}
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;n;i++){
        int u,v;
        cin&gt;&gt;u&gt;&gt;v;
        add(u,v);
        add(v,u);
    }
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;w[i];
    }
    for(int i=1;i&lt;=n;i++){
        int max1=0,max2=0;
        int t1=0,t2=0;
        for(int j=head[i];j;j=a[j].next){
            if(w[a[j].to]&gt;max1)max2=max1,max1=w[a[j].to];
            else if(w[a[j].to]&gt;max2)max2=w[a[j].to];
            t1=(t1+w[a[j].to])%10007;
            t2=(t2+w[a[j].to]*w[a[j].to])%10007;
        }
        t1=t1*t1%10007;
        ans=(ans+t1+10007-t2)%10007;
        if(maxx&lt;max1*max2)maxx=max1*max2;
    }
    cout&lt;&lt;maxx&lt;&lt;" "&lt;&lt;ans;
    return 0;
}
    </pre>题解在题解区。<a href="https://www.luogu.com.cn/problem/solution/P1351">题解区。第一篇就是。@wucstdio</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1315">P1315 [NOIP2011 提高组] 观光公交</a><a href="https://www.luogu.com.cn/problem/list?difficulty=5">提高+/省选-</a>这道题是经典贪心题，用不到图论哦！<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
const int maxn = 10003;
int n,m,k,d[maxn];
struct people{
    int kaishi,chufabianhao,daodabianhao;
}a[maxn];
struct zhandian{
    int daoda,zuiwan,person;
}b[maxn];
int main(){
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;
    for(int i=1;i&lt;n;i++)cin&gt;&gt;d[i];
    for(int i=1;i&lt;=m;i++){
        cin&gt;&gt;a[i].kaishi&gt;&gt;a[i].chufabianhao&gt;&gt;a[i].daodabianhao;
        ++b[a[i].daodabianhao].person;
        b[a[i].chufabianhao].zuiwan=max(b[a[i].chufabianhao].zuiwan,a[i].kaishi);
    }
    int wudan_time=0;
    for(int i=1;i&lt;=n;i++){
        b[i].daoda=wudan_time;
        wudan_time=max(wudan_time,b[i].zuiwan)+d[i];
    }
    while(k--){
        int max_preson=0,max_zhandian=0;
        for(int i=2;i&lt;=n;i++){
            if(!d[i-1])continue;
            int now_preson=0;
            for(int j=i;j&lt;=n;j++){
                now_preson+=b[j].person;
                if(b[j].daoda&lt;=b[j].zuiwan)break;
            }
            if(now_preson&gt;max_preson){
                max_preson=now_preson;
                max_zhandian=i;
            }
        }
        --d[max_zhandian-1];
        for(int i=max_zhandian;i&lt;=n;i++){
            --b[i].daoda;
            if(b[i].daoda&lt;b[i].zuiwan)break;
        }
    }
    int ans=0;
    for(int i=1;i&lt;=m;i++){
        ans+=b[a[i].daodabianhao].daoda-a[i].kaishi;
    }
    cout&lt;&lt;ans;
    return 0;
}
</pre>题解来自于博客园。<a href="https://www.cnblogs.com/xsl19/p/noip2011_day2t3.html">博客园题解。</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P5836">P5836 [USACO19DEC] Milk Visits S</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a>这道题要用并查集，题目并不难，我看着像并查集，但我没想出来，看了题解才知道原来这么简单。注意并查集的合并得是fa[find(x)]=find(fa[y])才行，否则WA。<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;
#define maxn 200000
int fa[maxn];
int find(int x){
    if(fa[x]==x)return x;
    return fa[x]=find(fa[x]);
}
void merge(int u,int v){
    fa[find(u)]=find(fa[v]);
}
int n,k;
char col[maxn];
int main(){
    cin&gt;&gt;n&gt;&gt;k;
    for(int i=1;i&lt;=n;i++){
        fa[i]=i;
        cin&gt;&gt;col[i];
    }
    for(int i=1,x,y;i&lt;n;i++){
        cin&gt;&gt;x&gt;&gt;y;
        if(col[x]==col[y])merge(x,y);
    }
    while(k--){
        int x,y;char c;
        cin&gt;&gt;x&gt;&gt;y&gt;&gt;c;
        if(find(x)==find(y)&&col[x]!=c)cout&lt;&lt;0;
        else cout&lt;&lt;1;
    }
    return 0;
}
</pre><a href="https://www.luogu.com.cn/problem/solution/P5836">题解区。</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P5536">P5536 【XR-3】核心城市</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a>这道题的解法是真的逆天啊！可以选择找树的直径，然后找直径中点，由中点向外发散k个核心城市。也可以拓扑排序从外向内找非核心城市，求ans最大值。<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;
#define maxn 200000
vector&lt;int&gt; e[maxn];
int n,k,du[maxn],size[maxn];
int main(){
    cin&gt;&gt;n&gt;&gt;k;
    for(int i=1,x,y;i&lt;n;i++){
        cin&gt;&gt;x&gt;&gt;y;
        e[x].push_back(y);
        e[y].push_back(x);
    }
    queue&lt;int&gt; q;
    for(int i=1;i&lt;=n;i++){
        du[i]=e[i].size();
        if(du[i]==1)q.push(i);
    }
    int m=n-k,ans=0;
    while(m--){
        int u=q.front();q.pop();
        ans=max(ans,size[u]);
        for(auto v:e[u]){
            if(--du[v]==1){
                size[v]=size[u]+1;
                q.push(v);
            }
        }
    }
    cout&lt;&lt;ans+1;
    return 0;
}
</pre>这说明我们在学习新算法的同时，不要忘了基础算法。<a href="https://www.luogu.com.cn/article/8zm2qhcz">逆天题解</a><a href="https://www.cnblogs.com/pure4knowledge/p/18111333">逆天代码。</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P5588">P5588 小猪佩奇爬树</a><a href="https://www.luogu.com.cn/problem/list?difficulty=5">提高+/省选-</a>这道题好难，不会。代码在题解区~~~<a href="https://www.luogu.com.cn/problem/solution/P5588">题解区</a></div>
    <div class="t1"><a href="https://www.cnblogs.com/lingspace/p/p5666.html">P5666 [CSP-S2019] 树的重心</a><a href="https://www.luogu.com.cn/problem/list?difficulty=6">省选/NOI-</a>这道题看不懂。呜呜呜~<pre>
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
using namespace std;

typedef long long ll;

const int maxn = 3e5 + 5;
const int maxm = 6e5 + 5;
const int inf = 0x3f3f3f3f;

int t, n, rt, u, v;
int head[maxn], sz[maxn], mx[maxn];
bool vis[maxn];
ll ans;
vector&lt;int&gt; g[maxn];

struct node
{
    int to, nxt;
} edge[maxm];

struct BIT
{
    int c[maxn];

    void clear() { memset(c, 0, (n + 2) * sizeof(int)); }

    int lowbit(int x) { return x & (-x); }

    void update(int p, int w) { p++; for (int i = p; i &lt;= n + 1; i += lowbit(i)) c[i] += w; }

    int query(int p)
    {
        int res = 0;
        p++;
        for (int i = p; i; i -= lowbit(i)) res += c[i];
        return res;
    }
} c1, c2;

void dfs1(int x, int f)
{
    bool is_rt = true;
    sz[x] = 1, mx[x] = 0;
    for (int y : g[x])
    {
        if (y == f) continue;
        dfs1(y, x);
        sz[x] += sz[y];
        mx[x] = max(mx[x], sz[y]);
        if (sz[y] &gt; (n &gt;&gt; 1)) is_rt = false;
    }
    if (n - sz[x] &gt; (n &gt;&gt; 1)) is_rt = false;
    if (is_rt) rt = x;
}

void dfs2(int x, int f)
{
    c1.update(sz[f], -1);
    c1.update(n - sz[x], 1);
    vis[x] |= vis[f];
    if (x != rt)
    {
        ans += 1ll * x * c1.query(n - 2 * mx[x]);
        ans -= 1ll * x * c1.query(n - 2 * sz[x] - 1);
        ans += 1ll * x * c2.query(n - 2 * mx[x]);
        ans -= 1ll * x * c2.query(n - 2 * sz[x] - 1);
        ans += 1ll * rt * (int)(sz[x] &lt;= n - 2 * sz[vis[x] ? v : u]);
    }
    c2.update(sz[x], 1);
    for (int y : g[x])
    {
        if (y == f) continue;
        dfs2(y, x);
    }
    c1.update(sz[f], 1);
    c1.update(n - sz[x], -1);
    if (x != rt)
    {
        ans -= 1ll * x * c2.query(n - 2 * mx[x]);
        ans += 1ll * x * c2.query(n - 2 * sz[x] - 1);
    }
}

int main()
{
    scanf("%d", &t);
    while (t--)
    {
        scanf("%d", &n);
        for (int i = 1; i &lt;= n; i++) g[i].clear();
        for (int i = 1, u, v; i &lt;= n - 1; i++)
        {
            scanf("%d%d", &u, &v);
            g[u].push_back(v);
            g[v].push_back(u);
        }
        ans = 0ll;
        dfs1(1, 0);
        dfs1(rt, 0);
        u = v = 0;
        for (int x : g[rt])
        {
            if (sz[x] &gt; sz[v]) v = x;
            if (sz[v] &gt; sz[u]) swap(u, v);
        }
        c1.clear(), c2.clear();
        for (int i = 0; i &lt;= n; i++) c1.update(sz[i], 1), vis[i] = false;
        vis[u] = true;
        dfs2(rt, 0);
        printf("%lld\n", ans);
    }
    return 0;
}
</pre>题解抄自博客园。<a href="https://www.cnblogs.com/lingspace/p/p5666.html">博客园题解</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P2052">P2052 [NOI2011] 道路修建</a><a href="https://www.luogu.com.cn/problem/list?difficulty=3">普及/提高-</a>我以为dfs时间复杂度会非常高，结果居然过了！数据范围10^6，这告诉了我们，有时候你越是想要正解，越容易出错，还不如先把暴力打一遍，说不定暴力即正解。<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
using namespace std;
#define maxn 1500000
#define int long long
struct edge{
    int v,w;
};
vector&lt;edge&gt; e[maxn];
int n;
int size[maxn],ans;
void dfs(int u,int fa){
    size[u]=1;
    for(auto ed:e[u]){
        if(ed.v==fa)continue;
        dfs(ed.v,u);
        size[u]+=size[ed.v];
        ans+=ed.w*abs(2*size[ed.v]-n);
    }
}
signed main(){
    cin&gt;&gt;n;
    for(int i=1,x,y,w;i&lt;n;i++){
        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;
        e[x].push_back({y,w});
        e[y].push_back({x,w});
    }
    dfs(1,0);
    cout&lt;&lt;ans;
    return 0;
}
</pre>这里要特别注意dfs的时候要传入当前节点编号还有父节点编号，至于为什么，其实我也不清楚，如果不这么做，dfs会无限循环。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P3369">P3369 【模板】普通平衡树</a><a href="https://www.luogu.com.cn/problem/list?difficulty=5">提高+/省选-</a>平衡树速度可真快。但代码老长了~<pre>
#include &lt;iostream&gt;
using namespace std;
#define ls(x) tr[x].ch[0]
#define rs(x) tr[x].ch[1]
const int N = 1100010,INF=(1&lt;&lt;30)+1;
struct node{
    int ch[2];
    int fa;
    int v;
    int cnt;
    int siz;
    void init(int p,int v1){
        fa=p,v=v1;
        cnt=siz=1;
    } 
}tr[N];
int root,tot;
void pushup(int x){
    tr[x].siz=tr[ls(x)].siz+tr[rs(x)].siz+tr[x].cnt;
}
void rotate(int x){
    int y=tr[x].fa,z=tr[y].fa,k=tr[y].ch[1]==x;
    tr[z].ch[tr[z].ch[1]==y]=x,tr[x].fa=z;
    tr[y].ch[k]=tr[x].ch[k^1],tr[tr[x].ch[k^1]].fa=y;
    tr[x].ch[k^1]=y,tr[y].fa=x;
    pushup(y),pushup(x);
}
void splay(int x,int k){
    while(tr[x].fa!=k){
        int y=tr[x].fa,z=tr[y].fa;
        if(z!=k)(ls(y)==x)^(ls(z)==y)?rotate(x):rotate(y);
        rotate(x);
    }
    if(!k)root=x;
}
void insert(int v){
    int x=root,p=0;
    while(x&&tr[x].v!=v)p=x,x=tr[x].ch[v&gt;tr[x].v];
    if(x)tr[x].cnt++;
    else{
        x=++tot;
        tr[p].ch[v&gt;tr[p].v]=x;
        tr[x].init(p,v);
    }
    splay(x,0);
}
void find(int v){
    int x=root;
    while(tr[x].ch[v&gt;tr[x].v]&&v!=tr[x].v){
        x=tr[x].ch[v&gt;tr[x].v];
    }
    splay(x,0);
}
int getpre(int v){
    find(v);
    int x=root;
    if(tr[x].v&lt;v)return x;
    x=ls(x);
    while(rs(x))x=rs(x);
    splay(x,0);
    return x;
}
int getsuc(int v){
    find(v);
    int x=root;
    if(tr[x].v&gt;v)return x;
    x=rs(x);
    while(ls(x))x=ls(x);
    splay(x,0);
    return x;
}
void del(int v){
    int pre=getpre(v);
    int suc=getsuc(v);
    splay(pre,0),splay(suc,pre);
    int del=tr[suc].ch[0];
    if(tr[del].cnt&gt;1){
        tr[del].cnt--,splay(del,0);
    }
    else{
        tr[suc].ch[0]=0,splay(suc,0);
    }
}
int getrank(int v){
    insert(v);
    int res=tr[tr[root].ch[0]].siz;
    del(v);
    return res;
}
int getval(int k){
    int x=root;
    while(1){
        if(k&lt;=tr[ls(x)].siz)x=ls(x);
        else if(k&lt;=tr[ls(x)].siz+tr[x].cnt)break;
        else k-=tr[ls(x)].siz+tr[x].cnt,x=rs(x);
    }
    splay(x,0);
    return tr[x].v;
}
int main(){
    insert(-INF);insert(INF);
    int n,op,x;cin&gt;&gt;n;
    while(n--){
        cin&gt;&gt;op&gt;&gt;x;
        if(op==1)insert(x);
        else if(op==2) del(x);
        else if(op==3) cout&lt;&lt;getrank(x)&lt;&lt;'\n';
        else if(op==4) cout&lt;&lt;getval(x+1)&lt;&lt;'\n';
        else if(op==5) cout&lt;&lt;tr[getpre(x)].v&lt;&lt;'\n';
        else cout&lt;&lt;tr[getsuc(x)].v&lt;&lt;'\n';
    }
    return 0;
}
</pre>题解来源：<a href="https://www.cnblogs.com/dx123/p/16495568.html">@董晓算法 Splay实现普通平衡树。</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P4592">P4592 [TJOI2018] 异或</a><a href="https://www.luogu.com.cn/problem/list?difficulty=6">省选/NOI-</a>前置知识：树上差分、LCA、可持续化字典树。这道题好难，题解没看懂。<pre>
#include &lt;cstdio&gt;
inline int Max(int x,int y){
    return x&gt;y?x:y;
}
const int MN = 100005;
const int MS = 6200005;
const int BK = 29;
int N,Q;
int A[MN];
int eh[MN],nxt[MN*2],to[MN*2],tot;
inline void insw(int x,int y){
    nxt[++tot]=eh[x];to[tot]=y;eh[x]=tot;
    nxt[++tot]=eh[y];to[tot]=x;eh[y]=tot;
}
int sz[MS],ch[MS][2],cnt;
int rt1[MN],rt2[MN];
inline void Ins(int &rt,int x,int j){
    ch[++cnt][0]=ch[rt][0],ch[cnt][1]=ch[rt][1],sz[cnt]=sz[rt];
    rt=cnt;
    ++sz[rt];
    if(~j)Ins(ch[rt][x&gt;&gt;j&1],x,j-1);
}
int ldf[MN],rdf[MN],dep[MN],faz[MN][17],dfc;
void DFS(int u,int fa){
    ldf[u]=++dfc;faz[u][0]=fa;dep[u]=dep[fa]+1;
    Ins(rt1[dfc]=rt1[dfc-1],A[u],BK);
    Ins(rt2[u]=rt2[fa],A[u],BK);
    for(int j=1;1&lt;&lt;j&lt;dep[u];++j)faz[u][j]=faz[faz[u][j-1]][j-1];
    for(int i=eh[u];i;i=nxt[i])if(to[i]!=fa)DFS(to[i],u);
    rdf[u]=dfc;
}
inline int LCA(int x,int y){
    if(dep[x]&lt;dep[y])x^=y^=x^=y;
    for(int d=dep[x]-dep[y],j=0;d;d&gt;&gt;=1,++j)if(d&1)x=faz[x][j];
    if(x==y)return x;
    for(int j=16;~j;--j)if(faz[x][j]!=faz[y][j])x=faz[x][j],y=faz[y][j];
    return faz[x][0];
}
int Qu(int rt1,int rt2,int x,int j){
    if(j==-1)return 0;
    int p=(x&gt;&gt;j&1)^1;
    if(sz[ch[rt1][p]]-sz[ch[rt2][p]])
        return Qu(ch[rt1][p],ch[rt2][p],x,j-1)|1&lt;&lt;j;
    return Qu(ch[rt1][p^1],ch[rt2][p^1],x,j-1);
}
int main(){
    scanf("%d%d",&N,&Q);
    for(int i=1;i&lt;=N;i++){
        scanf("%d",A+i);
    }
    for(int i=1,x,y;i&lt;N;i++){
        scanf("%d%d",&x,&y);
        insw(x,y);
    }
    DFS(1,0);
    for(int i=1,opt,x,y,z;i&lt;=Q;i++){
        scanf("%d",&opt);
        if(opt==1){
            scanf("%d%d",&x,&z);
            printf("%d\n",Qu(rt1[rdf[x]],rt1[ldf[x]-1],z,BK));
        }
        else{
            scanf("%d%d%d",&x,&y,&z);
            int w=faz[LCA(x,y)][0];
            printf("%d\n",Max(Qu(rt2[x],rt2[w],z,BK),Qu(rt2[y],rt2[w],z,BK)));
        }
    }
    return 0;
}
</pre>题解看的是小粉兔的。<a href="https://www.luogu.com.cn/problem/solution/P4592">@小粉兔</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P4735">P4735 最大异或和（【模板】可持续化字典树）</a><a href="https://www.luogu.com.cn/problem/list?difficulty=6">省选/NOI-</a>这道题使用可持续化字典树来解，题解可以看董晓算法，勉强能理解。<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
using namespace std;
#define maxn 350000
int n,m,idx,cnt,s;
int rt[maxn],ch[maxn*25][2],siz[maxn*25];
void insert(int v){
    rt[++idx]=++cnt;
    int x=rt[idx-1];
    int y=rt[idx];
    for(int i=23;i&gt;=0;i--){
        int j=v&gt;&gt;i&1;
        ch[y][!j]=ch[x][!j];
        ch[y][j]=++cnt;
        x=ch[x][j];y=ch[y][j];
        siz[y]=siz[x]+1;
    }
}
int query(int x,int y,int v){
    int ans=0;
    for(int i=23;i&gt;=0;i--){
        int j=v&gt;&gt;i&1;
        if(siz[ch[y][!j]]&gt;siz[ch[x][!j]]){
            x=ch[x][!j],y=ch[y][!j],ans+=(1&lt;&lt;i);
        }
        else{
            x=ch[x][j],y=ch[y][j];
        }
    }
    return ans;
}
int l,r,x;
char op;
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    insert(0);
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;x;
        s^=x;
        insert(s);
    }
    while(m--){
        cin&gt;&gt;op;
        if(op=='A'){
            cin&gt;&gt;x;
            s^=x;
            insert(s);
        }
        else{
            cin&gt;&gt;l&gt;&gt;r&gt;&gt;x;
            cout&lt;&lt;query(rt[l-1],rt[r],s^x)&lt;&lt;'\n';
        }
    }
}
    </pre><a href="https://www.cnblogs.com/dx123/p/16564383.html">博客园：董晓算法</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P2922">P2922 [USACO08DEC] Secret Message G</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a>这道题是字典树，而且是经典例题，我没看出来，所以没写出来。<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
const int maxn = 500005;
int n,m;
int trie[maxn][2],idx,cnt1[maxn],cnt2[maxn];
int len,s[maxn];
void add(int len,int s[maxn]){
    int u=0;
    for(int i=1;i&lt;=len;i++){
        if(!trie[u][s[i]])trie[u][s[i]]=++idx;
        u=trie[u][s[i]];
        cnt2[u]++;
    }
    cnt1[u]++;
}
int find(int len,int s[maxn]){
    int u=0,res=0;
    for(int i=1;i&lt;=len;i++){
        if(!trie[u][s[i]])return res;
        u=trie[u][s[i]];
        res+=cnt1[u];
    }
    if(u)res+=cnt2[u]-cnt1[u];
    return res;
}
int main(){
    cin&gt;&gt;m&gt;&gt;n;
    while(m--){
        cin&gt;&gt;len;
        for(int i=1;i&lt;=len;i++)cin&gt;&gt;s[i];
        add(len,s);
    }
    while(n--){
        cin&gt;&gt;len;
        for(int i=1;i&lt;=len;i++)cin&gt;&gt;s[i];
        cout&lt;&lt;find(len,s)&lt;&lt;'\n';
    }
    return 0;
}
    </pre></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P3586">P3586 [POI2015] LOG</a><a href="https://www.luogu.com.cn/problem/list?difficulty=6">省选/NOI-</a>这道题起初看不懂，后来知道了，他只叫选正数，因此还是我没认真读题。但我仍然不会，hhh。依旧抄的题解。<pre>
#include &lt;iostream>
#include &lt;cstring>
#include &lt;algorithm>
using namespace std;
#define LL long long
#define N 1000005
#define lowbit(x) (x&-x)
int n,m;char op[N];
int c[N],s[N],b[N],p[N];
LL cnt,sum,tr1[N],tr2[N];
void change(LL *s,int x,int k){
    while(x&lt;=m)s[x]+=k,x+=lowbit(x);
}
LL query(LL *s,int x){
    LL t=0;
    while(x)t+=s[x],x-=lowbit(x);
    return t;
}
int main(){
    cin>>n>>m;
    for(int i=1;i&lt;=m;i++){
        cin>>op[i]>>c[i]>>s[i];b[i]=s[i];
    }
    sort(b+1,b+m+1);
    for(int i=1;i&lt;=n;i++)p[i]=m+1;
    for(int i=1,si,k;i&lt;=m;i++){
        if(op[i]=='U'){
            k=c[i];
            si=lower_bound(b+1,b+m+1,s[i])-b;
            change(tr1,si,1);
            change(tr1,p[k],-1);
            change(tr2,si,b[si]);
            change(tr2,p[k],-b[p[k]]);
            p[k]=si;
        }
        else{
            si=lower_bound(b+1,b+m+1,s[i])-b;
            cnt=query(tr1,m)-query(tr1,si-1);
            sum=query(tr2,si-1);
            printf("%s\n",sum>=(c[i]-cnt)*s[i]?"TAK":"NIE");
        }
    }
    return 0;
}
</pre>题解来自博客园：<a href="https://www.cnblogs.com/dx123/p/17946159">@董晓算法</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P2161">P2161 [SHOI2009] 会场预约</a><a href="https://www.luogu.com.cn/problem/list?difficulty=5">提高+/省选-</a>这里有一个是分巧妙的解决方案，那就是利用set的不重叠的性质来解决重叠区间的唯一性的问题。具体解决方案见题解区大佬的文章，代码如下：<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;set&gt;
using namespace std;
#define maxn 300000
#define ll long long
int lowbit(int x){
    return x&(-x);
}
int n;
struct node{
    int l,r;
    bool operator &lt; (const node &a)const{
        return r&lt;a.l;
    }
}a;
int w[maxn];
set&lt;node&gt; st;
int main(){
    cin&gt;&gt;n;
    while(n--){
        char ch;
        int l,r;
        cin&gt;&gt;ch;
        if(ch=='A'){
            int tmp=0;
            cin&gt;&gt;a.l&gt;&gt;a.r;
            auto it=st.find(a);
            while(it!=st.end()){
                st.erase(it);
                tmp++;
                it=st.find(a);
            }
            st.insert(a);
            cout&lt;&lt;tmp&lt;&lt;'\n';
        }
        else{
            cout&lt;&lt;st.size()&lt;&lt;'\n';
        }
    }
    return 0;
}
</pre>但毕竟这章节学的是树状数组，我们还是得需要树状数组的解法。<pre>
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
#define lowbit(x) (x&-x)
#define mid ((l+r)&gt;&gt;1)
const int N = 100005;
int n,tot,s[N*2],ed[N*2];
void change(int x,int k){
    while(x&lt;=N) s[x]+=k,x+=lowbit(x);
}
int query(int x){
    int t=0;
    while(x)t+=s[x],x-=lowbit(x);
    return t;
}
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        char c;cin&gt;&gt;c;
        if(c=='A'){
            int L,R,cnt=0;cin&gt;&gt;L&gt;&gt;R;
            while(1){
                int l=-1,r=R+1;
                while(l+1&lt;r){
                    query(mid)&gt;=query(R)?r=mid:l=mid;
                }
                if(ed[r]&gt;=L){
                    change(r,-1);
                    cnt++;
                    tot--;
                }
                else break;
            }
            cout&lt;&lt;cnt&lt;&lt;'\n';
            change(L,1);
            ed[L]=R;
            tot++;
        }
        else cout&lt;&lt;tot&lt;&lt;'\n';
    }
    return 0;
}
</pre>原地址在博客：<a href="https://www.cnblogs.com/dx123/p/17940915">@董晓算法</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P5677">P5677 [GZOI2017] 配对统计</a><a href="https://www.luogu.com.cn/problem/list?difficulty=5">提高+/省选-</a>毫无疑问，我又是在超题解，毫无水平的抄。呜呜呜~看了题解也不会。<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#define ll long long
#define maxn 300010
using namespace std;
int lowbit(int x){
    return x&(-x);
}
int n,m;
ll tree[maxn];
void add(int pos){
    while(pos&lt;=n){
        tree[pos]++,pos+=lowbit(pos);
    }
}
int query(int num){
    ll sum=0;
    while(num&gt;0){
        sum+=tree[num],num-=lowbit(num);
    }
    return sum;
}
struct Num{
    ll num;int pos;
}a[maxn];
bool cmp(Num a1,Num a2){
    return a1.num&lt;a2.num;
}
struct Pair{
    int l,r;
}pairr[maxn&lt;&lt;1];
int paircnt=0;
void add_pair(Num a1,Num a2){
    int l=min(a1.pos,a2.pos),r=max(a1.pos,a2.pos);
    pairr[++paircnt].l=l;
    pairr[paircnt].r=r;
    return;
}
bool cmpPair(Pair a1,Pair a2){
    if(a1.r!=a2.r)return a1.r&lt;a2.r;
    else return a1.l&lt;a2.l;
}
struct Question{
    int l,r,pos;
}question[maxn];
bool cmpQuestion(Question a1,Question a2){
    if(a1.r!=a2.r)return a1.r&lt;a2.r;
    else return a1.l&lt;a2.l;
}
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    if(n==1){
        cout&lt;&lt;0;return 0;
    }
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;a[i].num;
        a[i].pos=i;
    }
    sort(a+1,a+n+1,cmp);
    add_pair(a[1],a[2]);
    add_pair(a[n],a[n-1]);
    for(int i=2;i&lt;n;i++){
        int ldif=a[i].num-a[i-1].num,rdif=a[i+1].num-a[i].num;
        if(ldif&lt;rdif)	add_pair(a[i],a[i-1]);
        else if(ldif==rdif)	add_pair(a[i],a[i-1]),add_pair(a[i],a[i+1]);
        else 			add_pair(a[i],a[i+1]);
    }
    sort(pairr+1,pairr+paircnt+1,cmpPair);
    for(int i=1;i&lt;=m;i++){
        cin&gt;&gt;question[i].l&gt;&gt;question[i].r;
        question[i].pos=i;
    }
    sort(question+1,question+m+1,cmpQuestion);
    ll ans=0;
    for(int i=1,j=1;i&lt;=m;i++){
        while(pairr[j].r&lt;=question[i].r&&j&lt;=paircnt){
            add(pairr[j].l);
            j++;
        }
        ans+=1ll*question[i].pos*(j-1-query(question[i].l-1));
    }
    cout&lt;&lt;ans;
    return 0;
}
    </pre><a href="https://www.luogu.com.cn/problem/solution/P5677">感谢 @harryzhr 提供的题解。</a>这道题主要考察排序和查找，我们需要先按右端点排序才能开始查找。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P2572">P2572 [SCOI2010] 序列操作</a><a href="https://www.luogu.com.cn/problem/list?difficulty=5">提高+/省选-</a>这道题是经典例题，建议反复观看。<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
using namespace std;
#define maxn 500000
#define ls u&lt;&lt;1
#define rs u&lt;&lt;1|1
int n,m,a[maxn];
struct tree{
    int l,r,b,lb,rb,mb,c,lc,rc,mc,len,tag,rev;
}tr[maxn&lt;&lt;2];
void pushup(tree &u,tree l,tree r){
    u.b=l.b+r.b;
    u.lb=l.c?l.lb:l.b+r.lb;
    u.rb=r.c?r.rb:r.b+l.rb;
    u.mb=max(max(l.mb,r.mb),l.rb+r.lb);
    u.c=l.c+r.c;
    u.lc=l.b?l.lc:l.c+r.lc;
    u.rc=r.b?r.rc:r.c+l.rc;
    u.mc=max(max(l.mc,r.mc),l.rc+r.lc);
}
void pd(int u,int opt){
    tree &t=tr[u];
    if(opt==0){
        t.b=t.lb=t.rb=t.mb=0;
        t.c=t.lc=t.rc=t.mc=t.len;
        t.tag=0;t.rev=0;
    }
    if(opt==1){
        t.b=t.lb=t.rb=t.mb=t.len;
        t.c=t.lc=t.rc=t.mc=0;
        t.tag=1;t.rev=0;
    }
    if(opt==2){
        swap(t.b,t.c);swap(t.lb,t.lc);
        swap(t.rb,t.rc);swap(t.mb,t.mc);
        t.rev^=1;
    }
}
void pushdown(int u){
    tree &t=tr[u];
    if(t.tag==0)pd(ls,0),pd(rs,0);
    if(t.tag==1)pd(ls,1),pd(rs,1);
    if(t.rev)pd(ls,2),pd(rs,2);
    t.tag=-1;t.rev=0;
}
void build(int u,int l,int r){
    int t=a[l];
    tr[u]={
        l,r,t,t,t,t,
        t^1,t^1,t^1,t^1,r-l+1,-1,0
    };
    if(l==r)return;
    int m=l+r&gt;&gt;1;
    build(ls,l,m);build(rs,m+1,r);
    pushup(tr[u],tr[ls],tr[rs]);
}
void change(int u,int x,int y,int k){
    if(y&lt;tr[u].l||tr[u].r&lt;x)return;
    if(x&lt;=tr[u].l&&tr[u].r&lt;=y){
        pd(u,k);return;
    }
    pushdown(u);
    change(ls,x,y,k);change(rs,x,y,k);
    pushup(tr[u],tr[ls],tr[rs]);
}
tree query(int u,int x,int y){
    if(x&gt;tr[u].r||y&lt;tr[u].l)return{};
    if(x&lt;=tr[u].l&&tr[u].r&lt;=y)return tr[u];
    pushdown(u);
    tree T;
    pushup(T,query(ls,x,y),query(rs,x,y));
    return T;
}
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];
    build(1,1,n);
    for(int i=1;i&lt;=m;i++){
        int opt,l,r;
        cin&gt;&gt;opt&gt;&gt;l&gt;&gt;r;
        ++l,++r;
        if(opt&lt;3)change(1,l,r,opt);
        else{
            tree t=query(1,l,r);
            printf("%d\n",opt==3?t.b:t.mb);
        }
    }
    return 0;
}
</pre>代码来自博客园<a href="https://www.cnblogs.com/dx123/p/17726747.html">@董晓算法</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P4145">P4145 上帝造题的七分钟 2 / 花神游历各国</a><a href="https://www.luogu.com.cn/problem/list?difficulty=5">提高+/省选-</a>这道题的线段树被称为“小清新线段树”。<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#define int long long
#define ls k&lt;&lt;1
#define rs k&lt;&lt;1|1
using namespace std;
const int maxn = 1000005;
int n,m;
int a[maxn],maxx[maxn&lt;&lt;2],sum[maxn&lt;&lt;2];
inline void up(int k){
    maxx[k]=max(maxx[ls],maxx[rs]);
    sum[k]=sum[ls]+sum[rs];
}
inline void build(int k,int l,int r){
    if(l==r){
        sum[k]=maxx[k]=a[l];
        return;
    }
    int mid=l+r&gt;&gt;1;
    build(ls,l,mid);
    build(rs,mid+1,r);
    up(k);
}
inline void change(int k,int l,int r,int L,int R){
    if(l==r&&l&gt;=L&&r&lt;=R){
        sum[k]=maxx[k]=sqrt(sum[k]);
        return;
    }
    int mid = l+r&gt;&gt;1;
    if(L&lt;=mid&&maxx[ls]&gt;1)change(ls,l,mid,L,R);
    if(mid&lt;R&&maxx[rs]&gt;1)change(rs,mid+1,r,L,R);
    up(k);
}
inline int query(int k,int l,int r,int L,int R){
    if(L&lt;=l&&r&lt;=R)return sum[k];
    int mid = l+r&gt;&gt;1;
    int ans=0;
    if(L&lt;=mid)ans+=query(ls,l,mid,L,R);
    if(mid&lt;R)ans+=query(rs,mid+1,r,L,R);
    return ans;
}
signed main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];
    build(1,1,n);
    cin&gt;&gt;m;
    while(m--){
        int op,l,r;
        cin&gt;&gt;op&gt;&gt;l&gt;&gt;r;
        if(l&gt;r)swap(l,r);
        if(op==0)change(1,1,n,l,r);
        else cout&lt;&lt;query(1,1,n,l,r)&lt;&lt;'\n';
    }
    return 0;
}
    </pre>没错，相信你也看到了，他没有pushdown，只有pushup。所以代码很短。<a href="https://www.luogu.com.cn/problem/solution/P4145">感谢 @Gary818 的题解。</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P5522">P5522 [yLOI2019] 棠梨煎雪</a><a href="https://www.luogu.com.cn/problem/list?difficulty=5">提高+/省选-</a>这也是一道维护区间的题目。不好写。据说是一道毒瘤题。<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
using namespace std;
#define N 400010
int flag[N&lt;&lt;2][2],n,m,q,op,ansss,l,r,anss;
char s[N][41],ch[41];
struct data{
    int x,y;
}none;
data operator + (data a,data b){
    return (data){
        a.x|b.x,a.y|b.y
    };
}
void build(int hao,int l,int r){
    if(l==r){
        for(int i=1;i&lt;=n;i++){
            if(s[l][i]=='?')continue;
            flag[hao][s[l][i]-'0']|=(1&lt;&lt;(i-1));
        }
        return;
    }
    int mid=l+r&gt;&gt;1;
    build(hao&lt;&lt;1,l,mid);
    build(hao&lt;&lt;1|1,mid+1,r);
    flag[hao][0]=flag[hao&lt;&lt;1][0]|flag[hao&lt;&lt;1|1][0];
    flag[hao][1]=flag[hao&lt;&lt;1][1]|flag[hao&lt;&lt;1|1][1];
}
data query(int hao,int l,int r,int L,int R){
    if(L&lt;=l&&R&gt;=r){
        return (data){
            flag[hao][0],flag[hao][1]
        };
    }
    int mid=l+r&gt;&gt;1;
    data kkk=none;
    if(L&lt;=mid){
        kkk = kkk+query(hao&lt;&lt;1,l,mid,L,R);
    }
    if(R&gt;mid){
        kkk = kkk+query(hao&lt;&lt;1|1,mid+1,r,L,R);
    }
    return kkk;
}
void change(int hao,int l,int r,int x){
    if(l==r){
        flag[hao][0]=flag[hao][1]=0;
        for(int i=1;i&lt;=n;i++){
            if(ch[i]=='?')continue;
            flag[hao][ch[i]-'0']|=(1&lt;&lt;(i-1));
        }
        return;
    }
    int mid=l+r&gt;&gt;1;
    if(x&lt;=mid){
        change(hao&lt;&lt;1,l,mid,x);
    }
    else{
        change(hao&lt;&lt;1|1,mid+1,r,x);
    }
    flag[hao][0]=flag[hao&lt;&lt;1][0]|flag[hao&lt;&lt;1|1][0];
    flag[hao][1]=flag[hao&lt;&lt;1][1]|flag[hao&lt;&lt;1|1][1];
}
int main(){
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;
    for(int i=1;i&lt;=m;i++){
        scanf("%s",s[i]+1);
    }
    build(1,1,m);
    for(int i=1;i&lt;=q;i++){
        cin&gt;&gt;op;
        if(op==0){
            cin&gt;&gt;l&gt;&gt;r;
            data ans=query(1,1,m,l,r);
            anss=1;
            for(int i=1;i&lt;=n;i++){
                if(ans.x&1&&ans.y&1){
                    anss=0;
                    break;
                }
                if(!(ans.x&1)&&!(ans.y&1)){
                    anss*=2;
                }
                ans.x&gt;&gt;=1;
                ans.y&gt;&gt;=1;
            }
            ansss^=anss;
        }
        else{
            scanf("%d%s",&l,ch+1);
            change(1,1,m,l);
        }
    }
    printf("%d\n",ansss);
    return 0;
}
</pre><a href="https://www.cnblogs.com/2017gdgzoi44/p/11409452.html">感谢博客园的题解。</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1558">P1558 色板游戏</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a>这道题提醒了我一个易错点：<b>可能 A>B 这样的话你需要交换A和B</b>另外还有一个坑：<b>memset对数组赋值只能4个字节一组进行赋值，那么赋值为1的话，这里就出问题了，结果每个元素不是1，而是0x01010101</b>这道题要用树状数组或者是线段树来解决，我不知道怎么解，留给后吧，或者是未来的我。<pre>
#include &lt;cstdio>
#include &lt;algorithm>
#include &lt;cstring>
using namespace std;
int l,t,o;
int a[5000000],lazy[5000000];
long long lala(int x){
    long long temp=1;
    for(int lmq=0;lmq&lt;x;lmq++){
        temp*=2;
    }
    return temp;
}
void pushdown(int num){
    if(lazy[num]){
        lazy[num&lt;&lt;1]=lazy[num];
        lazy[num&lt;&lt;1|1]=lazy[num];
        a[num&lt;&lt;1]=lazy[num];
        a[num&lt;&lt;1|1]=lazy[num];
        lazy[num]=0;
    }
}
void pushup(int num){
    a[num]=a[num&lt;&lt;1]|a[num&lt;&lt;1|1];
}
void build(int le,int re,int num){
    if(le==re){
        a[num]=1;return;
    }
    int mid=le+re>>1;
    build(le,mid,num&lt;&lt;1);
    build(mid+1,re,num&lt;&lt;1|1);
    pushup(num);
}
void color(int l,int r,int c,int le,int re,int num){
    if(l&lt;=le&&r>=re){
        pushdown(num);
        long long tmp=lala(c-1);
        a[num]=tmp;
        lazy[num]=tmp;
        return;
    }
    pushdown(num);
    int mid=le+re>>1;
    if(l&lt;=mid){
        color(l,r,c,le,mid,num&lt;&lt;1);
    }
    if(mid&lt;r){
        color(l,r,c,mid+1,re,num&lt;&lt;1|1);
    }
    pushup(num);
}
long long ask(int l,int r,int le,int re,int num){
    if(l&lt;=le&&re&lt;=r){
        return a[num];
    }
    pushdown(num);
    int mid=le+re>>1;
    long long temp=0;
    if(l&lt;=mid){
        temp=temp|ask(l,r,le,mid,num&lt;&lt;1);
    }
    if(mid&lt;r){
        temp=temp|ask(l,r,mid+1,re,num&lt;&lt;1|1);
    }
    return temp;
}
void f(long long x){
    int res=0;
    for(;x!=0;){
        if(x%2==1)res++;
        x/=2;
    }
    printf("%d\n",res);
    return;
}
int main(){
    scanf("%d%d%d",&l,&t,&o);
    build(1,l,1);
    for(int i=0;i&lt;o;i++){
        char q[3];
        scanf("%s",q);
        if(q[0]=='C'){
            int c1,c2,c3;
            scanf("%d%d%d",&c1,&c2,&c3);
            if(c1>c2){
                swap(c1,c2);
            }
            color(c1,c2,c3,1,l,1);
        }
        else{
            int c1,c2;
            scanf("%d%d",&c1,&c2);
            if(c1>c2)swap(c1,c2);
            long long ans=ask(c1,c2,1,l,1);
            f(ans);
        }
    }
    return 0;
}
</pre>感谢题解区UP <a href="https://www.luogu.com.cn/problem/solution/P1558">@MindyY</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1637">P1637 三元上升子序列</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a>这道题考察你对树状数组或线段树这类数据结构的理解，还有对动态规划的结合。<pre>
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
#define ll long long
#define maxn 300000
ll n,a[maxn],s[maxn],m,f[4][maxn],c[maxn],ans;
ll val(int x){
    return lower_bound(s+1,s+m+1,x)-s;
}
ll ask(int x,ll sum=0){
    for(;x;x-=(x&(-x)))sum+=c[x];
    return  sum;
}
void add(int x,ll v){
    for(;x&lt;=m;x+=(x&(-x)))c[x]+=v;
}
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i],s[i]=a[i];
    sort(s+1,s+n+1);
    m=unique(s+1,s+n+1)-s-1;
    for(int i=1;i&lt;=n;i++)f[1][i]=1,a[i]=val(a[i]);
    for(int i=2;i&lt;=3;i++){
        memset(c,0,sizeof(c));
        for(int j=1;j&lt;=n;j++){
            f[i][j]=ask(a[j]-1);
            add(a[j],f[i-1][j]);
        }
    }
    for(int i=1;i&lt;=n;i++)ans+=f[3][i];
    cout&lt;&lt;ans;
    return 0;
}
</pre>动态规划+树状数组优化，题解在题解区。<a href="https://www.luogu.com.cn/problem/solution/P1637">@紫题</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P6492">P6492 [COCI2010-2011#6] STEP</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a>这道题主要是练习我们对于区间合并的理解。<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;

const int N = 8e5+5;
int n,m;
int S[N],H[N],L[N],R[N],len[N],ans[N];
void work(int node,int k){
    ans[node]=S[node]=H[node]=1;
    L[node]=R[node]=k;
}
void pushup(int node){
    if(R[node&lt;&lt;1]^L[node&lt;&lt;1|1]){
        ans[node]=H[node&lt;&lt;1]+S[node&lt;&lt;1|1];
        ans[node]=max(ans[node],ans[node&lt;&lt;1]);
        ans[node]=max(ans[node],ans[node&lt;&lt;1|1]);
    }
    else{
        ans[node]=max(ans[node&lt;&lt;1],ans[node&lt;&lt;1|1]);
    }
    L[node]=L[node&lt;&lt;1];R[node]=R[node&lt;&lt;1|1];
    if(S[node&lt;&lt;1]==len[node&lt;&lt;1]&&R[node&lt;&lt;1]^L[node&lt;&lt;1|1]){
        S[node]=S[node&lt;&lt;1]+S[node&lt;&lt;1|1];
    }
    else{
        S[node]=S[node&lt;&lt;1];
    }
    if(H[node&lt;&lt;1|1]==len[node&lt;&lt;1|1]&&R[node&lt;&lt;1]^L[node&lt;&lt;1|1]){
        H[node]=H[node&lt;&lt;1|1]+H[node&lt;&lt;1];
    }
    else{
        H[node]=H[node&lt;&lt;1|1];
    }
}
void build(int node, int l,int r){
    len[node]=r-l+1;
    if(l==r){
        work(node,0);
        return;
    }
    int mid=l+r&gt;&gt;1;
    build(node&lt;&lt;1,l,mid);
    build(node&lt;&lt;1|1,mid+1,r);
    pushup(node);
}
void change(int node, int l,int r,int x){
    if(l==r)
    {
        work(node,!L[node]);
        return;
    }
    int mid=l+r&gt;&gt;1;
    if(x&lt;=mid)change(node&lt;&lt;1,l,mid,x);
    else change(node&lt;&lt;1|1,mid+1,r,x);
    pushup(node);
}
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    build(1,1,n);
    for(int i=1;i&lt;=m;i++){
        int x;
        cin&gt;&gt;x;
        change(1,1,n,x);
        cout&lt;&lt;ans[1]&lt;&lt;'\n';
    }
    return 0;
}
    </pre><p>不过我是抄的<a href="https://www.cnblogs.com/xcg123/p/13170192.html">博客园的题解</a>。</p></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1471">P1471 方差</a><a href="https://www.luogu.com.cn/problem/list?difficulty=5">提高+/省选-</a>太厉害了，这道题完美的让线段树与数学结合在了一起，让我们充分领略了西格玛求和函数在线段树中的应用。不过太难了，我抄的答案。呜呜呜<pre>
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#define lson rt&lt;&lt;1,l,mid
#define rson rt&lt;&lt;1|1,mid+1,r
#define maxn 300010
using namespace std;
double sega[maxn],segb[maxn];
double mark[maxn];
void pushup(int x){
    sega[x]=sega[x&lt;&lt;1]+sega[x&lt;&lt;1|1];
    segb[x]=segb[x&lt;&lt;1]+segb[x&lt;&lt;1|1];
}
void pushdown(int rt,int x){
    if(mark[rt]){
        segb[rt&lt;&lt;1]+=2*mark[rt]*sega[rt&lt;&lt;1]+(x-x/2)*mark[rt]*mark[rt];
        segb[rt&lt;&lt;1|1]+=2*mark[rt]*sega[rt&lt;&lt;1|1]+(x/2)*mark[rt]*mark[rt];
        sega[rt&lt;&lt;1]+=(x-x/2)*mark[rt];
        sega[rt&lt;&lt;1|1]+=(x/2)*mark[rt];
        mark[rt&lt;&lt;1]+=mark[rt];
        mark[rt&lt;&lt;1|1]+=mark[rt];
        mark[rt]=0;
    }
}
void build(int rt,int l,int r){
    if(l==r){
        cin&gt;&gt;sega[rt],segb[rt]=sega[rt]*sega[rt];
    }
    else{
        int mid=l+r&gt;&gt;1;
        build(lson);
        build(rson);
        pushup(rt);
    }
}
double query_a(int rt,int l,int r,int L,int R){
    if(l&gt;=L&&r&lt;=R){
        return sega[rt];
    }
    else{
        pushdown(rt,r-l+1);
        int mid=r+l&gt;&gt;1;
        double ret=0;
        if(mid&gt;=L){
            ret+=query_a(lson,L,R);
        }
        if(mid&lt;R){
            ret+=query_a(rson,L,R);
        }
        return ret;
    }
}

double query_b(int rt,int l,int r,int L,int R){
    if(l&gt;=L&&r&lt;=R){
        return segb[rt];
    }
    else{
        pushdown(rt,r-l+1);
        int mid=r+l&gt;&gt;1;
        double ret=0;
        if(mid&gt;=L){
            ret+=query_b(lson,L,R);
        }
        if(mid&lt;R){
            ret+=query_b(rson,L,R);
        }
        return ret;
    }
}
void update(int rt,int l,int r,int L,int R,double x){
    if(l&gt;=L&&r&lt;=R){
        mark[rt]+=x,segb[rt]+=2*x*sega[rt]+x*x*(r-l+1),sega[rt]+=(r-l+1)*x;
    }
    else{
        pushdown(rt,r-l+1);
        int mid=r+l&gt;&gt;1;
        if(mid&gt;=L){
            update(lson,L,R,x);
        }
        if(mid&lt;R){
            update(rson,L,R,x);
        }
        pushup(rt);
    }
}
double sqr(double x){
    return x*x;
}
int main(){
    int n,m,x,y,c;
    double z;
    cin&gt;&gt;n&gt;&gt;m;
    build(1,1,n);
    for(int i=1;i&lt;=m;i++){
        cin&gt;&gt;c;
        if(c==2){
            cin&gt;&gt;x&gt;&gt;y;
            printf("%.4lf\n",query_a(1,1,n,x,y)/(y-x+1));
        }
        else if(c==1){
            cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;
            update(1,1,n,x,y,z);
        }
        else if(c==3){
            cin&gt;&gt;x&gt;&gt;y;
            double sum1=query_b(1,1,n,x,y)/(y-x+1),sum2=query_a(1,1,n,x,y)/(y-x+1);
            double ans=sum1-sum2*sum2;
            printf("%.4lf\n",ans);
        }
    }
}
</pre>做这道题需要我们先展开求和公式，然后化简得到最基本的公式，然后转化成代码求解，跟普通的线段树找区间和是一样的，只不过这里变成了公式推导以及对于平方的处理。<p>感谢<a href="https://www.luogu.com.cn/problem/solution/P1471">@远航之曲
</a>的题解。</p>%%% orz</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P4513">P4513 小白逛公园</a><a href="https://www.luogu.com.cn/problem/list?difficulty=5">提高+/省选-</a>这道题是一道很好的最大连续子段和例题，建议记住。<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
using namespace std;
#define ll long long
#define maxn 500010
#define lc l,m,rt&lt;&lt;1
#define rc m+1,r,rt&lt;&lt;1|1
struct Tree{
    int pre,suf,sub,val;
}tree[maxn&lt;&lt;2];
Tree pushup(Tree l,Tree r){
    Tree rt;
    rt.pre=max(l.pre,l.val+r.pre);
    rt.suf=max(r.suf,r.val+l.suf);
    rt.sub=max(max(l.sub,r.sub),l.suf+r.pre);
    rt.val=l.val+r.val;
    return rt;
}
void build(int l,int r,int rt){
    if(l==r){
        cin&gt;&gt;tree[rt].val;
        tree[rt].pre=tree[rt].suf=tree[rt].sub=tree[rt].val;
        return;
    }
    int m=l+r&gt;&gt;1;
    build(lc);
    build(rc);
    tree[rt]=pushup(tree[rt&lt;&lt;1],tree[rt&lt;&lt;1|1]);
}
void update(int pos,int c,int l,int r,int rt){
    if(l==r){
        tree[rt].pre=tree[rt].suf=tree[rt].sub=tree[rt].val=c;
        return;
    }
    int m=l+r&gt;&gt;1;
    if(pos&lt;=m)update(pos,c,lc);
    if(pos&gt;m)update(pos,c,rc);
    tree[rt]=pushup(tree[rt&lt;&lt;1],tree[rt&lt;&lt;1|1]);
}
Tree query(int L,int R,int l,int r,int rt){
    if(L&lt;=l&&r&lt;=R){
        return tree[rt];
    }
    int m=l+r&gt;&gt;1;
    Tree ret,lret,rret;
    int flag1=0,flag2=0;
    if(L&lt;=m){
        lret=query(L,R,lc);flag1=1;
    }
    if(R&gt;m){
        rret=query(L,R,rc);flag2=1;
    }
    if(flag1&flag2){
        ret=pushup(lret,rret);
    }
    else if(flag1)ret=lret;
    else if(flag2)ret=rret;
    return ret;
}
int n,m;
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    build(1,n,1);
    for(int i=1;i&lt;=m;i++){
        int op;
        cin&gt;&gt;op;
        if(op==1){
            int l,r;
            cin&gt;&gt;l&gt;&gt;r;
            if(l&gt;r)swap(l,r);
            Tree ans=query(l,r,1,n,1);
            cout&lt;&lt;ans.sub&lt;&lt;'\n';
        }
        else{
            int p,s;
            cin&gt;&gt;p&gt;&gt;s;
            update(p,s,1,n,1);
        }
    }
    return 0;
}
</pre>这篇代码来源于博客:<a href="https://www.cnblogs.com/ZERO-/p/10679858.html">洛谷 P4513 小白逛公园-区间最大子段和-分治+线段树区间合并(单点更新、区间查询)</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P2085">P2085 最小函数值</a><a href="https://www.luogu.com.cn/problem/list?difficulty=3">普及/提高-</a>AC了！<br><b>啊~这灼热的真理！</b><pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
using namespace std;
#define maxn 200000
#define int long long
int n,m;
priority_queue&lt;int&gt; q;
priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; qr;
signed main(){
    cin&gt;&gt;n&gt;&gt;m;
    int a,b,c;
    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
    for(int i=1;i&lt;=m;i++){
        q.push(a*i*i+b*i+c);
    }
    for(int i=2;i&lt;=n;i++){
        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
        for(int j=1;j&lt;=m;j++){
            if((!q.empty())&&a*j*j+b*j+c&lt;q.top()){
                q.pop();q.push(a*j*j+b*j+c);
            }
        }
    }
    while(!q.empty()){
        qr.push(q.top());q.pop();
    }
    while(!qr.empty()){
        cout&lt;&lt;qr.top()&lt;&lt;' ';qr.pop();
    }
    return 0;
}
    </pre>用一个大顶堆维护前10个小的数，如果新来的数比堆顶还小，那么弹出堆顶，把新来的放进去。最后把大顶堆的数转移到小顶堆，输出小顶堆即可。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1631">P1631 序列合并</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a>这道题我还是有点糊涂~<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
using namespace std;
#define maxn 200000
#define int long long
#define pint pair&lt;int,int&gt;
int n,a[maxn],b[maxn],to[maxn];
priority_queue&lt;pint,vector&lt;pint&gt;,greater&lt;pint&gt; &gt; q;
signed main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;a[i];
    }
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;b[i];
        to[i]=1;
        q.push(make_pair(a[1]+b[i],i));
    }
    int i=n;
    while(n--){
        cout&lt;&lt;q.top().first&lt;&lt;' ';
        i=q.top().second;q.pop();
        q.push(make_pair(a[++to[i]]+b[i],i));
    }
    return 0;
}
</pre>详细解答见题解区：<a href="https://www.luogu.com.cn/problem/solution/P1631">@ysner
 大佬的解答</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1168">P1168 中位数</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a>这道题是维护两个队列，使其时钟保持两队列size相等。不断更新mid中位数的值，可以想象成不断吃了又吐的过程。<pre>
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
using namespace std;
#define int long long
int n,a[300000];
priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; qmin;
priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; qmax;
signed main(){
    cin&gt;&gt;n;
    cin&gt;&gt;a[1];
    int mid=a[1];
    cout&lt;&lt;mid&lt;&lt;'\n';
    for(int i=2;i&lt;=n;i++){
        cin&gt;&gt;a[i];
        if(a[i]&gt;mid){
            qmin.push(a[i]);
        }
        else{
            qmax.push(a[i]);
        }
        if(i%2){
            while(qmax.size()!=qmin.size()){
                if(qmax.size()&lt;qmin.size()){
                    qmax.push(mid);
                    mid=qmin.top();qmin.pop();
                }
                else if(qmax.size()&gt;qmin.size()){
                    qmin.push(mid);
                    mid=qmax.top();qmax.pop();
                }
            }
            cout&lt;&lt;mid&lt;&lt;'\n';
        }
    }
    return 0;
}
</pre>这道题还是队列拼接的问题啦！</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1801">P1801 黑匣子</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a>说白了就是两个优先队列一大一小维护第k小值。<pre>
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
using namespace std;
#define int long long
int n,m,a[300000],u;
priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; qmin;
priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; qmax;
signed main(){
    cin&gt;&gt;m&gt;&gt;n;
    for(int i=1;i&lt;=m;i++){
        cin&gt;&gt;a[i];
    }
    for(int i=1,p=1;i&lt;=n;i++){
        cin&gt;&gt;u;
        for(int j=p;j&lt;=u;j++){
            qmax.push(a[j]);
            if(qmax.size()==i){
                qmin.push(qmax.top());
                qmax.pop();
            }
        }
        p=u+1;
        cout&lt;&lt;qmin.top()&lt;&lt;'\n';
        qmax.push(qmin.top());qmin.pop();
    }
    return 0;
}
    </pre>但为什么我没有想到呢？？？</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P2483">P2483 【模板】k 短路 / [SDOI2010] 魔法猪学院</a><a href="https://www.luogu.com.cn/problem/list?difficulty=7">NOI/NOI+/CTSC</a>这道题我都没听懂，我就只知道Dijkstra和A*还有左偏树能解这道题，但具体怎么解，我不知道。<pre>
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;map&gt;
#define mp(x,y) make_pair(x,y)
using namespace std;
const int N = 2e5+10,M=N&lt;&lt;5;
const double eps=1e-8;
struct edge{
    int x,y;
    bool ban;
    double w;
}e[N];
struct node{
    int to,next,w;
}a[N];
int n,m,tot,ans,ls[N],ban[N],fa[N],rt[N];
double f[N],k;bool v[N];map&lt;int,int&gt; u[N];
vector&lt;int&gt; T[N],ot[N];
priority_queue&lt;pair&lt;double,int&gt; &gt; _q;
priority_queue&lt;pair&lt;double,pair&lt;int,int&gt; &gt; &gt; q;
struct SegTree{
    int cnt,w[M],ls[M],rs[M];
    int Change(int x,int L,int R,int pos){
        int p=++cnt;w[p]=w[x]+1;
        if(L==R)return p;int mid=L+R&gt;&gt;1;
        if(pos&lt;=mid)ls[p]=Change(ls[x],L,mid,pos),rs[p]=rs[x];
        else rs[p]=Change(rs[x],mid+1,R,pos),ls[p]=ls[x];
        return p;
    }
    int Ask(int x,int L,int R,int k){
        if(k&gt;R||!w[x])return 0;
        if(L==R)return L;int mid=L+R&gt;&gt;1;
        if(k&gt;mid)return Ask(rs[x],mid+1,R,k);
        int ans=Ask(ls[x],L,mid,k);
        if(!ans)ans=Ask(rs[x],mid+1,R,k);
        return ans;
    }
}S;
void addl(int x,int y,int w){
    a[++tot].to=y;
    a[tot].next=ls[x];
    ls[x]=tot,a[tot].w=w;
    return;
}
void dij(){
    for(int i=1;i&lt;n;i++)f[i]=1e100;
    _q.push(mp(0,n));
    while(!_q.empty()){
        int x=_q.top().second;_q.pop();
        if(v[x])continue;v[x]=1;
        for(int i=ls[x];i;i=a[i].next){
            int y=a[i].to;
            if(f[x]+e[a[i].w].w&lt;f[y]){
                f[y]=f[x]+e[a[i].w].w;
                ban[y]=a[i].w;fa[y]=x;
                _q.push(mp(-f[y],y));
            }
        }
    }
}
bool cmp(edge x,edge y){
    return x.w&lt;y.w;
}
void dfs(int x){
    for(int i=0;i&lt;ot[x].size();i++){
        rt[x]=S.Change(rt[x],1,m,ot[x][i]);
    }
    for(int i=0;i&lt;T[x].size();i++){
        rt[T[x][i]]=rt[x],dfs(T[x][i]);
    }
}
void solve(){
    int x=S.Ask(rt[1],1,m,0);
    q.push(mp(-f[1]-e[x].w,mp(1,x)));
    while(!q.empty()){
        double w=-q.top().first;
        int x=q.top().second.first;
        int y=q.top().second.second;
        q.pop();
        if(k+eps&lt;w){
            return;
        }
        k-=w;ans++;
        int p=S.Ask(rt[e[y].y],1,m,1);
        if(p)q.push(mp(-w-e[p].w,mp(e[y].y,p)));
        p=S.Ask(rt[x],1,m,y+1);
        if(p)q.push(mp(-w+e[y].w-e[p].w,mp(x,p)));
    }
}
int main()
{
    scanf("%d%d%lf",&n,&m,&k);
    for(int i=1;i&lt;=m;i++){
        scanf("%d%d%lf",&e[i].x,&e[i].y,&e[i].w);
        addl(e[i].y,e[i].x,i);
    }
    dij();
    if(k&lt;f[1])return puts("0")&0;
    k-=f[1];
    ans++;
    for(int i=1;i&lt;n;i++)e[ban[i]].ban=1;
    for(int i=1;i&lt;n;i++)T[fa[i]].push_back(i);
    for(int i=1;i&lt;=m;i++){
        if(!e[i].ban&&e[i].x!=n){
            e[i].w=f[e[i].y]+e[i].w-f[e[i].x];
        }
        else swap(e[i],e[m]),m--,i--;
    }
    sort(e+1,e+m+1,cmp);
    for(int i=1;i&lt;=m;i++)ot[e[i].x].push_back(i);
    dfs(n);solve();
    printf("%d\n",ans);
    return 0;
}
</pre>这个是模板，因此需要背会，我看题解好多人写了很多方法，估计是已经把左偏树、Dijkstra、A*理解的出神入化了吧，要不然不会有这么高的造诣。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P10484">P10484 送礼物</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a>这道题算是折半搜索的模板了meet-in-the-middle。<pre>
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;
using namespace std;
#define maxn 50
#define int long long
int m,n,g[maxn],w[1&lt;&lt;25],cnt,ans;
void dfs1(int u,int s){
    if(u==n/2){
        w[cnt++]=s;
        return;
    }
    dfs1(u+1,s);
    if(g[u]+s&lt;=m)dfs1(u+1,s+g[u]);
}
void dfs2(int u,int s){
    if(u==n){
        ans=max(ans,*(upper_bound(w,w+cnt,m-s)-1)+s);
        return;
    }
    dfs2(u+1,s);
    if(g[u]+s&lt;=m)dfs2(u+1,s+g[u]);
}
signed main(){
    cin&gt;&gt;m&gt;&gt;n;
    for(int i=0;i&lt;n;i++){
        cin&gt;&gt;g[i];
    }
    sort(g,g+n);reverse(g,g+n);
    dfs1(0,0);
    sort(w,w+cnt);cnt=unique(w,w+cnt)-w;
    dfs2(n/2,0);
    cout&lt;&lt;ans;
    return 0;
}
</pre>要注意的是，开longlong，否则就WA，还有就是upper_bound和sort还有reverse还有unique的区间千万不要搞错了，否则就会MLE和RE，w[]数组也要开大点，否则也会RE。</div>
    <div class="t1"><a href="https://codeforces.com/problemset/problem/525/E">E. Anya and Cubes</a>这是CF上的一道题目。主要运用了折半查找的算法<pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;unordered_map&gt;
using namespace std;
#define LL long long 
const int N = 30;
unordered_map&lt;LL,LL&gt; M[N];
LL fact[N];
int n,k,a[N];
LL s,ans;
void dfs1(int now,int end,LL S,int used){
    if(used&gt;k){
        return;
    }
    if(now&gt;end){
        M[used][S]++;
        return;
    }
    dfs1(now+1,end,S,used);
    dfs1(now+1,end,S+a[now],used);
    if(a[now]&lt;=20){
        dfs1(now+1,end,S+fact[a[now]],used+1);
    }
}
void dfs2(int now,int end,LL S,int used){
    if(used&gt;k){
        return;
    }
    if(S&gt;s){
        return;
    }
    if(now&gt;end){
        for(int i=0;i&lt;=k-used;i++){
            ans+=M[i][s-S];
        }
        return;
    }
    dfs2(now+1,end,S,used);
    dfs2(now+1,end,S+a[now],used);
    if(a[now]&lt;=20){
        dfs2(now+1,end,S+fact[a[now]],used+1);
    }
}
int main(){
    cin&gt;&gt;n&gt;&gt;k&gt;&gt;s;
    fact[1]=1;
    for(int i=2;i&lt;=20;i++){
        fact[i]=fact[i-1]*i;<span>与处理出20以内的所有数的阶乘</span>
    }
    for(int i=1;i&lt;=n;i++){ 
        cin&gt;&gt;a[i];
    }
    dfs1(1,(n+1)/2,0,0); 
    dfs2((n+1)/2+1,n,0,0);
    cout&lt;&lt;ans;
    return 0; 
}
    </pre>M意思是选了i个阶乘，和为S</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P8819">P8819 [CSP-S 2022] 星战</a><a href="https://www.luogu.com.cn/problem/list?difficulty=6">省选/NOI-</a>看好了孩子们，哈希是这么用的！<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;random&gt;
#include &lt;ctime&gt;
using namespace std;
#define N 500001
int n,m,q;
unsigned long long sum,ans,val[N],pos[N],pos2[N];
pair&lt;int ,int &gt; e[N];
int main(){
    srand(time(0)),cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;i++){
        val[i]=rand(),sum+=val[i];
    }
    for(int i=1;i&lt;=m;i++){
        cin&gt;&gt;e[i].first&gt;&gt;e[i].second;
        ans+=val[e[i].first];
        pos[e[i].second]+=val[e[i].first];
    }
    for(int i=1;i&lt;=n;i++)pos2[i]=pos[i];
    cin&gt;&gt;q;
    while(q--){
        int opt;
        cin&gt;&gt;opt;
        if(opt==1||opt==3){
            int x,y;
            cin&gt;&gt;x&gt;&gt;y;
            if(opt==1)pos[y]-=val[x],ans-=val[x];
            else pos[y]+=val[x],ans+=val[x];
        }
        if(opt==2||opt==4){
            int x;cin&gt;&gt;x;
            if(opt==2)ans-=pos[x],pos[x]=0;
            else ans+=pos2[x]-pos[x],pos[x]=pos2[x];
        }
        puts(sum==ans?"YES":"NO");
    }
    return 0;
}
</pre><p>暴力解法就是建图，然后按照opt的编号去把边的状态切换成“激活/失活”。之后统计激活的出边为1的点的数量，如果等于n，那么说明可以进攻，换句话说构成了一个环，不过这个环没有其他多余的边。但是压根不用判环，只需要判断出边就好了，参见<a href="https://www.luogu.com.cn/problem/solution/P8819">题解</a>。题解的解答比我的详细多了。这个环还真比较特殊，它叫做<a href="https://oi-wiki.org/graph/concept/">基环内向树</a>。</p></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P8818">P8818 [CSP-S 2022] 策略游戏</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a>我艹，我调了半天，这辈子也是有了~~~，完了之后才发现错误原因，首先是因为最大值和最小值开小了，但后来使用LONG_LONG_MAX，结果0pts，网上一查才知道，这玩意需要引入头文件<code>#include &lt;climits&gt;</code>真的服了。<pre>
#include &lt;iostream&gt;
#include &lt;cctype&gt;
#include &lt;climits&gt;
#define int long long
#define maxn 200000
#define logN 30
const int maxinf=LLONG_MAX,mininf=LLONG_MIN;
using namespace std;
int f[maxn+1][logN +1],lg[maxn+1];
inline int max(int a,int b){
    return a&gt;b?a:b;
}
inline int min(int a,int b){
    return a&lt;b?a:b;
}
void pre(){
    lg[2]=1;
    for(int i=3;i&lt;=maxn;i++)lg[i]=lg[i&gt;&gt;1]+1;
}
inline int read(){
    int s=0,w=1;char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-')w=-1;
        ch=getchar();
    }
    while(isdigit(ch)){
        s=s*10+ch-'0';
        ch=getchar();
    }
    return s*w;
}
int amax[maxn+1][logN+1],bmax[maxn+1][logN+1];
int amin[maxn+1][logN+1],bmin[maxn+1][logN+1];
int aupmin[maxn+1][logN+1];
int adownmax[maxn+1][logN+1];
int n,m,q,x,y;
signed main(){
    n=read(),m=read(),q=read();
    for(int i=1;i&lt;=n;i++){
        x=read();
        amax[i][0]=amin[i][0]=x;
        aupmin[i][0]=(x&gt;=0?x:maxinf);
        adownmax[i][0]=(x&lt;0?x:mininf);
    }
    for(int i=1;i&lt;=m;i++){
        x=read();
        bmax[i][0]=bmin[i][0]=x;
    }
    pre();
    for(int j=1;j&lt;=logN;j++){
        for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++){
            amax[i][j]=max(amax[i][j-1],amax[i+(1&lt;&lt;(j-1))][j-1]);
            amin[i][j]=min(amin[i][j-1],amin[i+(1&lt;&lt;(j-1))][j-1]);
            aupmin[i][j]=min(aupmin[i][j-1],aupmin[i+(1&lt;&lt;(j-1))][j-1]);
            adownmax[i][j]=max(adownmax[i][j-1],adownmax[i+(1&lt;&lt;(j-1))][j-1]);
            bmax[i][j]=max(bmax[i][j-1],bmax[i+(1&lt;&lt;(j-1))][j-1]);
            bmin[i][j]=min(bmin[i][j-1],bmin[i+(1&lt;&lt;(j-1))][j-1]);
        }
    }
    while(q--){
        int ans=mininf;
        x=read(),y=read();
        int s=lg[y-x+1];
        int a1=max(amax[x][s],amax[y-(1&lt;&lt;s)+1][s]);
        int a2=min(amin[x][s],amin[y-(1&lt;&lt;s)+1][s]);
        int a3=max(adownmax[x][s],adownmax[y-(1&lt;&lt;s)+1][s]);
        int a4=min(aupmin[x][s],aupmin[y-(1&lt;&lt;s)+1][s]);
        
        x=read(),y=read();
        s=lg[y-x+1];
        int b1=max(bmax[x][s],bmax[y-(1&lt;&lt;s)+1][s]);
        int b2=min(bmin[x][s],bmin[y-(1&lt;&lt;s)+1][s]);
        
        ans=max(ans,a1*(a1&gt;=0?b2:b1));
        ans=max(ans,a2*(a2&gt;=0?b2:b1));
        if(a3!=mininf){
            ans=max(ans,a3*(a3&gt;=0?b2:b1));
        }
        if(a4!=maxinf){
            ans=max(ans,a4*(a4&gt;=0?b2:b1));
        }
        cout&lt;&lt;ans&lt;&lt;'\n';
    }
    return 0;
}
</pre>不过通过这道题我也是把ST表玩明白了。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P8817">P8817 [CSP-S 2022] 假期计划</a><a href="https://www.luogu.com.cn/problem/list?difficulty=5">提高+/省选-</a><pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;set&gt;
#include &lt;vector&gt;
using namespace std;
#define int long long
#define maxn 200000
#define N 2147483647
struct edge{
    int v,w;
};
struct node{
    int dis,u;
    bool operator &gt; (const node & a)const{
        return dis &gt;a.dis;
    }
};
int sc[maxn];
vector&lt;edge&gt; e[maxn];
int dis[3000][3000],vis[maxn];
priority_queue&lt;node,vector&lt;node&gt;,greater&lt;node&gt; &gt; q;
void dijkstra(int s){
    dis[s][s]=0;
    q.push({0,s});
    while(!q.empty()){
        int u=q.top().u;
        q.pop();
        if(vis[u])continue;
        vis[u]=1;
        for(int i=0;i&lt;e[u].size();i++){
            edge ed=e[u][i];
            int v=ed.v,w=ed.w;
            if(dis[s][v]&gt;dis[s][u]+w){
                dis[s][v]=dis[s][u]+w;
                q.push({dis[s][v],v});
            }
        }
    }
}
set&lt;pair&lt;int,int&gt; &gt; s[maxn];
int n,m,ans,k;
signed main(){
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;
    for(int i=2;i&lt;=n;i++){
        cin&gt;&gt;sc[i];
    }
    for(int i=1,x,y;i&lt;=m;i++){
        cin&gt;&gt;x&gt;&gt;y;
        e[x].push_back({y,1});
        e[y].push_back({x,1});
    }
    memset(dis,0x3f,sizeof(dis));
    for(int i=1;i&lt;=n;i++){
        memset(vis,0,sizeof(vis));
        dijkstra(i);
    }

    <span>//------上面都是dijkstra算法模板，直接套就好-----</span>

    k++;
    for(int i=2;i&lt;=n;i++){
        for(int j=2;j&lt;=n;j++){
            if(i==j)continue;
            if(dis[i][j]&lt;=k&&dis[1][j]&lt;=k)
                s[i].insert({sc[j],j});<span>//这里的first虽然不会用到，但是是为了使set内元素有序而加入的。因为set的元素是pair时，set会先按照first排序，如果first相等，在按照second排序。</span>
            if(s[i].size()&gt;3)s[i].erase(s[i].begin());<span>//这里是为了维护前2大，size大于3直接把set的底部元素删掉。（也就是删最小的sc）</span>
        }
    }
    for(int b=2;b&lt;=n;b++){
        for(int c=2;c&lt;=n;c++){
            if(b==c||dis[b][c]&gt;k)continue;
            for(auto a:s[b]){
                if(a.second==b||a.second==c)continue;
                for(auto d : s[c]){
                    if(d.second==b||d.second==c||d.second==a.second)continue;
                    ans=max(ans,sc[a.second]+sc[b]+sc[c]+sc[d.second]);
                }
            }
        }
    }
    cout&lt;&lt;ans;
    return 0;
}
</pre>这里通过预处理达到n^2的复杂度，如果暴力解法的话，那就是dijkstra完事之后就枚举四个景点，四层循环，判断景点之间的距离要小于k，时间复杂度是n^4只能拿75分。我们可以预处理第一个点和最后一个点，再处理第二个和第三个点。时间复杂度直接降到了O(2*n²)=O(n²)，其中set查找的时间复杂度只有2，常数级忽略不计。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P7914">P7914 [CSP-S 2021] 括号序列</a><a href="https://www.luogu.com.cn/problem/list?difficulty=5">提高+/省选-</a>我想了半天也没想出来，看了题解才恍然大悟，这是个动态规划，而且不是一般的动态规划。<pre>
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;
#define int long long
#define mod 1000000007
int n,k,dp[600][600][10];
char s[600];
bool comp(int a,int b){
    return (s[a]=='('||s[a]=='?')&&(s[b]=='?'||s[b]==')');
}
signed main(){
    cin&gt;&gt;n&gt;&gt;k;
    scanf("%s",s+1);
    for(int i=1;i&lt;=n;i++)dp[i][i-1][0]=1;
    for(int len=1;len&lt;=n;len++){
        for(int l=1;l&lt;=n-len+1;l++){
            int r=l+len-1;
            if(len&lt;=k)dp[l][r][0]=dp[l][r-1][0]&&(s[r]=='*'||s[r]=='?');
            if(len&gt;=2){
                if(comp(l,r))dp[l][r][1]=(dp[l+1][r-1][0]+dp[l+1][r-1][2]+dp[l+1][r-1][3]+dp[l+1][r-1][4])%mod;
                for(int i=l;i&lt;=r-1;i++){
                    dp[l][r][2]=(dp[l][r][2]+dp[l][i][3]*dp[i+1][r][0])%mod;
                    dp[l][r][3]=(dp[l][r][3]+(dp[l][i][2]+dp[l][i][3])*dp[i+1][r][1])%mod;
                    dp[l][r][4]=(dp[l][r][4]+(dp[l][i][4]+dp[l][i][5])*dp[i+1][r][1])%mod;
                    dp[l][r][5]=(dp[l][r][5]+dp[l][i][4]*dp[i+1][r][0])%mod;
                }
            }
            dp[l][r][5]=(dp[l][r][5]+dp[l][r][0])%mod;
            dp[l][r][3]=(dp[l][r][3]+dp[l][r][1])%mod;
        }
    }
    cout&lt;&lt;dp[1][n][3];
    return 0;
}
</pre>*总结：考场上一定要多想想，找到规律，规律一定是能找到的，只不过你没发现。</div>
    
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P7913">P7913 [CSP-S 2021] 廊桥分配</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a>祝贺我把这道题搞懂了！！！<pre>
#include &lt;queue&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
using namespace std;
#define maxn 1000050
#define pii pair&lt;int,int&gt;
struct node{
    int x,y;
    bool operator &lt; (const node &a){
        return x&lt;a.x||(x==a.x&&y&lt;a.y);
    }
}a[maxn],b[maxn];

int n,m1,m2,ans;
int res1[maxn],res2[maxn];

void sol(node *t,int m,int *res){
    priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt; q;
    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; w;
    for(int i=1;i&lt;=n;i++)w.push(i);
    for(int i=1;i&lt;=m;i++){
        
        while((!q.empty())&&t[i].x&gt;=q.top().first){
            w.push(q.top().second);
            q.pop();
        }
        
        if(w.empty())continue;
        int dest=w.top();
        w.pop();
        res[dest]++;
        q.push(make_pair(t[i].y,dest));
    }
    for(int i=1;i&lt;=n;i++)res[i]+=res[i-1];
}

int main(){
    cin&gt;&gt;n&gt;&gt;m1&gt;&gt;m2;
    for(int i=1;i&lt;=m1;i++){
        cin&gt;&gt;a[i].x&gt;&gt;a[i].y;
    }
    for(int i=1;i&lt;=m2;i++){
        cin&gt;&gt;b[i].x&gt;&gt;b[i].y;
    }
    sort(a+1,a+m1+1);
    sort(b+1,b+m2+1);
    sol(a,m1,res1);
    sol(b,m2,res2);
    for(int i=0;i&lt;=n;i++){
        ans= max(ans, res1[i]+res2[n-i]);
    }
    cout&lt;&lt;ans;
    return 0;
}
</pre>我来讲解一下啥意思。首先按照飞机入港的时间排序，排好序之后我们用优先队列按顺序存储她们离港的时间。res1和res2数组用来存储国内和国外的廊桥上面停放飞机的前缀和。用w数组模拟飞机过来之后我分配给飞机一个空闲廊桥，暂时不考虑n的分配限制。我们res[i]记录第i个廊桥最多能停多少架飞机，完事之后求res前缀和。最后求答案的时候用for循环遍历i，找到最大的max(res1[i],res[n-i])，即为答案。<br>*总结，这道题卡了很长时间，我真到了考场不一定能想出来。总结一句，还是做题太少了。不过想想，我真的是做题太少了吗？可能是我对数据结构的认识还不够彻底吧。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P7915">P7915 [CSP-S 2021] 回文</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a>思维题？？？我无话可说。这题代码挺难实现的，我也是想不到这样的解法。<pre>
#include &lt;cstdio&gt;
#include &lt;cctype&gt;
int n;
const int maxn = 1000002;
char res[maxn];
int a[maxn];
inline int read(){
    int s=0,w=1;char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-'){
            w=-1;
        }
        ch=getchar();
    }
    while(isdigit(ch)){
        s=s*10+ch-'0';
        ch=getchar();
    }
    return s*w;
}
inline bool work(int l1,int r1,int l2,int r2){
    for(int i=1;i&lt;n;i++){
        if(l1&lt;=r1&&((l2&lt;=r2&&a[l1]==a[l2])||(l1&lt;r1&&a[l1]==a[r1]))){
            if(l1&lt;r1&&a[l1]==a[r1]){
                ++l1;--r1;
                res[i]='L';res[2*(n-1)-i+1]='L';
            }
            else{
                ++l1;++l2;
                res[i]='L';res[2*(n-1)-i+1]='R';
            }
        }
        else if(l2&lt;=r2&&((l1&lt;=r1&&a[r2]==a[r1])||(l2&lt;r2&&a[l2]==a[r2]))){
            if(l2&lt;r2&&a[l2]==a[r2]){
                ++l2;--r2;
                res[i]='R';res[2*(n-1)-i+1]='R';
            }
            else{
                --r2;--r1;
                res[i]='R';res[2*(n-1)-i+1]='L';
            }
        }
        else return 0;
    }
    return 1;
}
int main(){
    int T=read();
    while(T--){
        n=read();int p1=-1,p2=-1;
        for(int i=1;i&lt;=2*n;i++)a[i]=read();
        for(int i=1;i&lt;=2*n+1;i++)res[i]=0;
        for(int i=2;i&lt;=2*n;i++){
            if(a[1]==a[i]){
                p1=i;break;
            }
        }
        for(int i=1;i&lt;2*n;i++){
            if(a[2*n]==a[i]){
                p2=i;break;
            }
        }
        if(work(2,p1-1,p1+1,2*n)){
            printf("L%sL\n",res+1);
        }
        else if(work(1,p2-1,p2+1,2*n-1)){
            printf("R%sL\n",res+1);
        }
        else printf("-1\n");
    }
    return 0;
}
</pre>呜呜呜，求求你了€€£！我拿不到一等奖就完蛋了！呜呜呜！€€£ %%%orz。</div>
    <div class="t1">unordered_map比map速度要快，复杂度是O(1)，对于卡常数的题目，要用到map就直接用unordered_map。需要包含头文件：<code>#include &lt;unordered_map&gt;</code></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P4568">P4568 [JLOI2011] 飞行路线</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高-</a><pre>
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
struct Edge{
    int to,next,cost;
}edge[10000010];
int cnt,head[10000010];
void addedge(int u,int v,int c=0){
    edge[++cnt]=(Edge){v,head[u],c
    };
    head[u]=cnt;
}
int dis[10010000];
bool vis[10000001];
void dij(int s){
    memset(dis,0x3f,sizeof(dis));
    dis[s]=0;
    priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt; &gt;,greater&lt;pair&lt;int,int&gt; &gt; &gt; points;
    points.push(make_pair(0,s));
    while(!points.empty()){
        int u=points.top().second;
        points.pop();
        if(!vis[u]){
            vis[u]=1;
            for(int i=head[u];i;i=edge[i].next){
                int to=edge[i].to;
                if(dis[to]&gt;dis[u]+edge[i].cost){
                    dis[to]=dis[u]+edge[i].cost;
                    points.push(make_pair(dis[to],to));
                }
            }
        }
    }
}
int main(){
    int n,m,k,s,t;
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;s&gt;&gt;t;
    for(int i=0,u,v,c;i&lt;m;i++){
        cin&gt;&gt;u&gt;&gt;v&gt;&gt;c;
        addedge(u,v,c);
        addedge(v,u,c);
        for(int j=1;j&lt;=k;j++){
            addedge(u+(j-1)*n,v+j*n);
            addedge(v+(j-1)*n,u+j*n);
            addedge(u+j*n,v+j*n,c);
            addedge(v+j*n,u+j*n,c);
        }
    }
    for(int i=1;i&lt;=k;i++){
        addedge(t+(i-1)*n,t+i*n);
    }
    dij(s);
    printf("%d",dis[t+k*n]);
    return 0;
}
</pre><b style="margin-left: 60px;letter-spacing: 10px;">膜拜</b><p style="line-height: px;font-size: 10px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;站长</p><br><p style="line-height: 0px;">解法很玄妙，可惜我不懂。</p><br><p style="line-height: 0px;">我只会在那，%%%%orz。</p></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P3371">P3371 【模板】单源最短路径（弱化版）</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及/提高-</a>
解法1：链式前向星
<pre>
<span>//代码变量名有点臭，是为了防止系统名冲突</span>
<span>//考场上也把名字稍微起的臭一点更安全</span>
#include &lt;iostream&gt;
using namespace std;
int head[1000001],cnt;
long long ans[1000000];
bool vis[1000010];
int n,m,s;
struct edge{
    int to,nextt,wei;
}edge[1000000];
void addedge(int x,int y,int t){
    edge[++cnt].to=y;
    edge[cnt].nextt=head[x];
    edge[cnt].wei=t;
    head[x]=cnt;
}
int main(){
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;
    for(int i=1;i&lt;=m;i++){
        ans[i]=2147483647;
    }
    ans[s]=0;
    for(int i=1,u,v,w;i&lt;=m;i++){
        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
        addedge(u,v,w);
    }
    int pos=s;
    while(!vis[pos]){
        long long minn=2147483647;
        vis[pos]=1;
        for(int i=head[pos];i!=0;i=edge[i].nextt){
            if(!vis[edge[i].to]&&ans[edge[i].to]&gt;ans[pos]+edge[i].wei){
                ans[edge[i].to]=ans[pos]+edge[i].wei;
            }
        }
        for(int i=1;i&lt;=n;i++){
            if(ans[i]&lt;minn&&vis[i]==0){
                minn=ans[i];
                pos=i;
            }
        }
    }
    for(int i=1;i&lt;=n;i++){
        cout&lt;&lt;ans[i]&lt;&lt;' ';
    }
    return 0;
}
</pre>
解法2：暴力解法
<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
using namespace std;
#define int long long
const long long N=2147483647;<span>//正确示范1 </span>
<span>//const long long N=(1&lt;&lt;31)-1;//正确示范2 </span>
<span>//const long long N=1&lt;&lt;31-1;//错误示范</span>
struct edge{
    int v,w;
};

vector&lt;edge&gt; e[20000];

int dis[20001];
int n,m;
bool vis[20001];
void Dijkstra(int s){
    dis[s]=0;
    for(int i=1;i&lt;=n;i++){
        int u=0,mind=N;
        for(int j=1;j&lt;=n;j++){
            if(!vis[j]&&dis[j]&lt;mind)u=j,mind=dis[j];
        }
        vis[u]=1;
        for(int j=0;j&lt;e[u].size();j++){
            <span>//可不能把j写成i了！ </span>
            edge ed=e[u][j];
            int v=ed.v,w=ed.w;
            if(dis[v]&gt;dis[u]+w)dis[v]=dis[u]+w;
        }
    }
}

int s;
signed main(){
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;
    for(int i=1,x,y,w;i&lt;=m;i++){
        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;
        e[x].push_back({y,w});<span>//看好了，这是单向边！</span> 
    }
    
<span>//	memset(dis,0x3f,sizeof(dis));</span>
    for(int i=1;i&lt;=n;i++){
        dis[i]=N;
    }
    Dijkstra(s);
    
    for(int i=1;i&lt;=n;i++){
        cout&lt;&lt;dis[i]&lt;&lt;" ";
    }
    return 0;
}
</pre>
解法3：优先队列实现+链式前向星(堆优化版)
<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;
#define int long long
#define maxn 2000000
const long long N=2147483647;

priority_queue&lt;pair&lt;int,int&gt;, vector&lt;pair&lt;int,int&gt; &gt; ,greater&lt;pair&lt;int,int&gt; &gt; &gt; q;

int fir[maxn],to[maxn],val[maxn],nex[maxn],n,m,s,u,v,w,cnt;

int dis[maxn];
bool vis[maxn];

void addedge(int a,int b,int c){
    to[++cnt]=b;
    val[cnt]=c;
    nex[cnt]=fir[a];
    fir[a]=cnt;
}

void Dijkstra(int s){
    dis[s]=0;
    
    q.push(make_pair(0,s));
    while(!q.empty()){
        int x=q.top().second;q.pop();
        if(vis[x])continue;
        vis[x]=1;
        for(int i=fir[x];i;i=nex[i]){
            if(dis[to[i]]&gt;dis[x]+val[i]){
                dis[to[i]]=dis[x]+val[i];
                q.push(make_pair(dis[to[i]],to[i]));
            }
        }
    }
}

signed main(){
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;
    for(int i=1,x,y,w;i&lt;=m;i++){
        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;
        addedge(x,y,w);
    }
    
    for(int i=1;i&lt;=n;i++){
        dis[i]=N;
    }
    Dijkstra(s);
    
    for(int i=1;i&lt;=n;i++){
        cout&lt;&lt;dis[i]&lt;&lt;" ";
    }
    return 0;
}
</pre>
解法4：堆优化版，简单写法
<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;
#define int long long
#define maxn 2000000
const long long N=2147483647;

struct edge {
    int v, w;
};

struct node {
    int dis, u;

    bool operator&gt;(const node& a) const { return dis &gt; a.dis; }
};

vector&lt;edge&gt; e[maxn];
int dis[maxn], vis[maxn];
priority_queue&lt;node, vector&lt;node&gt;, greater&lt;node&gt; &gt; q;

void dijkstra(int s) {
    dis[s] = 0;
    q.push({0, s});
    while (!q.empty()) {
    int u = q.top().u;
    q.pop();
    if (vis[u]) continue;
    vis[u] = 1;
    for (int i=0;i&lt;e[u].size();i++) {
        edge ed=e[u][i];
        int v = ed.v, w = ed.w;
        if (dis[v] &gt; dis[u] + w) {
            dis[v] = dis[u] + w;
            q.push({dis[v], v});
        }
    }
    }
}

int n,m,s;
signed main(){
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;
    for(int i=1,x,y,w;i&lt;=m;i++){
        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;
        e[x].push_back({y,w});
    }


    for(int i=1;i&lt;=n;i++){
        dis[i]=N;
    }
    dijkstra(s);
    
    for(int i=1;i&lt;=n;i++){
        cout&lt;&lt;dis[i]&lt;&lt;" ";
    }
    return 0;
}
</pre>
解法5：spfa可以判负环
<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;
#define int long long
#define maxn 2000000
const long long N=2147483647;

struct edge{
    int v,w;
};

vector&lt;edge&gt; e[maxn];
int dis[maxn],cnt[maxn],vis[maxn];
queue&lt;int&gt; q;

bool spfa(int n,int s){
    dis[s]=0;vis[s]=1;
    q.push(s);
    while(!q.empty()){
        int u=q.front();
        q.pop(),vis[u]=0;
        for(int i=0;i&lt;e[u].size();i++){
            edge ed=e[u][i];
            int v=ed.v,w=ed.w;
            if(dis[v]&gt;dis[u]+w){
                dis[v]=dis[u]+w;
                cnt[v]=cnt[u]+1;<span>// 记录最短路经过的边数</span>
                if(cnt[v]&gt;=n)return 0;
                <span>// 在不经过负环的情况下，最短路至多经过 n - 1 条边</span>
                <span>// 因此如果经过了多于 n 条边，一定说明经过了负环</span>
                if(!vis[v])q.push(v),vis[v]=1;
            }
        }
    }
    return 1;
}

int n,m,s;
signed main(){
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;
    for(int i=1,x,y,w;i&lt;=m;i++){
        cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;
        e[x].push_back({y,w});
    }
    
//	memset(dis,0x3f,sizeof(dis));
    for(int i=1;i&lt;=n;i++){
        dis[i]=N;
    }
    spfa(n,s);
    
    for(int i=1;i&lt;=n;i++){
        cout&lt;&lt;dis[i]&lt;&lt;" ";
    }
    return 0;
}
</pre>
    </div>
    <div class="t1">蓝色的是高频考点：<img src="https://upload-bbs.miyoushe.com/upload/2024/10/20/286158760/2dc705baa5fe2e0d9e8c4980809e6410_3563378581543882989.png" alt="考点"></div>
    <div class="t1">最大公约数与最小公倍数的求法<pre>
int sum1=__gcd(a,b);<span>//求最大公约数</span>
int sum2=a*b/__gcd(a,b);<span>//求最小公倍数</span>
    </pre></div>
    <div class="t1">认真读题，有些题里面要求对答案进行mod多少，别忘了mod，否则就会WA。</div>
    <div class="t1">异或：<img src="https://upload-bbs.miyoushe.com/upload/2024/10/19/286158760/b8355bb0bb08782bd17367225f5f18cc_2398932819789195744.png" alt="异或"></div>
    <div class="t1"><a href="https://contest.xinyoudui.com/contest/280/problem/1503">A.  火柴</a>注意for循环的范围，我把数组的范围写成了1-39，正确做法应该是0-39,39取不到。</div>
    <div class="t1">学习最短路之前先总结一波~(Because 我已经学完了) <ol>
        <li>Dijkstra算法<ul><li>优点：<ol><li>准确性</li><li>适用性广泛</li><li>易于理解和实现</li><li>支持自动路径恢复</li></ol><li>缺点：</li><ol><li>无法处理含负权边的图</li><li>对于稀疏图效率较低</li><li>牺牲了部分性能来保证准确性</li></ol></li></ul></li>

        <li>Floyed算法<ul><li>优点：<ol><li>多源最短路算法</li><li>动态规划思想</li><li>稠密图效果最佳</li></ol><li>缺点：</li><ol><li>时间复杂度较高</li><li>无法处理负环</li></ol></li></ul></li>

        <li>SPFA算法<ul><li>优点：<ol><li>适用于稀疏图</li><li>可以解决带有负权边的问题</li></ol><li>缺点：</li><ol><li>时间复杂度不稳定</li><li>实现相对复杂</li></ol></li></ul></li>
    </ol><br>总之，赛场上尽量用Dijkstra，因为Dijkstra时间复杂度低，而且稳定，SPFA容易被卡数据。（SPFA已死~）</div>
    <div class="t1">最短路<img src="https://upload-bbs.miyoushe.com/upload/2024/10/18/198629752/f3f059a471cc80989eb1c327706830ca_177783167206426404.png" alt="最短路"></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P3128">P3128 [USACO15DEC] Max Flow P</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a>果然，还是套公式好用！这道题前一部分是直接套用熟练剖分的算法模板，后一部分也就是dfs3是遍历整棵树，回溯过程中去做和的累加，循环外去记录最大值。<b>典型模板：树上差分</b><pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;
#define maxn 500100
vector&lt;int&gt; linker[maxn];
int n,m,k,ans,power[maxn];<span>//power是差分数组</span>
int fa[maxn],dep[maxn],top[maxn],sz[maxn],son[maxn];
void dfs1(int u,int father){
    fa[u]=father;sz[u]=1;dep[u]=dep[father]+1;
    for(int i=0;i&lt;linker[u].size();i++){
        int v=linker[u][i];
        if(v==father)continue;
        dfs1(v,u);
        sz[u]+=sz[v];
        if(sz[son[u]]&lt;sz[v])son[u]=v;
    }
}
void dfs2(int u,int t){
    top[u]=t;
    if(!son[u])return;
    dfs2(son[u],t);
    for(int i=0;i&lt;linker[u].size();i++){
        if(linker[u][i]==fa[u]||linker[u][i]==son[u])continue;
        dfs2(linker[u][i],linker[u][i]);
    }
}
void swap(int &x,int &y){
    int tmp=x;x=y;y=tmp;
}
int lca(int x,int y){
    while(top[x]!=top[y]){
        if(dep[top[x]]&lt;dep[top[y]])swap(x,y);
        x=fa[top[x]];
    }
    return dep[x]&lt;dep[y]?x:y;
}
<span>//--------从这往上都是模板-----------</span>

void dfs3(int u,int f){<span>//这个的意思就是遍历整棵树</span>
    for(int i=0;i&lt;linker[u].size();i++)
    {
        if(linker[u][i]==f)continue;
        dfs3(linker[u][i],u);
        power[u]+=power[linker[u][i]];<span>//回溯阶段累加</span>
    }
    ans=max(ans,power[u]);<span>//记录最大值</span>
}
int main(){
    cin&gt;&gt;n&gt;&gt;k;
    for(int i=1,x,y;i&lt;n;i++){
        cin&gt;&gt;x&gt;&gt;y;
        linker[x].push_back(y);
        linker[y].push_back(x);
    }
    dfs1(1,0);
    dfs2(1,1);
    for(int i=1,x,y;i&lt;=k;i++){
        cin&gt;&gt;x&gt;&gt;y;
        int l=lca(x,y);
        ++power[x];++power[y];<span>//做差分，跟之前学的差不多</span>
        --power[l];--power[fa[l]];
    }
    dfs3(1,0);<span>//差分完了就累加</span>
    cout&lt;&lt;ans;
    return 0;
}
    </pre></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P3379">P3379 【模板】最近公共祖先（LCA）</a><a href="https://www.luogu.com.cn/problem/list?difficulty=3">普及/提高-</a>树链剖分挺简单的。<br><b>1.树链剖分：</b><pre>
#include &lt;vector&gt;
#include &lt;iostream&gt;
using namespace std;
#define maxn 500100
vector&lt;int&gt; linker[maxn];
int n,m,s;
int fa[maxn],dep[maxn],top[maxn],sz[maxn],son[maxn];
void dfs1(int u,int father){<span>//求出fa、sz、dep、son</span>
    fa[u]=father;sz[u]=1;dep[u]=dep[father]+1;
    for(int i=0;i&lt;linker[u].size();i++){
        if(linker[u][i]==father)continue;
        dfs1(linker[u][i],u);
        sz[u]+=sz[linker[u][i]];
        if(sz[son[u]]&lt;sz[linker[u][i]])son[u]=linker[u][i];
    }
}
void dfs2(int u,int t){<span>//求出链头top</span>
    top[u]=t;
    if(!son[u])return;
    dfs2(son[u],t);
    for(int i=0;i&lt;linker[u].size();i++){
        if(linker[u][i]==fa[u]||linker[u][i]==son[u])continue;
        dfs2(linker[u][i],linker[u][i]);
    }
}
void swap(int &x,int &y){
    int tmp=x;x=y;y=tmp;
}
int lca(int x,int y){<span>//通过链头向上跳，找最近公共祖先。</span>
    while(top[x]!=top[y]){
        if(dep[top[x]]&lt;dep[top[y]])swap(x,y);
        x=fa[top[x]];
    }
    return dep[x]&lt;dep[y]?x:y;
}
int main(){
    cin&gt;n&gt;m&gt;s;
    for(int i=1,x,y;i&lt;n;i++){
        cin&gt;x&gt;y;
        linker[x].push_back(y);
        linker[y].push_back(x);
    }
    dfs1(s,0);
    dfs2(s,s);
    int x,y;
    while(m--){
        cin&gt;x&gt;y;
        cout&lt;&lt;lca(x,y)&lt;&lt;'\n';
    }
    return 0;
}</pre><br><b>2.倍增：</b><pre>
#include &lt;vector&gt;
#include &lt;iostream&gt;
using namespace std;
#define maxn 500100
vector&lt;int&gt; linker[maxn];
int n,m,s,x,y;
int fa[maxn][30],dep[maxn];
void dfs(int u,int father){
    fa[u][0]=father;
    dep[u]=dep[father]+1;
    <span>//fa数组的初始化，可以考虑在dfs的时候一块弄，不过这样会略微超时，所以我把fa数组初始化提出来了。见下文__init()函数</span>
<span>//	for(int i=1;i&lt;=19;i++){</span>
<span>//		fa[u][i]=fa[fa[u][i-1]][i-1];</span>
<span>//	}</span>
    for(int i=0;i&lt;linker[u].size();i++){
        if(linker[u][i]!=father)dfs(linker[u][i],u);
    }
}
void swap(int &x,int &y){
    int tmp=x;x=y;y=tmp;
}
int lca(int u,int v){
    if(dep[u]&lt;dep[v])swap(u,v);
    for(int i=19;i&gt;=0;i--){
        if(dep[fa[u][i]]&gt;=dep[v]){
            u=fa[u][i];
        }
    }
    if(u==v)return v;
    for(int i=19;i&gt;=0;i--){
        if(fa[u][i]!=fa[v][i]){
            u=fa[u][i];v=fa[v][i];
        }
    }
    return fa[u][0];
}
void __init(){
    for(int i=1;i&lt;20;i++){
        for(int j=1;j&lt;=n;j++){
            fa[j][i]=fa[fa[j][i-1]][i-1];
        }
    }
}
int main()
{
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;
    for(int i=1;i&lt;n;i++){
        cin&gt;&gt;x&gt;&gt;y;
        linker[x].push_back(y);
        linker[y].push_back(x);
    }
    dfs(s,0);
    __init();<span>//把fa数组提出来处理，虽然仍会TLE，但比之前好一点。</span>
    while(m--){
        cin&gt;&gt;x&gt;&gt;y;
        cout&lt;&lt;lca(x,y)&lt;&lt;'\n';
    }
    return 0;
}
</pre><br><b>3.tarjan算法</b><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
#define maxn 500100
vector&lt;int&gt; linker[maxn];
vector&lt;pair&lt;int,int&gt; &gt; query[maxn];
int fa[maxn],vis[maxn],ans[maxn],n,m,s,x,y;
int find(int u){
    if(u==fa[u])return u;
    return fa[u]=find(fa[u]);
}
void tarjan(int u){
    vis[u]=true;
    for(int i=0;i&lt;linker[u].size();i++){
        if(!vis[linker[u][i]]){
            tarjan(linker[u][i]);
            fa[linker[u][i]]=u;
        }
    }
    for(int i=0;i&lt;query[u].size();i++){
        int v=query[u][i].first,q=query[u][i].second;
        if(vis[v])ans[q]=find(v);
    }
}
int main(){
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;
    for(int i=1;i&lt;n;i++){
        cin&gt;&gt;x&gt;&gt;y;
        linker[x].push_back(y);
        linker[y].push_back(x);
    }
    for(int i=1;i&lt;=m;i++){
        cin&gt;&gt;x&gt;&gt;y;
        query[x].push_back({y,i});
        query[y].push_back({x,i});
    }
    for(int i=1;i&lt;=n;i++){
        fa[i]=i;
    }
    tarjan(s);
    for(int i=1;i&lt;=m;i++){
        cout&lt;&lt;ans[i]&lt;&lt;'\n';
    }
    return 0;
}
</pre><br><br>总结：数列剖分比较易于理解，而且不超时，但比较麻烦。倍增算法易于理解但是超时。tarjan算法不好理解，但是是最高效的。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1395">P1395 会议</a><a href="https://www.luogu.com.cn/problem/list?difficulty=3">普及/提高-</a>典型的找树的重心的问题啊！！！但我不会呜呜呜。<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;
using namespace std;
#define maxn 10000010
int n,f[maxn],size[maxn],center,sum,dep[maxn];<span>//center为重心</span>
vector&lt;int&gt; G[maxn];
queue&lt;int&gt; q;
void getcenter(int u,int fa){
    size[u]=1;f[u]=0;
    for(int i=0;i&lt;G[u].size();i++){
        int v=G[u][i];
        if(v==fa)continue;
        getcenter(v,u);
        size[u]+=size[v];
        f[u]=max(f[u],size[v]);<span>//f[u]保存了点u的最大子树大小</span>
    }
    f[u]=max(f[u],n-size[u]);
    <span>//size[u]计算完之后，计算树中除了该点的部分，并和之前的f[u]取较大值</span>
    if(f[u]&lt;f[center]||(f[u]==f[center]&&u&lt;center)){
        center=u;<span>//如果f[u]较小，更新找到的重心</span>
    }
}
void bfs(){
    q.push(center);
    while(!q.empty()){
        int u=q.front();q.pop();
        for(int i=0;i&lt;G[u].size();i++){
            int v=G[u][i];
            if(dep[v]||v==center)continue;
            dep[v]=dep[u]+1;<span>//深度</span>
            sum+=dep[v];<span>//总距离要加上这个点的深度</span>
            q.push(v);
        }
    }
}
int main()
{
    cin&gt;&gt;n;
    for(int i=1,x,y;i&lt;=n-1;i++){
        cin&gt;&gt;x&gt;&gt;y;
        G[x].push_back(y);
        G[y].push_back(x);
    }
    center=0;f[0]=0x3f3f3f3f;
    getcenter(1,0);<span>//求重心</span>
    bfs();<span>//从重心开始求距离</span>
    cout&lt;&lt;center&lt;&lt;' '&lt;&lt;sum;
    return 0;
}
    </pre>代码还是挺好理解的哦~</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1099">P1099 [NOIP2007 提高组] 树网的核</a><a href="https://www.luogu.com.cn/problem/list?difficulty=4">普及+/提高</a>找直径，我们可以跑两遍DFS，随便找一点DFS到最远端，然后在最远端开始DFS找对于这个最远端来说的最远端。这两个最远端的距离就是直径。<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#define M 500005
using namespace std;
int n,m,x,y,z,k,id,top,ans=2e9;
int dis[M],fa[M],head[M];
bool mark[M];
struct node{
    int to,w,nxt;
}E[M&lt;&lt;1];
void add(int u,int v,int w){
    E[++id]=((node){v,w,head[u]});
    head[u]=id;<span>//存图</span>
}
void dfs(int f,int x){
    fa[x]=f;
    if(dis[x]&gt;dis[k])k=x;
    for(int i=head[x];i;i=E[i].nxt){
        int y=E[i].to;
        if(y==f||mark[y])continue;
        dis[y]=dis[x]+E[i].w;
        dfs(x,y);
    }
}
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;n;i++){
        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;
        add(x,y,z);add(y,x,z);
    }
    dis[1]=1;dfs(0,1);
    dis[k]=0;dfs(0,k);
    top=k;<span>//k表示最远的端点</span>
    for(int i=top,j=top,l=1,r=0;i;i=fa[i]){
        while(dis[j]-dis[i]&gt;m)j=fa[j];
        <span>//进行尺取，选路径。</span>
        x=max(dis[top]-dis[j],dis[i]);
        <span>//路径两端点到直径端点的最小贡献.</span>
        ans=min(ans,x);
    }
    for(int i=top;i;i=fa[i])mark[i]=1;
    <span>//标记直径，重新计算每个点的贡献。</span>
    for(int i=top;i;i=fa[i]){
        k=i;dis[k]=0;
        dfs(fa[i],i);
    }
    for(int i=1;i&lt;=n;i++){
        ans=max(ans,dis[i]);<span>//每个点的贡献，仔细想想为什么是对的。</span>
    }
    cout&lt;&lt;ans;
    return 0;
}
</pre></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P5908">P5908 猫猫和企鹅</a><a href="https://www.luogu.com.cn/problem/list?difficulty=2">普及-</a>这普及的题目啊，就一个字，“细节”！<pre>
#include &lt;iostream&gt;
using namespace std;
long long p[4000001];
long long ans,n,d,x,y;
int main()
{
    cin&gt;&gt;n&gt;&gt;d;
    for(int i=1;i&lt;=n-1;i++){
        cin&gt;&gt;x&gt;&gt;y;
        if(x&gt;y)int tmp=x,x=y,y=tmp;
        p[y]=p[x]+1;
        if(p[y]&lt;=d)ans++;
    }
    cout&lt;&lt;ans;
    return 0;
}
    </pre>因为题目中没有说输入的x和y一定是x小于y，她只是说了：“居民区x和y之间存在道路”。这也就是本题的坑点。导致我WA零分！所以输入数据要判断x如果大于y就交换她俩。<br><hr style="width: 100%;">那为什么建图就AC了呢？其实原因就在于建图的建了无向边，恰好规避了这个顺序问题。其实这道题的数据也比较水，如果我来个这个数据：<pre>
5 1
1 5
3 5
2 3
4 2</pre>这个数据按道理老说应该输出1，但是却输出了4，也就是说，我们这个代码是会WA的，之所以AC了，是因为数据太水了。这都能过，我也是服了。比赛时保险起见还是建图比较好。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P3810">P3810 【模板】三维偏序（陌上花开）</a><a href="https://www.luogu.com.cn/problem/list?difficulty=6">省选/NOI-</a>省选代码都可长了~连一个模板都要这么长！<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
#define maxn 1000006
int n,k,cnt[maxn];<span>// n是元素数量，k是最大属性值，cnt数组用于存储结果</span>
struct Data
{
    int x,y,z;
    <span>// 重载小于运算符，用于排序</span>
    int operator &lt; (const Data &o)const{
        return x!=o.x?(x&lt;o.x):(y!=o.y?(y&lt;o.y):(z&lt;o.z));
    }
    <span>// 重载等于运算符，用于比较两个元素是否相等</span>
    int operator == (const Data &o)const{
        return x==o.x&&y==o.y&&z==o.z;
    }
}data[maxn];

<span>// 树状数组（线段树）的定义</span>
struct Seg{
    struct Node{
        int val;
        Node *ch[2];
        Node(int val=0):val(val){
            ch[0]=ch[1]=NULL;
        }
    };
    Node *rt;
    Seg(){
        rt=NULL;
    }
    <span>// 修改操作，在树状数组中的指定位置增加或减少值</span>
    void Modify(Node *&now,int pos,int val,int nl,int nr){
        if(!now)now=new Node();
        if(nl==nr){
            now-&gt;val+=val;
            return;
        }
        int mid=(nl+nr)&gt;&gt;1;
        if(pos&lt;=mid)Modify(now-&gt;ch[0],pos,val,nl,mid);
        else Modify(now-&gt;ch[1],pos,val,mid+1,nr);
        now-&gt;val=(now-&gt;ch[0]?now-&gt;ch[0]-&gt;val:0)+(now-&gt;ch[1]?now-&gt;ch[1]-&gt;val:0);
    }
    <span>// 查询操作，获取树状数组中指定区间的和</span>
    int Query(Node *now,int l,int r,int nl,int nr){
        if(!now)return 0;
        if(l==nl&&r==nr)return now-&gt;val;
        int mid=nl+nr&gt;&gt;1;
        if(r&lt;=mid)return Query(now-&gt;ch[0],l,r,nl,mid);
        else if(l&gt;mid)return Query(now-&gt;ch[1],l,r,mid+1,nr);
        return Query(now-&gt;ch[0],l,mid,nl,mid)+Query(now-&gt;ch[1],mid+1,r,mid+1,nr);
    }
};
Seg tree[maxn];<span>// 树状数组数组，用于处理每个x值的y,z坐标统计</span>
int LB(int x){
    return x&(-x);
}
void Modify(int posx,int posy,int val){
    for(int i=posx;i&lt;=k;i+=LB(i)){
        tree[i].Modify(tree[i].rt,posy,val,1,k);
    }
}
int Query(int x,int y){
    int ret=0;
    for(int i=x;i;i-=LB(i))ret+=tree[i].Query(tree[i].rt,1,y,1,k);
    return ret;
}
int main(){
    cin&gt;&gt;n&gt;&gt;k;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;data[i].x&gt;&gt;data[i].y&gt;&gt;data[i].z;
    }
    sort(data+1,data+n+1);<span> // 按x,y,z排序 </span>
    int sum=1;<span>// 用于处理相同元素的数量</span>
    for(int i=1;i&lt;=n;i++){
        if(data[i+1]==data[i]){
            sum++;<span>// 如果下一个元素与当前元素相同，增加sum</span>
            continue;
        }
        Modify(data[i].y,data[i].z,sum);<span>// 在树状数组中记录当前元素</span>
        int res=Query(data[i].y,data[i].z);<span>// 查询小于等于当前y,z的点的数量</span>
        cnt[res]+=sum;
        sum=1;<span>// 重置sum</span>
    }
    for(int i=1;i&lt;=n;i++)cout&lt;&lt;cnt[i]&lt;&lt;'\n';
    return 0;
}
    </pre></div>
    <div class="t1">树<img src="https://upload-bbs.miyoushe.com/upload/2024/10/18/198629752/4ac1d4603e95ddbde0301655b6273856_5867892361830757225.png" alt="树"></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P4587">P4587 [FJOI2016] 神秘数</a>这也是一个模板题，不过我不会，呜呜呜~<a href="https://www.luogu.com.cn/problem/list?difficulty=6">省选/NOI-</a><pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
#define N 1000001 <span>//数组最大值</span>
int n,m,tot,rt[N],ans;
struct node{
    int ls[N&lt;&lt;5],rs[N&lt;&lt;5],v[N&lt;&lt;5];<span>//小一点就RE</span>
    void cp(int x,int y){
        ls[x]=ls[y],rs[x]=rs[y],v[x]=v[y];<span>//节点复制</span>
    }
    void fix(int pl,int pr,int l,int r,int x){
        cp(pr,pl),v[pr]+=x;<span>//按照pl新建一个节点pr(两棵树可以共享节点)</span>
        if(l==r)return;
        int mid=(l+r)&gt;1;
        if(mid&gt;=x) fix(ls[pl],ls[pr]=++tot,l,mid,x);
        else fix(rs[pl],rs[pr]=++tot,mid+1,r,x);
    }
    int sum(int pl,int pr,int l,int r,int x,int y){<span>//得出pr和pl之间的大于x小于y的数的和</span>
        if(v[pr]-v[pl]==0) return 0;
        if(l&gt;=x&&r&lt;=y) return v[pr]-v[pl];
        int ret=0,mid=(l+r)&gt;1;
        if(mid&gt;=x) ret+=sum(ls[pl],ls[pr],l,mid,x,y);
        if(mid&lt;y) ret+=sum(rs[pl],rs[pr],mid+1,r,x,y);
        return ret;
    }
}tree;
int main(){
    cin&gt;n;
    for(int i=1;i&lt;=n;i++){
        int x;
        cin&gt;x;
        tree.fix(rt[i-1],rt[i]=++tot,1,N&lt;&lt;10,x);
    }
    cin&gt;m;
    for(int i=1;i&lt;=m;i++){
        int L,R,tmp,lst=0,now=0;
        cin&gt;L&gt;R;
        while(1){
            tmp=tree.sum(rt[L-1],rt[R],1,N&lt;&lt;10,lst+1,now+1);<span>//算法精华</span>
            if(tmp){
                lst=now+1;now+=tmp;
            }
            else break;
        }
        cout&lt;&lt;now+1&lt;&lt;'\n';
    }
    return 0;
}
    </pre></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P3834">P3834 【模板】可持久化线段树 2</a><a href="https://www.luogu.com.cn/problem/list?difficulty=5">提高+/省选-</a><pre>
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
#define N 200010
int n,q,m,cnt;<span>// n为序列长度，q为查询数量，m为去重后的元素数量，cnt为节点计数器</span>
int a[N],b[N],tree[N];<span>// a为原始序列，b为排序后的唯一元素序列，tree为可持久化线段树的根节点数组</span>
int sum[N&lt;&lt;5],L[N&lt;&lt;5],R[N&lt;&lt;5];<span>// sum为线段树节点存储的区间和（此处为元素个数），L和R为左右子节点指针</span>
<span>// 构建空线段树</span>
inline int build(int l,int r){
    int mid=(l+r)&gt;&gt;1;
    int rt=++cnt;<span> // 新建节点</span>
    sum[rt]=0;<span>// 初始化区间和为0</span>
    if(l&lt;r){
        L[rt]=build(l,mid);<span>// 递归构建左子树</span>
        R[rt]=build(mid+1,r);<span>// 递归构建右子树</span>
    }
    return rt;<span>// 返回当前节点编号 </span>
}
<span>// 更新线段树，插入新元素</span>
inline int update(int pre,int l,int r,int x){
    int mid=(l+r)&gt;&gt;1;
    int rt=++cnt;<span>// 新建节点</span>
    L[rt]=L[pre];R[rt]=R[pre];sum[rt]=sum[pre]+1;<span>// 复制前驱节点的信息，并增加区间和</span>
    if(l&lt;r){
        if(x&lt;=mid) L[rt]=update(L[pre],l,mid,x);<span>// 如果x在左子树范围内，更新左子树</span>
        else R[rt]=update(R[pre],mid+1,r,x);<span>// 否则更新右子树</span>
    }
    return rt;<span>// 返回当前节点编号</span>
}
<span>// 查询区间第k小值</span>
inline int query(int u,int v,int l,int r,int k){
    int mid=(l+r)&gt;&gt;1;
    if(l&gt;=r)return l;<span>// 如果区间长度为1，直接返回该位置的值（但此处不会执行，因为k一定小于区间长度）</span>
    int x=sum[L[v]]-sum[L[u]];<span>// 计算v和u在左子树中的区间和之差，即[l, mid]区间内v有而u没有的元素个数</span>
    if(x&gt;=k)return query(L[u],L[v],l,mid,k);<span>// 如果左子树中的元素个数大于等于k，继续在左子树中查询</span>
    else return query(R[u],R[v],mid+1,r,k-x);<span>// 否则，在右子树中查询第(k-x)小的元素  </span>
}
int main()
{
    cin&gt;&gt;n&gt;&gt;q;<span>// 输入序列长度和查询数量  </span>
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;a[i];
        b[i]=a[i];<span>// 将a数组的元素复制到b数组，用于后续排序和去重  </span>
    }
    sort(b+1,b+n+1);<span> // 对b数组进行排序  </span>
    m=unique(b+1,b+n+1)-b-1;<span>// 去重，并计算去重后的元素数量  </span>
    <span>// 构建可持久化线段树  </span>
    tree[0]=build(1,m);<span>// 构建空线段树作为根节点（虽然实际上没有用到，但为了统一接口）  </span>
    for(int i=1;i&lt;=n;i++){
        int t=lower_bound(b+1,b+m+1,a[i])-b;<span>// 在b数组中找到a[i]的位置（排序后的） </span>
        tree[i]=update(tree[i-1],1,m,t);<span>// 基于前一个节点的线段树，插入新元素a[i]  </span>
    }
    <span>// 查询并输出结果</span>
    while(q--){
        int x,y,z;
        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;<span>// 输入查询的区间[x, y]和k值 </span>
        int t=query(tree[x-1],tree[y],1,m,z);<span> // 在线段树中查询区间[x, y]内的第z小值  </span>
        cout&lt;&lt;b[t]&lt;&lt;'\n';<span>// 输出查询结果  </span>
    }
    return 0;
}
    </pre>*这段代码实现了可持久化权值线段树，用于解决静态区间第k小值的问题。通过构建一系列版本的线段树，每个版本都基于前一个版本进行更新，从而可以在O(log n)的时间内查询任意区间的第k小值。<br><a href="https://yiyan.baidu.com/" style="text-decoration: none;color: rgb(0, 132, 255);">代码注释by: 文心一言®</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P5283">P5283 [十二省联考 2019] 异或粽子</a>区间[l,r]的异或和等于sr⊕sl-1因为每个si都异或了两遍而抵消。<pre>
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;cstring&gt;
using namespace std;
#define ll long long
#define maxn 501000
int n,k;
ll a[maxn];
int trie[maxn*32][2],sz[maxn*32],tot=0;
void insert(ll val){
    int u=0;
    for(int i=31;i&gt;=0;i--){
        int z=(val&gt;&gt;i)&amp;1;
        if(!trie[u][z]){
            trie[u][z]=++tot;
        }
        u=trie[u][z];
        sz[u]++;
    }
}
ll find(ll val,int t){
    ll s=0;
    int u=0;
    for(int i=31,z;i&gt;=0;i--){
        z=(val&gt;&gt;i)&amp;1;
        if(sz[trie[u][z^1]]&gt;=t){
            u=trie[u][z^1];
            s|=(1ll&lt;&lt;i);
        }else{
            t-=sz[trie[u][z^1]];
            u=trie[u][z];
        }
    }
    return s;
}
struct node{
    ll w;
    int x,y;<span>//x的第y大</span>
    bool operator&lt;(const node &amp;A)const{
        return w&lt;A.w;
    }
};
node d[maxn];
priority_queue&lt;node&gt; q;
int main(){
    cin&gt;&gt;n&gt;&gt;k;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;a[i];
        a[i]^=a[i-1];
    }
    for(int i=0;i&lt;=n;i++){
        insert(a[i]);
    }
    k=2*k;
    for(int i=0;i&lt;=n;i++){
        d[i].w=find(a[i],1);
        d[i].x=i;
        d[i].y=1;
        q.push(d[i]);
    }
    ll ans=0;
    node A;
    for(int i=1;i&lt;=k;i++){
        A=q.top();
        ans+=A.w;
        q.pop();
        d[A.x].y++;
        d[A.x].w=find(a[A.x],d[A.x].y);
        q.push(d[A.x]);
    }
    ans/=2;
    cout&lt;&lt;ans;
    return 0;
}
    </pre></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P4551">P4551 最长异或路径</a>01-Trie树。<pre>
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
struct node{
    int v,w,nxt;
}edge[2000001];
int head[2000001];
int cnt=1;
void add(int u,int v,int w){
    edge[++cnt].nxt=head[u];
    edge[cnt].v=v;
    edge[cnt].w=w;
    head[u]=cnt;
}
int sum[2000001];
void dfs(int x,int fa){<span>//预处理 </span>
    for(int i=head[x];~i;i=edge[i].nxt){
        int v=edge[i].v;
        int w=edge[i].w;
        if(v!=fa){
            sum[v]=sum[x]^w;
            dfs(v,x);
        }
    }
}
struct trie{
    int ch[2];
}t[2000001];
int tot;
void build(int val,int x){
    for(int i=(1&lt;&lt;30);i;i&gt;&gt;=1){
        bool c=val&amp;i;<span>//取出二进制下这个数的当前位置 </span>
        if(!t[x].ch[c]){
            t[x].ch[c]=++tot;
        }
        x=t[x].ch[c];
    }
}
int query(int val,int x){
    int ans=0;
    for(int i=(1&lt;&lt;30);i;i&gt;&gt;=1){
        bool c=val&amp;i;
        if(t[x].ch[!c]){<span>//如果这一位可以进行异或就沿着这一条往下走 </span>
            ans+=i;
            x=t[x].ch[!c];
        }
        else x=t[x].ch[c];<span>//否则就沿着另一条路往下走 </span>
    }
    return ans;
}
int main()
{
    memset(head,-1,sizeof(head));
    int n;
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n-1;i++){
        int u,v,w;
        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;
        add(u,v,w);
        add(v,u,w);
    }
    dfs(1,-1);<span>//预处理出每一个节点到根的异或和 </span>
    for(int i=1;i&lt;=n;i++){<span>//建立trie树 </span>
        build(sum[i],0);
    }
    int ans=0;
    for(int i=1;i&lt;=n;i++){
        ans=max(ans,query(sum[i],0));<span>//查询，取最大值 </span>
    }
    cout&lt;&lt;ans;
}
    </pre></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P2580">P2580 于是他错误的点名开始了</a>STL大法好！用map叫我做爽了。<pre>
#include &lt;iostream&gt;
#include &lt;map&gt;
using namespace std;
map&lt;string,int&gt; mp;
int main(){
    int n;
    cin&gt;&gt;n;
    while(n--){
        string s;
        cin&gt;&gt;s;
        mp[s]=1;
    }
    cin&gt;&gt;n;
    while(n--){
        string s;
        cin&gt;&gt;s;
        if(mp[s]==1&&mp[s]++)
            cout&lt;&lt;"OK"&lt;&lt;'\n';
        else if(mp[s]==0)
            cout&lt;&lt;"WRONG"&lt;&lt;'\n';
        else if(mp[s]&gt;1)
            cout&lt;&lt;"REPEAT"&lt;&lt;'\n';
    }
    return 0;
}
    </pre>不过这道题既然是字典树，那我们就用字典树来解吧！<br>*But，我不会。<img src="https://upload-bbs.miyoushe.com/upload/2024/10/16/302083128/5cd66a31025f6db429719874abee013b_8339061302961208307.gif" alt="啊啊啊" style="width: 150px;"></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1481">P1481 魔族密码</a>Trie字典树题目。<pre>
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
using namespace std;
char c[90];
int word[1000],g[1000][1000];
int ans,res,u,tot,n;
void f(){
    int len=strlen(c);
    u=res=0;
    for(int i=0;i&lt;len;i++){
        int a=c[i]-'0';
        if(!g[u][a])g[u][a]=++tot;
        u=g[u][a];
        res+=word[u];
    }
    word[u]++;
    ans=max(ans,res+1);
}
int main()
{
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        memset(c,0,sizeof(0));
        cin&gt;&gt;c;
        f();
    }
    cout&lt;&lt;ans;
    return 0;
}
    </pre></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P3368">P3368 【模板】树状数组 2</a><ul>
        <li>区间修改</li><li>单点查找</li>
    </ul><pre>
#include &lt;iostream&gt;
using namespace std;
#define maxn 500010
int n,m;
int a[maxn],c[maxn],b[maxn];
int lowbit(int x){
    return x&(-x);
}
void add(int x,int y){
    for(int i=x;i&lt;=n;i+=lowbit(i))
        c[i]+=y;
}
int sum(int x){
    int res=0;
    for(int i=x;i;i-=lowbit(i))
        res+=c[i];
    return res;
}
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;a[i];
        b[i]=a[i]-a[i-1];
        add(i,b[i]);
    }
    while(m--){
        int op,x,y,k;
        cin&gt;&gt;op;
        if(op==1)
        {
            cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;
            add(x,k);
            add(y+1,-k);
        }
        else
        {
            cin&gt;&gt;x;
            cout&lt;&lt;sum(x)&lt;&lt;'\n';
        }
    }
    return 0;
}
    </pre></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P3374">P3374 【模板】树状数组 1</a>还挺简单的，我用线段树一遍AC了，没想到我还是会写线段树的啊，哈哈哈~ <img src="https://upload-bbs.miyoushe.com/upload/2024/10/16/265801674/2939e5b79007fb2673dba8fcbea8b89f_4984784221438249415.gif" alt="哈哈哈" style="width: 150px;"><br>*But，不过这道题让我用的是树状数组......<br><b>线段树做法：</b><pre style="height: 400px;">
#include &lt;iostream&gt;
using namespace std;
#define int long long
<span>//考场不建议把int替换为long long，万一RE了呢？谁知道评测机上跑的啥样？ </span>
struct node{
    int val;
}tree[4000001];
int a[1000100];
void build(int root,int l,int r){
    if(l==r){
        tree[root].val=a[l];
        return;
    }
    int m=(l+r)&gt;&gt;1;
    build(root&lt;&lt;1,l,m);
    build(root&lt;&lt;1|1,m+1,r);
    tree[root].val=tree[root&lt;&lt;1].val+tree[root&lt;&lt;1|1].val;
}
void update(int root,int l,int r,int ql,int qr,int k){
    if(qr&lt;l||r&lt;ql)return;<span>//这一句必须加，不加就卡住了 </span>
    if(ql&lt;=l&&r&lt;=qr){
        tree[root].val+=k;
        return;
    }
    int m=(l+r)&gt;&gt;1;
    update(root&lt;&lt;1,l,m,ql,qr,k);
    update(root&lt;&lt;1|1,m+1,r,ql,qr,k);
    tree[root].val=tree[root&lt;&lt;1].val+tree[root&lt;&lt;1|1].val;
}
int query(int root,int l,int r,int ql,int qr){
    if(qr&lt;l||r&lt;ql)return 0;<span>//这一句必须加，不加就卡住了</span> 
    if(ql&lt;=l&&r&lt;=qr){
        return tree[root].val;
    }
    int m=(l+r)&gt;&gt;1;
    return query(root&lt;&lt;1,l,m,ql,qr)+query(root&lt;&lt;1|1,m+1,r,ql,qr);
}
int n,m,op,x,y,k;
signed main()
{
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;a[i];
    }
    build(1,1,n);
    while(m--)
    {
        cin&gt;&gt;op;
        if(op==1){
            cin&gt;&gt;x&gt;&gt;k;
            update(1,1,n,x,x,k);
        }
        else{
            cin&gt;&gt;x&gt;&gt;y;
            cout&lt;&lt;query(1,1,n,x,y)&lt;&lt;'\n';
        }
    }
    return 0;
}
    </pre><br><b>树状数组求法：</b><ul>
        <li>单点修改</li><li>区间查找</li>
    </ul><pre>
#include &lt;iostream&gt;
using namespace std;
#define maxn 500010
int n,m;
int a[maxn],c[maxn];
int lowbit(int x){
    return x&(-x);
}
int sum(int x){
    int res=0;
    for(int i=x;i;i-=lowbit(i))
        res+=c[i];
    return res;
}
void add(int x,int y){
    for(int i=x;i&lt;=n;i+=lowbit(i))
        c[i]+=y;
}
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;a[i];
        add(i,a[i]);
    }
    while(m--){
        int op,x,y;
        cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;
        if(op==1)
            add(x,y);
        else
            cout&lt;&lt;sum(y)-sum(x-1)&lt;&lt;'\n';
    }
    return 0;
}
    </pre></div>
    <div class="t1">树状数组与字典树<img src="https://upload-bbs.miyoushe.com/upload/2024/10/16/198629752/c5d9ad7673cdfc1000a1c34ada514390_7005827162608113595.png" alt="树状数组"></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P3373">P3373 【模板】线段树 2</a>这个模板代码我调了半天才发现其中一个+号不小心写成了*号，就连鲨笔AI都查不出来。<pre>
#include &lt;iostream&gt;
using namespace std;
#define int long long
struct node{
    int mul,add,val;
}tree[4000011];
int a[1000001],p;
void pushdown(int root,int l,int r){
    int m=(l+r)&gt;&gt;1;
    tree[root&lt;&lt;1].val=(tree[root&lt;&lt;1].val*tree[root].mul+tree[root].add*(m-l+1))%p;
    tree[root&lt;&lt;1|1].val=(tree[root&lt;&lt;1|1].val*tree[root].mul+tree[root].add*(r-m))%p;
    tree[root&lt;&lt;1].mul=(tree[root&lt;&lt;1].mul*tree[root].mul)%p;
    tree[root&lt;&lt;1|1].mul=(tree[root&lt;&lt;1|1].mul*tree[root].mul)%p;
    tree[root&lt;&lt;1].add=(tree[root&lt;&lt;1].add*tree[root].mul+tree[root].add)%p;
    tree[root&lt;&lt;1|1].add=(tree[root&lt;&lt;1|1].add*tree[root].mul+tree[root].add)%p;
    tree[root].add=0;
    tree[root].mul=1;
}
void build(int root,int l,int r){
    tree[root].mul=1;
    tree[root].add=0;
    if(l==r){
        tree[root].val=a[l];
    }
    else{
        int m=(l+r)&gt;&gt;1;
        build(root&lt;&lt;1,l,m);
        build(root&lt;&lt;1|1,m+1,r);
        tree[root].val=tree[root&lt;&lt;1].val+tree[root&lt;&lt;1|1].val;
    }
    tree[root].val%=p;
    return;
}
void updateC(int root,int l,int r,int ql,int qr,int k){
    if(qr&lt;l||r&lt;ql){
        return;
    }
    if(ql&lt;=l&&r&lt;=qr){
        tree[root].val=(tree[root].val*k)%p;
        tree[root].mul=(tree[root].mul*k)%p;
        tree[root].add=(tree[root].add*k)%p;
        return;
    }
    pushdown(root,l,r);
    int m=(l+r)&gt;&gt;1;
    updateC(root&lt;&lt;1,l,m,ql,qr,k);
    updateC(root&lt;&lt;1|1,m+1,r,ql,qr,k);
    tree[root].val=(tree[root&lt;&lt;1].val+tree[root&lt;&lt;1|1].val)%p;
}
void updateJ(int root,int l,int r,int ql,int qr,int k){
    if(qr&lt;l||r&lt;ql){
        return;
    }
    if(ql&lt;=l&&r&lt;=qr){
        tree[root].add=(tree[root].add+k)%p;
        tree[root].val=(tree[root].val+k*(r-l+1))%p;
        return;
    }
    pushdown(root,l,r);
    int m=(l+r)&gt;&gt;1;
    updateJ(root&lt;&lt;1,l,m,ql,qr,k);
    updateJ(root&lt;&lt;1|1,m+1,r,ql,qr,k);
    tree[root].val=(tree[root&lt;&lt;1].val+tree[root&lt;&lt;1|1].val)%p;
}
int query(int root,int l,int r,int ql,int qr){
    if(qr&lt;l||r&lt;ql){
        return 0;
    }
    if(ql&lt;=l&&r&lt;=qr){
        return tree[root].val;
    }
    pushdown(root,l,r);
    int m=(l+r)&gt;&gt;1;
    return (query(root&lt;&lt;1,l,m,ql,qr)+query(root&lt;&lt;1|1,m+1,r,ql,qr))%p;
}
int n,q,op,x,y,k;
signed main()
{
    cin&gt;&gt;n&gt;&gt;q&gt;&gt;p;
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;a[i];
    }
    build(1,1,n);
    while(q--)
    {
        cin&gt;&gt;op;
        if(op==1){
            cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;
            updateC(1,1,n,x,y,k);
        }
        else if(op==2){
            cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;
            updateJ(1,1,n,x,y,k);
        }
        else{
            cin&gt;&gt;x&gt;&gt;y;
            cout&lt;&lt;query(1,1,n,x,y)%p&lt;&lt;'\n';
        }
    }
    return 0;
}
    </pre>这个故事告诉我们要仔细检查。<p>这个代码是仿照<a href="https://www.luogu.com.cn/problem/solution/P3373">@zhuwanman</a>的代码抄的~</p></div>
    <div class="t1">手写max太慢，容易TLE，具体原理我也不清楚，反正<code>#define max(a,b) (a>b?a:b)</code>这个以后就不要用了。以后就用algorithm里面的max函数就好了。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1253">P1253 扶苏的问题</a>手写max容易超时，眼都快看花了，后面看了讨论区才知道手写max太慢。😓这个代码建议多看几遍，毕竟线段树挺重要的。这个线段树代码支持修改、查找、最大值比较操作，知识点还算全。<pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cctype&gt;
#include &lt;algorithm&gt;
using namespace std;
<span>//#define max(a,b) (a&gt;b?a:b)</span>
<span>//总结，能不用就不用，用了就会超时。 </span>
#define ll long long
ll a[4000001];
struct node{
    ll data,add=0;
    bool set=0;
}tree[4000501];
inline void build(ll root,ll l,ll r){
    ll num;
    if(l==r){
        tree[root].data=a[l];
        num=max(num,root);
        return;
    }
    ll m=(l+r)&gt;&gt;1;
    build(root&lt;&lt;1,l,m);
    build((root&lt;&lt;1)+1,m+1,r);
    tree[root].data=max(tree[root&lt;&lt;1].data,tree[(root&lt;&lt;1)+1].data);
}
inline void pushdown(ll root){
    if(tree[root].set){
        tree[root].set=0;
        tree[root].add=0;
        tree[root&lt;&lt;1].add=0;
        tree[root&lt;&lt;1].set=1;
        tree[root&lt;&lt;1].data=tree[root].data;
        tree[(root&lt;&lt;1)+1].add=0;
        tree[(root&lt;&lt;1)+1].set=1;
        tree[(root&lt;&lt;1)+1].data=tree[root].data;
    }
    else
    {
        tree[root&lt;&lt;1].add+=tree[root].add;
        tree[root&lt;&lt;1].data+=tree[root].add;
        tree[(root&lt;&lt;1)+1].add+=tree[root].add;
        tree[(root&lt;&lt;1)+1].data+=tree[root].add;
        tree[root].add=0;
    }
}
inline ll query(ll root,ll l,ll r,ll ql,ll qr){
    ll ans=-1e18;
    if(l&lt;=ql&&r&gt;=qr)return tree[root].data;
    pushdown(root);
    ll m=(ql+qr)&gt;&gt;1;
    if(l&lt;=m)ans=max(ans,query(root&lt;&lt;1,l,r,ql,m));
    if(r&gt;m)ans=max(ans,query((root&lt;&lt;1)+1,l,r,m+1,qr));
    return ans;
}
inline void update(ll root,ll L,ll R,ll l,ll r,ll k)
{
    if(L&lt;=l&&R&gt;=r)
    {
        tree[root].add+=k;tree[root].data+=k;
        return;
    }
    pushdown(root);
    ll m=(l+r)&gt;&gt;1;
    if(L&lt;=m)update(root&lt;&lt;1,L,R,l,m,k);
    if(R&gt;m)update((root&lt;&lt;1)+1,L,R,m+1,r,k);
    tree[root].data=max(tree[root&lt;&lt;1].data,tree[(root&lt;&lt;1)+1].data);
}
inline void reset(ll root,ll L,ll R,ll l,ll r,ll k)
{
    if(L&lt;=l&&R&gt;=r)
    {
        tree[root].add=0;tree[root].data=k;tree[root].set=1;
        return;
    }
    pushdown(root);
    ll m=(l+r)&gt;&gt;1;
    if(L&lt;=m)reset(root&lt;&lt;1,L,R,l,m,k);
    if(R&gt;m)reset((root&lt;&lt;1)+1,L,R,m+1,r,k);
    tree[root].data=max(tree[root&lt;&lt;1].data,tree[(root&lt;&lt;1)+1].data);
}
ll read()
{
    ll s=0,w=1;char ch=getchar();
    while(!isdigit(ch)){<span>//使用isdigit()函数被忘了引用cctype </span>
        if(ch=='-')w=-1;
        ch=getchar();
    }
    while(isdigit(ch)){
        s=s*10+ch-'0';
        ch=getchar();
    }
    return s*w;
}
int main()
{
    ll n,q,l,r,x,op;
    n=read();q=read();
    for(int i=1;i&lt;=n;i++)
    {
        a[i]=read();
    }
    build(1,1,n);
    while(q--)
    {
        op=read();
        if(op==1)
        {<span>//把(l,r)的所有数修改成x。 </span>
            l=read();r=read();x=read();
            reset(1,l,r,1,n,x);
        }
        else if(op==2)
        {<span>//对(l,r)区间的每个数加x。 </span>
            l=read();r=read();x=read();
            update(1,l,r,1,n,x);
        }
        else
        {<span>//查询(l,r)区间的最大值。 </span>
            l=read();r=read();
            printf("%lld\n",query(1,l,r,1,n));
        }
    }
    return 0;
}
</pre></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1438">P1438 无聊的数列</a>在线段树当中算是一个进阶题了吧。我想我得把这个记下来，这道题是区间加上一个等差数列，那么我们是选择使用线段树+差分完成的。这个是结构体版本的，只需要2个数组就能完成。<pre>
#include &lt;iostream&gt;
using namespace std;
#define ll long long
ll data[100010];
struct point{<span>//结构体定义节点</span>
    ll sum;
    ll tag;
}a[400001];
inline int ls(int root){
    <span>//左孩子</span>
    return root&lt;&lt;1;
}
inline int rs(int root){
    <span>//右孩子</span>
    return root&lt;&lt;1|1;
}
inline void up(int root){
    <span>//相当于pushup</span>
    a[root].sum=a[ls(root)].sum+a[rs(root)].sum;
}
void build(int root,int l,int r){
    <span>//构建线段树</span>
    a[root].tag=0;int mid=(l+r)&gt;&gt;1;
    if(l==r){
        a[root].sum=data[l];
        return;
    }
    build(ls(root),l,mid);build(rs(root),mid+1,r);
    up(root);
}
inline void pd(int root,int l,int r){
    <span>//下加，pushdown</span>
    int mid=(l+r)&gt;&gt;1;
    a[ls(root)].tag+=a[root].tag;
    a[rs(root)].tag+=a[root].tag;
    a[ls(root)].sum+=a[root].tag*(mid-l+1);
    a[rs(root)].sum+=a[root].tag*(r-mid);
    a[root].tag=0;
}
void add(int root,int l,int r,int ql,int qr,ll x){
    <span>//单点添加元素</span>
    if(ql&lt;=l&&qr&gt;=r){
        a[root].tag+=x;
        a[root].sum+=(r-l+1)*x;
        return;
    }
    int mid=(l+r)&gt;&gt;1;
    pd(root,l,r);
    if(ql&lt;=mid)add(ls(root),l,mid,ql,qr,x);
    if(qr&gt;mid)add(rs(root),mid+1,r,ql,qr,x);
    up(root);
    return;
}
ll query(int root,int l,int r,int ql,int qr){
    if(ql&lt;=l&&qr&gt;=r){<span>//单点查询</span>
        return a[root].sum;
    }
    int mid=(l+r)&gt;&gt;1,res=0;
    pd(root,l,r);
    if(ql&lt;=mid)res+=query(ls(root),l,mid,ql,qr);
    if(qr&gt;mid)res+=query(rs(root),mid+1,r,ql,qr);
    return res;
}
int main()
{
    int n,m,opt,l,r,K,D,p;
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;data[i];
    }
    for(int i=n-1;i&gt;0;i--)
    {
        data[i+1]=data[i+1]-data[i];
    }
    build(1,1,n);
    while(m--)
    {
        cin&gt;&gt;opt;
        switch(opt)
        {
            case 1:{
                cin&gt;&gt;l&gt;&gt;r&gt;&gt;K&gt;&gt;D;
                add(1,1,n,l,l,K);
                if(l+1&lt;=r)add(1,1,n,l+1,r,D);
                if(r&lt;n)add(1,1,n,r+1,r+1,-(K+D*(r-l)));
                break;
            }
            case 2:{
                cin&gt;&gt;p;
                cout&lt;&lt;query(1,1,n,1,p)&lt;&lt;'\n';
                break;
            }
        }
    }
    return 0;
}
    </pre></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P3870">P3870 [TJOI2009] 开关</a>算是模板题了，不过因为我刚学线段树，所以不会做。<a href="https://www.luogu.com.cn/problem/solution/P3870">题解区</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P3372">P3372 【模板】线段树 1</a>这道题需要数组开大点，否则WA。<a href="https://www.luogu.com.cn/record/182406256">AC代码</a></div>
    <div class="t1">线段树<img src="https://upload-bbs.miyoushe.com/upload/2024/10/16/198629752/555e5110f45b475c11cb40f875bd6a7a_1581579760085853751.png" alt="线段树"></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P2278">P2278 [HNOI2003] 操作系统</a>这道题非常考验思维啊。输入数据已经按到达时间从小到大排序。首先刚开始没有东西的时候，我们加入第一个任务。其次，你们还是看题解区吧。<a href="https://www.luogu.com.cn/problem/solution/P2278">题解区</a>总之这道题跟上一道是一样的需要一个变量充当时间线。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P4053">P4053 [JSOI2007] 建筑抢修</a>我们按照时间T1排序，然后再循环中把T1加起来作为当前时间，然后把抢修时间加入优先队列，如果当前时间小于优先队列当中最小的(最紧急)抢修时间，那么我们就修，否则不修了，pop()掉，把这个东西所需时间减掉。最后代码：<a href="https://www.luogu.com.cn/problem/solution/P4053">题解区大佬思路牛啊。</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P2827">P2827 [NOIP2016 提高组] 蚯蚓</a>如果你用C++自带的priority_queue，别忘了STL的许多函数常数都是比较大的，也就是说这玩意会超时！害我改了半天。<a href="https://blog.csdn.net/I_have_a_world/article/details/119207142">CSDN的大佬的操作很神奇。</a>可以准备三个队列，第一个存放原来的蚯蚓，第二个和第三个存放切割后的蚯蚓，这三个都是单调不增的。<br><b>证明：由于最开始蚯蚓取的是最大值，则分割后的小蚯蚓存入另外两个队列后仍然最大，且后面入队的蚯蚓都比她们小，这是因为蚯蚓都在变长，相对长度不变。</b>这样一来三个队列的最大值直接进行队头比较就好了。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P2168">P2168 [NOI2015] 荷马史诗</a>代码挺简单，主要是哈夫曼树不太好看出来，而且也不好想。可能还是我刷题太少了。<a href="https://www.luogu.com.cn/record/182332052">AC代码</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1090">P1090 [NOIP2004 提高组] 合并果子 / [USACO06NOV] Fence Repair G</a>2024年S组要是来个这样的题多好啊，简直是送分啊，不要白不要。<a href="https://www.luogu.com.cn/record/182308166">AC代码</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P3378">P3378 【模板】堆</a>可以使用priority_queue&lt;int , vector&lt;int&gt; , greater&lt;int&gt; &gt;秒杀。但我们毕竟是来学算法的，所以来讲一下堆吧。最重要的是这个<ol>
        <li>
            编号为x节点的父节点是[x/2]。
        </li>
        <li>
            编号为x节点的左子节点是2x，右子节点是2x+1。
        </li>
        <li>
            对于大根堆而言，父节点的值一定大于等于子节点的值；小根堆反之。
        </li>
    </ol>修复二叉堆，直接找到要修复的节点，让她与父节点交换，直到满足第三条性质。删除堆顶元素，直接让堆顶与堆尾交换，然后修复二叉堆。</div>
    <div class="t1">二叉堆<img src="https://upload-bbs.miyoushe.com/upload/2024/10/16/198629752/0fb55586daf283dcdc56be51b1614d07_837307545986593437.png" alt="二叉堆"></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1074">P1074 [NOIP2009 提高组] 靶形数独</a>搜索题，感觉很简单，但其实我也不知道为什么错，我的代码可能没错，只不过时间复杂度是阶乘级别的。因此这道题我是抄的。<a href="https://www.luogu.com.cn/problem/solution/P1074">感谢 @学无止境 的题解</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P2324">P2324 [SCOI2005] 骑士精神</a>这道题是启发式A*搜索算法，我抄的题解。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P5507">P5507 机关</a>这道题我不会，抄的。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1379">P1379 八数码难题</a>累晕了，不想看了~我直接抄的题解，不过这道题看起来应该不难。<a href="https://www.luogu.com.cn/problem/solution/P1379">@hidden_er的题解</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1763">P1763 埃及分数</a>迭代加深搜索我不会，所以是抄的。<a href="https://www.luogu.com.cn/problem/solution/P1763">感谢 @王熙文 的题解</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1120">P1120 小木棍</a>这道题可谓是把剪枝剪到了极致！<a href="https://www.luogu.com.cn/record/182203529">我之前的答案</a><a href="https://www.luogu.com.cn/record/182205234">AC之后的答案</a>木棍需要从最大值枚举，枚举到所有木棍最大加和。如果不是最大加和的因数就continue，而且从大到小枚举......具体见题解。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1433">P1433 吃奶酪</a>搜索拿不了满分，最多拿90分，不过在赛场上已经够了。其中搜索的一个新技巧是遇到卡时情况时，可以强制退出。<pre>
cnt++;
if(cnt>=10000000)<span>//卡时，则直接退出程序。</span>
{
    printf("%.2lf",ans);
    exit(0);<span>//结束程序需要用头文件cstdlib</span>
}
    </pre></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1036">P1036 [NOIP2002 普及组] 选数</a>一道普及的题目我调了半天。最后发现是参数写错了。<code>dfs(x+1,i+1,z+a[i]);</code>这里应该是i+1而不是y+1。<a href="https://www.luogu.com.cn/record/182199160">AC代码</a>如果按照常规搜索，那么会有重复，为了避免重复，我们dfs要有3个参数<ol>
        <li>当前选了多少数</li>
        <li>考虑下一个是哪里</li>
        <li>加和是多少</li>
    </ol></div>
    <div class="t1">进阶搜索<img src="https://upload-bbs.miyoushe.com/upload/2024/10/15/198629752/aa21ff8dbbb240259aa361fe8086648c_3557376428275539776.png" alt="进阶搜索"></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P7562">P7562 [JOISC 2021 Day4] イベント巡り 2 (Event Hopping 2)</a>这道题我就是抄代码也是我抄不来的。不过题目很好理解，主要是代码很难写。<a href="https://www.luogu.com.cn/problem/solution/P7562">感谢@AquariusZhao的题解</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P6648">P6648 [CCC2019] Triangle: The Data Structure</a>看来还是我肤浅了，ST表要是考得难，就会这样难。<a href="https://www.luogu.com.cn/problem/solution/P6648">题解</a>看不懂，不过觉得应该是多维ST表，这是啥我没学过啊！<a href="https://blog.csdn.net/weixin_41162823/article/details/98471161">二维ST表</a><a href="https://www.luogu.com.cn/problem/P2216">二维ST表例题：P2216 [HAOI2007] 理想的正方形</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1816">P1816 忠诚</a>这道题是一道令人喜庆的ST表问题，而且考的是模板！我一遍就AC了（其实MLE了4个点）。<br><br>*总结：ST表不能开太大，我试了一下，这个题目数据我们rmin只需要开[m][16]即可。<br>（其实我也不知道为什么开这么小能过，因为模板上是这么写的，赛场上保险一点还是开到[m][64]吧。）<a href="https://www.luogu.com.cn/record/182134693">AC代码</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P4155">P4155 [SCOI2015] 国旗计划</a>这道题主要是倍增的一个应用，目前题解写的是啥我都没搞明白，可能是我的知识储备还不够吧。<a href="https://www.luogu.com.cn/record/182086007">AC代码</a><a href="https://www.luogu.com.cn/problem/solution/P4155">感谢@xuanfly的题解</a></div>
    <div class="t1">遇到圆环问题，我们一般的做法是改成链来做，把原数组复制一份，加到原数组后面去。<img src="https://upload-bbs.miyoushe.com/upload/2024/10/14/198629752/accf07f019be64aa9d6d1f49b068bc7f_5634778520008144210.png" alt="如图"></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P3517">P3517 [POI2011] WYK-Plot</a>派蒙抄完都似了~<img src="https://img-static.mihoyo.com/communityweb/upload/417976a3dacde790f947f8769d85d55c.png" alt="π蒙">比前一道题的代码还长！感谢大佬的题解，虽然连题目样例都没过，但结果居然AC了！很神奇。<a href="https://www.luogu.com.cn/problem/solution/P3517">@ycyaw</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1742">P1742 最小圆覆盖</a>π蒙抄完都似了~<img src="https://img-static.mihoyo.com/communityweb/upload/417976a3dacde790f947f8769d85d55c.png" alt="π蒙">不过还是要感谢这位大佬给的题解<a href="https://www.luogu.com.cn/problem/solution/P1742">@TimeTraveller
    </a><br><p>我的题解<b><a href="https://www.luogu.com.cn/record/182055836">代码</a></b></p></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P3509">P3509 [POI2010] ZAB-Frog</a>这道题我连题目都没读懂别说写了，不过抄代码的时候忘记带cstring头文件了，导致编译失败，这要在赛场估计得凉凉。<a href="https://www.luogu.com.cn/problem/solution/P3509">感谢@卷王[慢即快]的题解</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P2345">P2345 [USACO04OPEN] MooFest G</a>这道题是CDQ分治，目前还没学到，因此代码我是抄的。<a href="https://oi-wiki.org/misc/cdq-divide/">CDQ分治——OI Wiki</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1228">P1228 地毯填补问题</a>分治算法的典型，主要是太费时间了，这道题需要找好位置之间的关系来递归求解。<a href="https://www.luogu.com.cn/problem/solution/P1228"></a>题解区</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1257">P1257 平面上的最接近点对</a>令我吃惊的是，暴力居然真的能过！<a href="https://www.luogu.com.cn/record/182016281">AC代码</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P2415">P2415 集合求和</a>纯数学方法就行了，这道题原本我还想二分，结果一看题解，居然是数学推导。<a href="https://www.luogu.com.cn/problem/solution/P2415">题解区</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P7167">P7167 [eJOI2020 Day1] Fountain</a>这道题要用二分+ST表，ST表存储最大值，使用二分查找最大值。没错，二分最大值不一定非要序列有序，ST表是可以被二分的！<a href="https://www.luogu.com.cn/record/182012406">AC代码</a>查询ST表最大值
    <pre>
int query_max(int A,int B)
{<span>//ST表的查询，建议直接背会</span>
	int x=log_2[B-A+1];
	return max(rmax[A][x],rmax[B-(1&lt;&lt;x)+1][x]);
}
    </pre>构建ST表
<pre>
for(int i=2;i<=n;i++)
{
    log_2[i]=log_2[i>>1]+1;
}
for(int i=1;i<=n;i++)
{
    rmax[i][0]=d[i];
}
for(int j=1;(1&lt;&lt;j)&lt;=n;j++)
{
    for(int i=1;i&lt;=n-(1&lt;&lt;j)+1;i++)
    {
        rmax[i][j]=max(rmax[i][j-1],rmax[i+(1&lt;&lt;j-1)][j-1]);
    }
}
</pre></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P2880">P2880 [USACO07JAN] Balanced Lineup G</a>还是奶牛牧场这道题，但是ST表，ST表我刚学，还是得背板子啊。<a href="https://www.luogu.com.cn/record/181971452">AC代码</a>需要2个数组，分别存储最大值和最小值，ST表可以存储最大值和最小值，但要么只能存最大、要么只能存最小，所以要想两个都存，就必须要开2个数组。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1045">P1045 [NOIP2003 普及组] 麦森数</a>思路挺简单，主要是高精度不会的话得需要复习一下了。<a href="https://www.luogu.com.cn/record/181931701">AC代码</a>其中为了输出位数，指数化成了对数log表示。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1226">P1226 【模板】快速幂</a>经典算法快速幂<br><a href="https://www.luogu.com.cn/record/181914237">递归写法</a><a href="https://www.luogu.com.cn/record/181919030">非递归写法</a>主要利用了二分法和倍增法。<br>递归法是将指数二分。<br>非递归法是将底数倍增。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1966">P1966 [NOIP2013 提高组] 火柴排队</a>这可能是我第一次理解归并排序<a href="https://www.luogu.com.cn/record/181909327">AC代码</a>如果代码看不懂就去看题解区大佬的代码，毕竟这个没有注释。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1908">P1908 逆序对</a>归并排序求逆序对<a href="https://www.luogu.com.cn/record/181836523">AC代码</a><img src="https://upload-bbs.miyoushe.com/upload/2024/10/13/198629752/220c2cdbf5a1a991f296bebb20abd02b_8699420978560025386.png" alt="解释">代码解释如图。详细见Database中的深入浅出。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1177">P1177 【模板】排序</a>
    <pre>
#include &lt;iostream&gt;
using namespace std;
int a[100010],b[100001],n;
void mergersort(int l,int r){
    if(l==r)return;<span>//如果撞到了一起则返回 </span>
    int mid=(l+r)/2;
    mergersort(l,mid);mergersort(mid+1,r);<span>//分治 </span>
    for(int i=l,j=l,k=mid+1;i&lt;=r;i++)<span>//排序</span> 
        if(j==mid+1) b[i]=a[k++];
        else if(k==r+1) b[i]=a[j++];
        else b[i]=a[j]&lt;a[k]?a[j++]:a[k++];
    for(int i=l;i&lt;=r;i++)a[i]=b[i];<span>//覆盖</span> 
}
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];
    mergersort(1,n);
    for(int i=1;i&lt;=n;i++)cout&lt;&lt;a[i]&lt;&lt;" ";
    return 0;
}
    </pre>这是经过压行的归并排序，十分简洁，了解主要分治思想最关键。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P11184?contestId=200686">P11184 带余除法</a>CSP-J模拟赛，这道题需要用数学方法来做，当时提交时候用的暴力枚举除数，结果1个MLE、3个AC，其他TLE。正解应该是这样的：<a href="https://www.luogu.com.cn/record/181818460">AC代码</a>我们用商的边界相减就能得到余数的种类。比如10/5=2、10/3=3，那么我们就用5-3等于2，那么余数一共有2种。</div>
    <div class="t1">每场考试都要写read，否则就算答案对了，也得TLE</div>
    <div class="t1">归并排序算法当中有一步叫做合并，具体实现步骤看这：<img src="https://upload-bbs.miyoushe.com/upload/2024/10/13/198629752/7bbd924ea0156296fd8c66c79982ccbd_6907507698226923087.png" alt="合并">这里用到了3个指针+3个数组，c是结果数组，a和b是被合并的数组。最终结果c数组呈单调增。</div>
    <div class="t1">分治与倍增<img src="https://upload-bbs.miyoushe.com/upload/2024/10/13/198629752/6a87b1b1252ffef69e94285a33b20729_9207826495284927265.png" alt="分治与倍增"></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P5937">P5937 [CEOI1999] Parity Game</a>这道题是并查集、找关系，如果冲突，那么就输出答案，否则继续判断。通过将数据离散化来达到降低复杂度的效果。<a href="https://www.luogu.com.cn/record/181785320">题解代码</a>题解区的代码讲的太难懂，我用我的理解写到了注释上面。总的意思来说，就是给每个区间端点设立两种状态，如果不冲突，那么就合并，否则就输出冲突的位置结束程序。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P4375">P4375 [USACO18OPEN] Out of Sorts G</a>这道题如果只改写代码，那么只能拿到50分。<a href="https://www.luogu.com.cn/problem/solution/P4375">@Meepo的题解</a>代码写的很简单，大意就是找到需要往后面交换的数字的个数。<a href="https://www.luogu.com.cn/record/181623321">我的题解(注释非常清晰)</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1904">P1904 天际线</a>这道题暴力就能AC，但是我们为了练习离散化，还是用离散化比较好。<br>
        <ol>
            <li>明确离散对象：左右区间l和r。</li>
            <li>二分对象：高度</li>
        </ol><a href="https://www.luogu.com.cn/record/181594387">题解代码</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P3029">P3029 [USACO11NOV] Cow Lineup S</a>这道题使用单调队列和离散化求解，离散化就用map就能实现了。<a href="https://www.luogu.com.cn/record/181574982">题解代码</a>我觉得这是最容易理解的代码了。<a href="https://upload-bbs.miyoushe.com/upload/2024/10/12/198629752/051492f6386b9f247fa787df63c07633_8572214169970926441.png">我与AI的聊天记录</a>这是AI的回答，非常容易理解</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P4552">P4552 [Poetize6] IncDec Sequence</a>这道题已经是一道数学题了。<br>不要模拟，模拟不出来，看看题目颜色，绿色！这道题需要先用数学思想推一下，最后总结出公式再写代码，代码很短。<a href="https://www.luogu.com.cn/record/181563937">我的AC代码</a>这告诉我们一个道理，有些题目你最好先试试能不能总结出公式，如果不能，那就模拟。<a href="https://www.luogu.com.cn/problem/solution/P4552">别人的题解</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P2882">P2882 [USACO07MAR] Face The Right Way G</a>这道题需要利用二进制的异或运算。差分数组为二进制异或差分。这是一道很典的题目。这道题不好理解的地方在于题目中说每次可以将K头牛转向，但没有说这个K是不变的，因此刚开始我以为这个K会变，结果看了题解才知道原来K是一个定值。这道题翻译过来就是给定一个01串、一个K，每次对某个长度为K的区间进行翻转，使得所有0变成1。求翻转的最小次数还有最小次数对应的K。<br><a href="https://www.luogu.com.cn/record/181558002">题解</a>其中的now相当于对区间进行前缀异或了(说白了就是对区间取反)，这样的做法时间复杂度可以降至O(n²)。题目范围5000，O(n²)的复杂度下，5000*5000=25000000&lt;400000000可以在一秒内通过本题。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/record/181548562">P1083 [NOIP2012 提高组] 借教室</a>这道题有一个坑点，输入的数据是有序的，也就是可以使用二分答案！呜呜呜~<br>二分+前缀和+差分配合使用。<br>别忘了memset初始化tmp数组。<a href="https://www.luogu.com.cn/record/181548562">题解</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P3406">P3406 海底高铁</a>这道题是前缀和+差分，首先进行差分，求解一个区间经过了多少次，但这道题不同的是，他告诉你了进过了第几段区间，而不是从几到几，因此差分不需要再尾部+1的位置-1，而是要直接在尾部-1。前缀和+贪心求解最终答案即可。<br>*这道题可以加深自己对前缀和与差分的认识。<br><a href="https://www.luogu.com.cn/record/181468218">题解</a><img src="https://upload-bbs.miyoushe.com/upload/2024/10/11/198629752/3b735a0db14f78be46234d68ed2be073_1895195961999785588.png" alt="前缀和与差分">如图，其中的t就是差分后累加的每个阶段的结果。(还是那句话，这个差分的是段，而不是点，所以直接尾部-1，而不是尾部+1处-1。)。每个阶段的t代表了这个区间经过了多少遍，然后用这个t乘以我的花费，对于IC卡，你可能也注意到了，每次i只经过一次，因此刚好利用程序顺序结构处理了IC卡的问题。<p>如果还不理解可以去题解那边去看看，记得亲自用手推一遍dalao的代码。</p></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P3017">P3017 [USACO11MAR] Brownie Slicing G</a>不会...题解没看懂。<a href="https://www.luogu.com.cn/problem/solution/P3017">题解</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P2004">P2004 领地选择</a>这道题挺简单的，但我提交了几遍才AC，因为这道题说了领地大小了，因此我们只需要枚举右上角，那么左下角就根据领地边长C算出来了，时间复杂度O(n²)。<br>易错点：遍历循环边界忘记加一，计算出的右下角忘记减一。出错的位置我在↓题解标出来了。<a href="https://www.luogu.com.cn/record/181395934">题解</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1884">P1884 [USACO12FEB] Overplanting S</a>这道题是典型的二维离散化。要注意题目中要求是笛卡尔坐标，也就是说输入数据当中的y轴一定要颠倒过来，否则输出答案就是0，我当时还调试了好一会才发现错误。数组大小需要大一点。<a href="https://www.luogu.com.cn/record/181389465">AC代码</a>*和一维离散化很像~</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1955">P1955 [NOI2015] 程序自动分析</a>离散化端点x和y，然后lower_bound将原来的x和y转化成下标，之后根据a[i].z是否是相等，来判断是否要在x和y之间连边。连完边之后我们遍历整个a[]数组，判断a[i].z是否不相等，如果不相等，那么判断x和y有没有连边，如果连了边，那么说明与不相等相矛盾，这时直接输出NO，然后break。否则输出YES。<br><br>致错原因：把return 0写到了while(t--)里面，导致多组数据只能读入一组。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1496">P1496 火烧赤壁</a>这道题足足硬控了我2小时。就为了一个lower_bound问东问西。结果用手一模拟啥问题都没了。这个故事告诉我们，不懂的代码可以模拟来理解。<a href="https://www.luogu.com.cn/record/181275467">题解</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P3397">P3397 地毯</a>这道题的数据范围没问题，当时数组开的刚刚好，结果CE了，后来一查发现竟然是数组里面有一项是<code>b[x2+1][y2+1]+=1;</code>说明数组需要多开一点，要不然这个+1操作会越界。<br><p>关于二维差分我找到了一个帖子：<a href="https://zhuanlan.zhihu.com/p/439268614">二维差分</a><br>二维差分核心就这两条<img src="https://upload-bbs.miyoushe.com/upload/2024/10/10/198629752/cbe6a648473cfcabf33e2ba1b4195110_7117397826006467220.png" alt="差分"><img src="https://upload-bbs.miyoushe.com/upload/2024/10/10/198629752/92e38cf14e320067068a165dfc6dd7b3_9089620150170481597.png" alt="差分">不要以为和二维前缀和一样，要注意还是有点不一样的地方：<b>第二张图的最后一个算式</b></p><a href="https://www.luogu.com.cn/record/181266744">题解</a>*另外，差分需要满足叠加，如果不满足那么就不能用差分解题喽~</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P2367">P2367 语文成绩</a>差分的经典题型，手推一遍理解差分含义。记住差分公式。<ol>
        <li>
            构建差分数组b[i]=a[i]-a[i-1]；
        </li>
        <li>
            对区间修改时直接对差分数组修改，若加x，则在首端加x，末端+1的位置减x。
        </li>
        <li>
            对差分数组求前缀和之后的数组就是修改后的原数组。
        </li>
    </ol><br>*面对大数据大范围大范围修改时，差分更有优势，否则你会TLE。<a href="https://www.luogu.com.cn/record/181254236">题解</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1314">P1314 [NOIP2011 提高组] 聪明的质监员</a>这道题目前我还不会哦~</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1719">P1719 最大加权矩形</a>区区普及，还能难倒我？这道题跟以前哪道题很像？</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P8218">P8218 【深进1.例1】求区间和</a><p>致错原因：☝️🤓诶，数组开小了，如此低级的错误我还能犯，呜呜呜~，一定要看好题目区间啊！！！有时候区间开小了都不给你CE，给你个WA让你去猜吧。</p></div>
    <div class="t1">前缀和、查分与离散化<img src="https://upload-bbs.miyoushe.com/upload/2024/10/10/198629752/02af59cc5778c715efddc10c4a043e46_5468453292179555448.png" alt="第二章"></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1725">P1725 琪露诺</a>这道题用动态规划+单调队列优化。<a href="https://www.luogu.com.cn/record/181197716">题解</a>如果仅仅用动态规划只能拿80分，剩下的就TLE了。<a href="https://www.luogu.com.cn/record/181189437">80分的题解</a></div>
    <div class="t1">注意函数返回值，如果该返回的没有返回，结果会TLE。而且在本机上跑的是正确的，在评测机上就会TLE。因此这个错误很重要。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1714">P1714 切蛋糕</a>这道题需要前缀和+单调序列，当时我以为不能是单调队列，于是我的代码就写成了这样：<a href="https://www.luogu.com.cn/record/181183317">代码</a>后来看了题解才知道，必须得是单调队列，而且还得要前缀和。于是后来改成了这样<a href="https://www.luogu.com.cn/record/181185448">代码</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1886">P1886 滑动窗口 /【模板】单调队列</a><P>滑动窗口这道题需要注意，这道题中有一个位置容易错。请看 <a href="https://www.luogu.com.cn/record/181171733">代码</a> ，这里的
        <pre>
while((!mindq.empty())&&i-k>=mindq.front())
{
    mindq.pop_front();
}
while((!maxdq.empty())&&i-k>=maxdq.front())
{
    maxdq.pop_front();
}
    </pre>其中<code>i-k>=mindq.front()</code>可以写成<code>mindq.back()-mindq.front()>=k-1</code>但是不能写成<code>mindq.back()-mindq.front()>=k</code>因为当我们的区间的序列长度已经等于k的时候，我们就应该把<code>front()</code>pop掉，因为后面还要push一个i，这就意味着如果我们的序列长度等于k，那么后面再加入i的时候长度就会大于k，因此代码才这么写。<br>&nbsp;&nbsp;&nbsp;&nbsp;*当然，你要是把push语句放前面的话那就没事了。</P></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P3467">P3467 [POI2008] PLA-Postering</a>这道题需要有反向思维，既然海报数一个一个加不好办，那么我们就反向减。具体思路见题解。<a href="https://www.luogu.com.cn/problem/solution/P3467">题解</a>代码很简单，但这个思路绝了！<b>选自题解的一句核心句：因为题目要求海报不可超出建筑物链，那么我们即可用单调栈维护：初始海报数为建筑物数，入栈建筑物链的高度序列，当栈顶大于即将入栈元素时弹栈，若最后弹栈元素与即将入栈元素等高，需要的海报数-1；</b></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1578">P1578 奶牛浴场</a><p>小心！这道题和<a href="https://www.luogu.com.cn/problem/P4147">P4147 玉蟾宫</a>不一样。这道题的数据范围不适用悬线法，否则会MLE！经过我查找题解，发现某年的国家队wzk大佬的论文《浅谈用极大化思想解决最大子矩形问题》，一共有两种：1.悬线法 2.通过障碍点找子矩形。我们也只能用第二种了。<a href="https://www.luogu.com.cn/problem/solution/P1578">题解</a>太绝喵了！我正在研究中......</p><br><br>这道题抄都能抄错，l和1长得太像啦！很容易把l抄成1。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P4147">P4147 玉蟾宫</a><p>这是一道经典的求区间边界的题目，可以用悬线法求解，悬线怎么理解？当时我想了一天，后来遇到<a href="https://www.luogu.com.cn/problem/P1578">奶牛浴场</a>这道题我才醒悟。你可以理解为PS的裁剪工具，如图：<img src="https://upload-bbs.miyoushe.com/upload/2024/10/09/198629752/7b03d2e7bb2ca7c0f5bc82d4033c2195_2942403461030409694.png" alt="PS"></p>悬线就是裁剪边缘的框框，框住了哪里，哪里就要被保留，其余的就被裁剪掉了。这两道题悬线的概念就是这么理解的。<br><br>我们设置一个h数组记录从第(i,j)这一点向上能到达的最大长度，碰到障碍物或者边界就break。l数组记录左边最远到达的长度，r数组记录右边。*此时你会问了，为什么没有down数组记录下面到达的最远位置？A:因为不需要，那样做太多余了，我们的for循环是从上往下遍历的，而且答案也是从上往下遍历的，我们迟早要遍历到下边，因此down数组没有任何作用。最后的最大面积就是答案，面积=底乘高，底=(l+r-1),为什么要减一，因为l和r在一个点重合了，高=h，那么面积=h*(l+r-1)，之后取最大值就是最终结果。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P7910">P7910 [CSP-J 2021] 插入排序</a>还是需要插入排序，我觉得最简单的方法就是按照题目要求每次进行插入排序就好了，只不过我们无需对全部区间排序，只需要判断：如果修改后的值改小了，那么对她前面的区间排序，否则对她后面的区间排序。<a href="https://www.luogu.com.cn/problem/solution/P7910">感谢@Inaba_Meguru的题解</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P3143">P3143 [USACO16OPEN] Diamond Collector S</a><p>这是一道好题啊！我看到一篇题解十分牛逼：<a href="https://www.luogu.com.cn/problem/solution/P3143">@a1455520571</a>感谢这位大佬带来的题解。思路很绝妙。就是类似DP+双指针。i表示左侧第一个架子上最多能放多少钻石，i~r的差就是右侧能放的最多的钻石数量。用ma记录左侧能放的最大值，然后ans更新成ma+(r-i)<b style="color: rgba(0, 0, 0, 0.371);"> (式子展开就是ma+r-i) </b>的最大值。</p><br><a href="https://www.luogu.com.cn/record/181024731">我的题解</a></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P4653">P4653 [CEOI2017] Sure Bet</a>要用双指针+前缀和，当然，就算不用前缀和也没事，就是有点麻烦，这道题有点像贪心。<a href="https://www.luogu.com.cn/record/181010663">题解</a></div>
    <div class="t1">常见的优化技巧<img src="https://upload-bbs.miyoushe.com/upload/2024/10/08/198629752/b7726f0ceadc1d948614c82f2ebd11e0_6626171470311379944.png" alt="优化技巧"></div>
    <div class="t1">局部变量一定要初始化，轻则TLE，重则RE，其间就是WA。</div>
    <div class="t1">cout输出字符串占时间，而且占的不少，容易超时。建议用printf输出字符串！！！(后来经过调查，原来是endl的问题，endl占的时间比较多，以后换行就用'\n'吧，尽量别用endl了，endl不仅仅是换行，endl还要清除缓存区，所以慢得多)</div>
    <div class="t1">千万不要忘记检查代码输出格式，比如把“YES”写成“Yes”结果直接0分，幸好不是在赛场上，否则直接见祖宗！<br><br>图论当中要注意在删除点的时候，推荐使用二维矩阵，因为二维表会出问题。<br><br><code>memset(g[i],0,sizeof(g[i]))</code>可以对一个数组的某一个维度单独初始化，这个操作我才知道！<br><br>如何输入当中给你的是无法用cin和scanf区分的数据，那么就把这串数据当成字符串来处理输入，之后转成自己想要的数据。</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1345">1345：【例4-6】香甜的黄油</a>这道题我也是不会，要求用SPFA解决，反正不会，目前走一步看一步吧。<a href="https://blog.csdn.net/qq_42914633/article/details/98882991">题解</a></div>
    <div class="t1">群友提供的Dijkstra算法的通解：<img src="https://upload-bbs.miyoushe.com/upload/2024/10/06/198629752/c6aebb59e6f1a42ec6bb8ba938758d66_7600648732841161930.jpg" alt="Dijkstra">目前我确实看不懂，后面再说吧。</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1344">1344：【例4-4】最小花费</a>这道题属于是板子题了，我得背一下板子，否则后面真的学不下去。(因为前面啥板子都没背过，这个Dijkstra算法难写，没办法那就背吧。)<a href="https://blog.csdn.net/weixin_61017400/article/details/124343916">Dijkstra算法模板</a><p><a href="https://www.luogu.com.cn/training/444587#problems">Dijkstra算法刷题题单</a>我觉得这块还是得练练，要不然后面真不知道要怎么进行下去。</p></div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1343">1343：【例4-2】牛的旅行</a><p>这道题看了<a href="https://www.cnblogs.com/jzxnl/p/11397149.html">题解</a>，觉得很简单，但实际做起来发现结果居然不对，始终不知道哪错了。</p></div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1343">1343：【例4-2】牛的旅行</a>这道题还是求最短路，只不过是求整个牧场最短路当中最大的那个。</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1342">1342：【例4-1】最短路径问题</a><p>这道题错的稀里糊涂，我也不知道为啥。第一次写的时候输出了个0.00，其实不是0，而是被省略了小数，这很显然是一个异常的答案。后来找到了原因，原来是memset初始化double类型的数组时不能用0x3f，具体原因见<a href="https://blog.csdn.net/PoPoQQQ/article/details/38926889">博文</a>，而应该赋值成0x7f，否则最终结果连0.1都不到。最后这道题我也是AC了。</p><br><p><a href="https://blog.csdn.net/lq1990717/article/details/123321240#:~:text=%E8%AE%A2%E9%98%85%E4%B8%93%E6%A0%8F.%20%E3%80%90%E9%A2%98%E7%9B%AE%E9%93%BE">Floyed算法求最短路</a>可以说是最基础的了。</p></div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1375">1375：骑马修栅栏(fence)</a>记录欧拉路要在回溯阶段存储，否则会出现错误。另外，起始点不一定是1。题目中说“输出第一个数较小的”意思就是开始的节点度数最小，那么我们的最终代码就出来了：<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
int f,n;
int arr[2001],top=1;
int g[2001][2001],du[2001];
void dfs(int xi)
{
    for(int i=1;i&lt;=n;i++)
    {
        if(g[xi][i])
        {
            g[xi][i]--;g[i][xi]--; 
            dfs(i);
        }
    }
    arr[top++]=xi;<span>//回溯阶段存储路径</span>
}
int main()
{
    cin&gt;&gt;f;
    int start=0x3f3f3f3f;<span>//就像我说的，起始节点不一定是1，所以要初始时赋值为一个很大的数，后面找最小的节点编号。</span> 
    for(int i=1,x,y;i&lt;=f;i++)
    {
        cin&gt;&gt;x&gt;&gt;y;
        g[x][y]++;g[y][x]++;
        du[x]++;du[y]++;
        n=x&gt;n?x:n;<span>//找到最大的点的编号。</span>
        n=y&gt;n?y:n;
        start=start&lt;x?start:x;<span>//找到最小的点</span>
        start=start&lt;y?start:y;
    }
    for(int i=1;i&lt;=n;i++)
    {
        if(du[i]%2==1)
        {
            start=i;
            break;
        }
    }
    dfs(start);
    for(int i=top-1;i&gt;=1;i--)
    {<span>//到序输出</span>
        cout&lt;&lt;arr[i]&lt;&lt;endl;
    }
    return 0;
}
    </pre>说白了还是最基础的邻接矩阵存图，没什么难的，但要是不注意题目说的是啥，那就容易爆0。(当时我还在想500进制表示法是啥来着，但现在看来啥用也没有。)</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1374">1374：铲雪车(snow)</a><p>看到这道题我第一时间想到的是建立一个图。结果当我看到<a href="https://blog.csdn.net/lq1990717/article/details/129891715#:~:text=%E9%93%B2%E9%9B%AA%E8%BD%A6%E5%8F%AF%E4%BB%A5%E5%9C%A8%E4%BB%BB%E6%84%8F%E4%BA%A4%E5%8F%89">题解</a>的时候立刻小脑萎缩。</p>致错原因：做题前没有充分分析题目。有些题目要用数学方法证明，如果能证明出来，那么题目会非常简单，但如果证明不出来，那么就只能模拟。但通常像这种题目，模拟难度往往很高。*我也不会模拟。</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1341">1341：【例题】一笔画问题</a>致错原因：这是无向图，有度，没有入度和出度之分，直接用度就好了。使用邻接矩阵解决。<p><a href="https://blog.csdn.net/Wchenchen0/article/details/81283700">题解</a>仅供参考。</p>原本深入浅出的那本书上讲的挺好的，到这里怎么我的编程能力还退化了呢？</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1372">1372：小明的账单</a>这道题挺简单，但要注意的是要对每个账单设置一个id，已经弹出的账单保证不再弹出。<a href="https://blog.csdn.net/lq1990717/article/details/128502439#:~:text=ybt%201372%EF%BC%9A%E5%B0%8F">题解</a>使用优先队列priority_queue可以快速完成。不建议使用多重集合multiset。</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1371">1371：看病</a>这道题看似很简单，其实坑点一大堆。其中一个点还超时。<a href="https://blog.csdn.net/lq1990717/article/details/128490063#:~:text=1371%EF%BC%9A%E7%9C%8B%E7%97%85%20%E6%97%B6%E9%97%B4">题解</a></div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1370">1370：最小函数值(minval)</a><p>这道题不难，主要是刚开始读题可能会理解错，这道题的意思是对函数值排序，不是叫你对解出的x值排序。这是<a href="https://www.cnblogs.com/tflsnoi/p/14150443.html#:~:text=1370%EF%BC%9A%E6%9C%80%E5%B0%8F%E5%87%BD%E6%95%B0%E5%80%BC">题解</a></p></div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1373">1373：鱼塘钓鱼(fishing)</a><p>这道题挺难的，因为我不会。但是<a href="https://blog.csdn.net/Wchenchen0/article/details/81259412">题解</a>很好看。</p></div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1369">1369：合并果子(fruit)</a>哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈，我对了！我对了！<br>我终于对了一道题了！！！哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈......<br><b>需要注意的是，要分成函数写，否测会WA，不知道为啥，写成顺序结构会WA，但封装成函数就AC了(挠头~)。</b><p>*也可以直接用<code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt;</code>来解出答案。(也不知道比赛时叫不叫用)</p><pre>
#include &lt;iostream&gt;
using namespace std;
#define LL long long
LL n,a[30001],ans;
void swap(LL &a,LL &b)
{
    LL tmp=a;a=b;b=tmp;
}
void _init()
{
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;a[i];
        int p=i;
        while(p!=1)
        {
            if(a[p/2]&gt;a[p])
            {
                swap(a[p/2],a[p]);
            }
            else break;
            p=p/2;
        }
    }
}
void put(int x)
{
    a[++n]=x;int p=n;
    while(p!=1)
    {
        if(a[p/2]&gt;a[p])
        {
            swap(a[p/2],a[p]);
        }
        else break;
        p=p/2;
    }
}
int get()
{
    LL res=a[1];
    a[1]=a[n--];
    for(int i=1;i&lt;=n;i++)
    {
        int p=i;
        while(p!=1)
        {
            if(a[p/2]&gt;a[p])
            {
                swap(a[p/2],a[p]);
            }
            else break;
            p=p/2;
        }
    }
    return res;
}
int main()
{
    cin&gt;&gt;n;
    _init();
    while(1)
    {
        if(n==1)break;
        LL a=get();
        LL b=get();
        put(a+b);
        ans+=(a+b);
    }
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}
    </pre></div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1368">1368：对称二叉树(tree_c)</a>二叉树的题目好难啊，这道题还是不会。<a href="https://blog.csdn.net/lq1990717/article/details/127680193">题解</a></div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1367">1367：查找二叉树(tree_a)</a>致错原因：题目描述的问题，与我无瓜~，™也没说1号必须是根节点呀？<a href="https://blog.csdn.net/qq_39053800/article/details/108318606">题解</a>如此简单的一道题，我又双叒做错了。</div> 
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1365">1365：FBI树(fbi)</a><p>这道题不会，我看的<a href="https://www.cnblogs.com/tflsnoi/p/14110703.html#:~:text=%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E7%AC%A8%E5%8A%9E%E6%B3%95%E5%BB%BA%E6%A3%B5%E6%A0%91">题解</a></p></div>
    <div class="t1">使用cin、cout、string......时，一定要引入命名空间<code>using namespace std;</code></div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1363">1363：小球(drop)</a>这道题可以暴力遍历。<a href="https://www.cnblogs.com/sxrekord/p/small_ball.html#:~:text=1363%EF%BC%9A%E5%B0%8F%E7%90%83%20(d">题解</a>*然而我还傻傻模拟了一棵树。</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1364">1364：二叉树遍历(flist)</a>这么简单的题也能错？我真的服了。致错原因：没有加if判断。<a href="https://www.cnblogs.com/sxrekord/p/binary_tree_traversal.html">题解</a>就只这两个if判断<pre>
if(p&gt;l)print(l,p-1);
if(p&lt;r)print(p+1,r);</pre>*函数名和题解的不一样。</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/pic/1340.gif">1340：【例3-5】扩展二叉树</a>写的时候发现全错，但答案是对的，后来发现自己忘记把新创建的节点赋值为NULL，然后再判断要不要创建新节点。<br>这是正确写法，重点标红：<pre>void crt(tree &p)
{
    char x=getchar();
    <b style="color: red;">p=NULL;</b><span>//先赋值为NULL。</span>
    <b style="color: red;">if(x=='.')return;</b><span>//再看看要不要创建新的。</span>
    <b style="color: red;">p=new node;</b><span>//如果要，那么就创建新的。</span>
    p->l=NULL;p->r=NULL;
    p->data=x;
    crt(p->l);
    crt(p->r);
}</pre>如果反过来写虽然输出是对的，但判题机给我判错，我想可能是因为我没有把p赋值为NULL，导致输出时某些不可见字符被输出了出来导致错误。</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1339">1339：【例3-4】求后序遍历</a>第一次就想写出来不就成了天才了？(自我安慰)<a href="https://blog.csdn.net/qq_39053800/article/details/108182882">题解</a>这是模板，后面学二叉树可能会用它来构造二叉树，需要背下来。</div>
    <div class="t1">创建链表。<pre>struct node
{
    int data;<span>//数据。</span> 
    node *next,*pre;<span>//前指针、后指针。 </span>
};
node *head,*p,*r;<span>//创建头、中、尾指针。</span>  </pre></div>
<div class="t1">
链表新增以及移动的几个步骤：<br>
1.申请新节点。<br>
2.赋值数据。<br>
3.当前节点的下一个置为NULL，前一个节点的下一个置为自己。<br>
4.指针后移，即前一个变成自己。<br>
<pre>
p=new node;
p->data=x;
p->next=NULL;
r->next=p;
r=p;
</pre>在此之前还需要<code>head=new node;<br>r=head;</code>最后指针p归位<code>p=head->next;</code>
</div>
    <div class="t1">二叉树的存储结构，可以用数组，也可以用指针。两种方式都差不多，总之就是模拟。<br>这个是指针方式：<code>
typedef struct node;<br>
typedef node *tree;<br>
struct node<br>
{<br>
	&nbsp;&nbsp;*tree lchild,rchild;<br>
	&nbsp;&nbsp;int data;<br>
};<br>
tree bt;<br>
    </code></div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1306">1306：最长公共子上升序列</a>据说这道题是一道模板题。总之我不会，就算是看了题解还是不会。<p><a href="https://blog.csdn.net/lq1990717/article/details/124222748">君义_noip</a>的题解第一个还写错了，也没看懂在写啥。</p><p><a href="https://www.cnblogs.com/-Ackerman/p/11232960.html#:~:text=%E5%A6%82%E6%9E%9C%E6%98%AF%E6%B1%82%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E4%B8%8B%E9%99%8D">-Ackermanの博客</a>的题解还算比较清晰，但没时间看了，暂时就过吧。</p></div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1305">1305：Maximum sum</a>这是一个动态规划之最大连续子段和问题。没学过，不会。<p><a href="https://blog.csdn.net/lq1990717/article/details/124162300#:~:text=%E8%A7%A3%E6%B3%951%EF%BC%9A%20%E8%A6%81%E5%9C%A8%E6%95%B4%E4%B8%AA%E5%BA%8F">题解</a>看的似懂非懂。</p></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1107">P1107 [BJWC2008] 雷涛的小猫</a>始终不知道自己哪错了，拿了80分，稀里糊涂看了题解。</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1304">1304：数的划分</a>信心都快要错没了。致错原因：没找对状态转移方程。<a href="https://developer.aliyun.com/article/1285630#:~:text=%E7%AE%80%E4%BB%8B%EF%BC%9A%201304%EF%BC%9A%E6%95%B0%E7%9A%84%E5%88%92%E5%88%86%20%E6%97%B6%E9%97%B4%E9%99%90%E5%88%B6%3A%201000%20ms%20%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6%3A%2065536%20KB,%E5%B0%86%E6%95%B4%E6%95%B0n%E5%88%86%E6%88%90k%E4%BB%BD%EF%BC%8C%E4%B8%94%E6%AF%8F%E4%BB%BD%E4%B8%8D%E8%83%BD%E4%B8%BA%E7%A9%BA%EF%BC%8C%E4%BB%BB%E6%84%8F%E4%B8%A4%E4%BB%BD%E4%B8%8D%E8%83%BD%E7%9B%B8%E5%90%8C%20%28%E4%B8%8D%E8%80%83%E8%99%91%E9%A1%BA%E5%BA%8F%29%E3%80%82%20%E4%BE%8B%E5%A6%82%EF%BC%9An%3D7%EF%BC%8Ck%3D3%EF%BC%8C%E4%B8%8B%E9%9D%A2%E4%B8%89%E7%A7%8D%E5%88%86%E6%B3%95%E8%A2%AB%E8%AE%A4%E4%B8%BA%E6%98%AF%E7%9B%B8%E5%90%8C%E7%9A%84%E3%80%82%201%EF%BC%8C1%EF%BC%8C5%EF%BC%9B%201%EF%BC%8C5%EF%BC%8C1%EF%BC%9B%205%EF%BC%8C1%EF%BC%8C1%EF%BC%9B%20%E9%97%AE%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E5%88%86%E6%B3%95%E3%80%82%20%E8%BE%93%E5%87%BA%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%EF%BC%8C%E5%8D%B3%E4%B8%8D%E5%90%8C%E7%9A%84%E5%88%86%E6%B3%95%E3%80%82">阿里云题解</a>这个题解还是蛮清晰的。</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1303">1303：鸣人的影分身</a>这道题不是很清楚，但为了时间，还是草草过了，后面遇到类似的题回来看看吧。<a href="https://blog.csdn.net/lq1990717/article/details/125285359#:~:text=%E6%88%91%E4%BB%AC%E7%9A%84%E4%B8%BB%E8%A7%92%E6%BC%A9%E6%B6%A1%E9%B8%A3%E4%BA%BA%E6%89%80">题解</a>题解写的也是一如既往的简单啊。为什么我就是想不出来呢?</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1302">1302：股票买卖</a>致错原因：数组忘记改名了，导致同一个数组用了2遍。<a href="https://blog.csdn.net/lq1990717/article/details/125284609#:~:text=%E8%AE%A2%E9%98%85%E4%B8%93%E6%A0%8F.%20%E3%80%90%E9%A2%98%E7%9B%AE%E9%93%BE">题解</a>我写的是解法一的优化版，下次忘了就回来看看。</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1301">1301：大盗阿福</a>常规做法会超时，必须优化。<a href="https://blog.csdn.net/weq2011/article/details/127170491#:~:text=%E9%98%BF%E7%A6%8F%E6%98%AF%E4%B8%80%E5%90%8D%E7%BB%8F%E9%AA%8C%E4%B8%B0%E5%AF%8C%E7%9A%84">题解</a>这个作者写的很全，有2种优化，1.一维数组+压缩循环。2.滚动数组+压缩循环。</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1300">1300：鸡蛋的硬度</a>很难想。<a href="https://blog.csdn.net/lq1990717/article/details/125259551">题解</a></div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1299">1299：糖果</a>致错原因：还是不会找状态转移方程。dp[i][j]表示取前i个数的余数为j时的最大值。<a href="https://blog.csdn.net/qq_40802813/article/details/123556631#:~:text=1299%EF%BC%9A%E7%B3%96%E6%9E%9C%20%E6%97%B6%E9%97%B4">题解</a></div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1297">1297：公共子序列</a>这道题和最长公共子序列那道题很像，但就是有一点点不一样，不知道为什么，竟然这都能AC？<pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
using namespace std;
string a,b;
int dp[501][501];
int f(string a,string b)
{
    memset(dp,0,sizeof(0));
    a=" "+a;
    b=" "+b;
    for(int i=1;i&lt;a.length();i++)
    {
        for(int j=1;j&lt;b.length();j++)
        {
            if(a[i]==b[j])
            {
                <span>//增加</span>
                dp[i][j]=dp[i-1][j-1]+1;
            }
            else
            {
                <span>//继承</span>
                dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
            }
        }
    }
    return dp[a.length()-1][b.length()-1];
}
int main()
{
    while(cin&gt;&gt;a&gt;&gt;b)
    {
        cout&lt;&lt;f(a,b)&lt;&lt;endl;
    }
    return 0;
}
    </pre>容易忽视的问题：当你在字符串前面加上空格时，字符串长度也会增加，因此ij不能循环到s.length()了，输出也不能输出到s.length()。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1434">P1434 [SHOI2002] 滑雪</a>这道题是动态规划+记忆化搜索。
    <pre>
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
using namespace std;
int r,c,a[201][201],maxn,dp[200][200];
int dir[4][2]={{1,0},{-1,0},{0,1},{0,-1}};
int dfs(int x,int y)
{
    <span>//如果来过，那么直接返回当前点出发的长度。就不需要再走一遍了。</span>
    if(dp[x][y])return dp[x][y];
    <span>//如果没来过，那么算上这个点，从这个点开始进行搜索。</span>
    dp[x][y]=1;
    for(int i=0;i&lt;4;i++)
    {
        int ux=x+dir[i][0],uy=y+dir[i][1];
        if(ux&gt;=1&&ux&lt;=r&&uy&gt;=1&&uy&lt;=c&&a[ux][uy]&lt;a[x][y])
        {
            dfs(ux,uy);
            dp[x][y]=max(dp[x][y],dp[ux][uy]+1);
        }
    }
    return dp[x][y];
}
int main()
{
    cin&gt;&gt;r&gt;&gt;c;
    for(int i=1;i&lt;=r;i++)
    {
        for(int j=1;j&lt;=c;j++)
        {
            cin&gt;&gt;a[i][j];
        }
    }
    for(int i=1;i&lt;=r;i++)
    {
        for(int j=1;j&lt;=c;j++)
        {
            maxn=max(maxn,dfs(i,j));
        }
    }
    cout&lt;&lt;maxn&lt;&lt;endl;
    return 0;
}
</pre>如果仅仅用记忆化搜索，那么只能拿90分，其中一个点超时。优化：如果你已经找到一条对于该点出发来说的最长路径，那么下次遇到这个点的时候就可以不用搜索，直接返回这条路径的长度即可，最后用这个长度加上你之前走过的长度就是当前点的答案。省下了大量时间。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1854">P1854 花店橱窗布置</a><p>这是一个不一样的动态规划，不会做，就看题解了。结果发现题解代码和<a href="https://www.luogu.com.cn/problem/P2066">P2066 机器分配</a>一模一样，可以去对比一下。</p>我觉得好的题解是这个<a href="https://blog.csdn.net/lq1990717/article/details/125213307">信息学奥赛一本通 1279：【例9.23】橱窗布置(flower) | 洛谷 P1854 花店橱窗布置</a></div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1278">1278：【例9.22】复制书稿(book)</a>这这道题很难，当时没做出来，就这样吧。
    <pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
using namespace std;
int m,k,a[1001],s[1001],dp[1001][1001];
void show(int t,int x)
{
    int i;
    int sum=0;
    if(t==0)return;
    for(i=t;i&gt;=1&&sum+a[i]&lt;=x;i--)
    {
        sum+=a[i];
    }
    show(i,x);
    cout&lt;&lt;i+1&lt;&lt;" "&lt;&lt;t&lt;&lt;endl;
}
int main()
{
    cin&gt;&gt;m&gt;&gt;k;
    for(int i=1;i&lt;=m;i++)
    {
        cin&gt;&gt;a[i];
        s[i]=a[i]+s[i-1];
    }
    memset(dp,0x3f,sizeof(dp));
    for(int i=1;i&lt;=m;i++)
    {
        dp[i][1]=s[i];
    }
    for(int i=1;i&lt;=m;i++)
    {//i表示抄写的人数。 
        for(int j=2;j&lt;=k;j++)
        {//前j本书分配给i个人抄写。 
            for(int h=j;h&lt;=i;h++)
            {//最后一个人需要抄写h~i本书。 
                dp[i][j]=min(dp[i][j],max(dp[h-1][j-1],s[i]-s[h-1]));
            }
        }
    }
    show(m,dp[m][k]);
    return 0;
}
</pre>
</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1004">P1004 [NOIP2000 提高组] 方格取数</a>因为是2个人走，所以要用4维数组，dp[i][j][k][p]，ij表示第一个人走的，kp表示第二个人走的。
    <pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
using namespace std;
#define LL long long
LL n,a[40][40],ans,dp[11][11][11][11];
void print()
{
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=n;j++)
        {
            cout&lt;&lt;a[i][j]&lt;&lt;" ";
        }cout&lt;&lt;endl;
    }cout&lt;&lt;endl;
}
LL max(LL a,LL b)
{
    return a&gt;b?a:b;
}
void f()
{
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=n;j++)
        {
            for(int k=1;k&lt;=n;k++)
            {
                for(int p=1;p&lt;=n;p++)
                {
                    dp[i][j][k][p]=max(dp[i-1][j][k-1][p],max(dp[i][j-1][k][p-1],max(dp[i-1][j][k][p-1],dp[i][j-1][k-1][p])))+a[i][j];
                    if(i!=k&&j!=p)<span>//如果第一个人没走过，那第二个人就走过来。</span>
                    {
                        dp[i][j][k][p]+=a[k][p];
                    }	
                }
            }
        }
    }
    ans=dp[n][n][n][n];
}
int main()
{
    cin&gt;&gt;n;
    LL x,y,v;
    while(cin&gt;&gt;x&gt;&gt;y&gt;&gt;v&&(x!=0||y!=0||v!=0))
    {
        a[x][y]=v;
    }
    f();
    cout&lt;&lt;ans&lt;&lt;endl;
}
    </pre>当时情况没有考虑周全，导致暴力求解WA了2个点。暴力做法的代码在这里了<a href="https://www.luogu.com.cn/record/179790417">暴力代码</a>
    </div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P2758">P2758 编辑距离</a>确定状态，转移方程，注意边界条件。<br>致错原因：未处理边界。
    <pre>
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
using namespace std;
int dp[2001][2001];
string a,b;
int main()
{
    cin&gt;&gt;a&gt;&gt;b;
    a=" "+a;b=" "+b;
    <b style="color: red;">for(int i=1;i&lt;=a.length();i++)
    {<span>//当其中一个串为0时，最小操作次数就是不为零的那个串的长度咯！</span>
        dp[i][0]=i;
    }
    for(int i=1;i&lt;=b.length();i++)
    {
        dp[0][i]=i;
    }</b>
    for(int i=1;i&lt;=a.length();i++)
    {
        for(int j=1;j&lt;=b.length();j++)
        {
            if(a[i]==b[j])dp[i][j]=dp[i-1][j-1];
            else
            {
                <span>//我可以增删改三选一，三选一找最小值。</span>
                dp[i][j]=min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]))+1;
            }
        }
    }
    cout&lt;&lt;dp[a.length()][b.length()]&lt;&lt;endl;
    return 0;
}
    </pre>
    </div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1275">1275：【例9.19】乘积最大</a>像这种动态规划的题目不要用瞪眼法，瞪眼法看不出来的，需要先用小数据枚举，找规律，找状态转移方程。<br>致错原因：区间定义错误。</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1274">1274：【例9.18】合并石子</a>状态转移方程，dp[i][j]表示从第i堆石子到第j堆石子合并的最小价值。</div>
    <div class="t1">二维数组最大开5000*5000，否则可能出现MLE的情况。如果数据范围拿不准，就用vector吧。</div>
    <div class="t1">
        各个数据类型大小(单位字节Byte,B)：<br>short 2<br>int 4<br>long 4<br>long long 8<br>char 1<br>double 8<br><br>1MB=1024kb=1024*1024B。
    </div>
    <div class="t1">循环边界再检查一遍。看看变量名是否与上文重合了。</div>
    <div class="t1">有些题目需要对某些情况特判。</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1293">1293：买书</a>错误原因：没有看清条件。</div>
    <div class="t1">
        <a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1296">1296：开餐馆</a>
        致错原因：ans最大值更新时放在了if语句内，导致更新失败而爆0。
        <pre>
int ans=dp[1];
for(int i=1;i&lt;=n;i++)
{
    for(int j=1;j&lt;i;j++)
    {
        if(m[i]-m[j]&gt;k)
        {
            dp[i]=max(dp[i],dp[j]+p[i]);
        }
        <b style="color: red;">ans=max(ans,dp[i]);</b>//&lt;------- 应该是在这，之前写到上边括号里头了。
    }
}
cout&lt;&lt;ans&lt;&lt;endl;
        </pre>
    </div>
    <div class="t1">经常忘记题目叫输出的是啥，比如叫你求最大值，而且输出格式是“max=最大值”，结果我只输出了最大值，那么全0分。</div>

    <div class="t1">01背包：每种物品只选一次。(逆推)<code>二维：dp[i][j]=max(dp[i-1][j],dp<b style="color: rgb(255, 79, 188);">[i-1]</b>[j-w[i]]+c[i])<br>一维：dp[j]=max(dp[j],dp[j-w[i]]+c[i])</code><br>完全背包：每种物品数量无限。(顺推)<code><p>二维：dp[i][j]=max(dp[i-1][j],dp<b style="color: rgb(255, 79, 188);">[i]</b>[j-w[i]]+c[i])<br>一维：dp[j]=max(dp[j],dp[j-w[i]]+c[i]);</p></code><br>多重背包：每种物品数量有限。(二维可顺可逆，一维要逆推)<br><code><p>二维：dp[i][j]=max(dp[i][j],dp<b style="color: rgb(255, 79, 188);">[i-1]</b>[j-k*w[i]]+k*c[i]);<br>一维：dp[j]=max(dp[j],dp[j-k*v[i]]+k*w[i]);</p></code></p><br>混合背包：遍历物品的时候加个判断就好，物品只有一个那就是01背包，无限就是完全背包，有穷就是多重背包。其他都不变。<br><br>二维费用问题：普通背包的基础上再加一个状态就好，状态的最小值设为0或1。<br><br>分组背包：普通背包问题的基础上最内层多加一个遍历每组的物品个数就好了，可以用vector储存每组的物品信息。<br><br>有依赖的背包问题：需要建树。<br><br>背包问题的方案总数：递推，f[0]=1，普通背包基础上，往下推即可。<br><br>**01背包dp[i][j]的意思是，考虑前i个物品且背包容量为j的情况下能够获得的最大价值。当优化成一维dp[i]时，表示考虑前i件物品能达到的最大价值。<br>**完全背包：含义与01背包相同，只不过第i种物品可以取无数次。<br><br>*背包的数组优化，仅仅在空间上进行了优化。</div>

    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1271">1271：【例9.15】潜水员</a>二维费用问题的典型题目，代码如下：
        <pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
int m,n,s,a[1001],b[1001],c[1001],dp[1001][1001];
int main()
{
    cin&gt;&gt;m&gt;&gt;n&gt;&gt;s;
    for(int i=1;i&lt;=s;i++)
    {
        cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i];
    }
    memset(dp,0x3f,sizeof(dp));
    dp[0][0]=0;//都不放的时候就是0。 
    for(int i=1;i&lt;=s;i++)
    {
        for(int j=m;j&gt;=0;j--)
        {//枚举氧气 
            for(int k=n;k&gt;=0;k--)
            {//枚举氮气 
                //氧气限度不能低于0，如果低于0代表超了。 
                dp[j][k]=min(dp[j][k],dp[max(0,j-a[i])][max(0,k-b[i])]+c[i]);
            }
        }
    }
    cout&lt;&lt;dp[m][n]&lt;&lt;endl;
    return 0;
}
        </pre>
    </div>

    <div class="t1">Linux主要命令，一定要熟练掌握，否则赛场两眼一摸黑。<br><br><p><code>mkdir</code>：创建文件夹。</p><p><code>touch</code>：创建文件。</p><p><code>cd</code>：切换目录。</p><p><code>ls</code>：列出当前文件夹下的内容。</p><p><code>cat</code>：显示文件内容，而且是全部显示。</p><p><code>more</code>：查看文件内容，但是翻页查看。</p><p><code>cp [-r] [被复制] [复制到哪]</code>：复制文件文件夹，参数<code>-r</code>可以复制文件夹。</p><p><code>mv [被移动] [目的地]</code>：移动文件文件夹。</p><p><code>rm [-r -f] [参数1......参数n]</code>：删除文件，<code>-r</code>删除文件夹，<code>-f</code>强制删除。</p></div>

    <div class="t1"><p>对拍时使用<code>rand()</code>函数生成伪随机数的方法。</p><p>头文件是<code>#include &lt;cstdlib&gt;</code></p>接下来是代码：
        <pre>
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cstdlib&gt;

int getRand(int min, int max) {
    return (rand() % (max - min + 1)) + min;
}

int main() {
    srand(time(0)); // 使用当前时间作为种子
    for (int i = 0; i &lt; 10; i++) {
        int r = getRand(2, 20); // 生成2到20之间的随机整数
        std::cout &lt;&lt; r &lt;&lt; std::endl;
    }
    return 0;
}
        </pre>
        建议写一个自己的解题代码，再写一个暴力的代码，之后再写一个随机数生成数据的代码。<br><br>即，用随机数生成数据，然后用暴力算法测试数据答案，最后用自己的解题代码测试答案与暴力解法是否相等，如果不相等，说明代码存在漏洞。
    </div>
    
    <div class="t1"><b>别忘了加上文件读写。</b><p>文件读写的头文件是<code>#include &lt;cstdio&gt;</code>。</p>开头加上这句<code>freopen("demo.in","r",stdin);<br>freopen("demo.out","w",stdout);</code>否则等着爆0。<br>结尾建议加上这句<code>fclose(stdin);<br>fclose(stdout);</code></div>

    <div class="t1">调试的那些打印语句别忘了注释掉！否则0分等着你！</div>
    <div class="t1">
        二维数组求“最大连续子矩阵和”的解法：<br><br>
        <b>暴力解法：</b>6层循环即可，外两层是左上角，中间两层是右下角，内两层是枚举累加左上到右下的和。<br><br>
        <b>优化解法1：一维前缀和优化</b>
        跟一维数组求“最大连续子区间”的优化解法是一样的，只不过把<code>w[i]=w[i-1]+a[i];</code>改成了<code>w[i][j]=w[i][j-1]+a[i][j]</code>然后对循环以及部分内容稍微改动就完事了。<br><br>
        <b>优化解法2：二维前缀和优化</b>
        <pre>
#include &lt;iostream&gt;
using namespace std;
int n,a[10001][10001],w[10001][10001],maxn=-0x3f3f3f3f;
//maxn建议赋值为负数，因为矩阵当中可能会出现负的数。
int main()
{
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=n;j++)
        {
            cin&gt;&gt;a[i][j];
            w[i][j]=w[i-1][j]+w[i][j-1]+a[i][j]-w[i-1][j-1];
        }
    }
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=n;j++)
        {//------枚举左上角--------

            for(int k=i;k&lt;=n;k++)
            {
                for(int t=j;t&lt;=n;t++)
                {//--------枚举右下角---------

                    int sum=w[k][t]-w[k][j-1]-w[i-1][t]+w[i-1][j-1];
                    maxn=maxn&gt;sum?maxn:sum;

                }
            }

        }
    }
    cout&lt;&lt;maxn&lt;&lt;endl;
    return 0;
}
        </pre>
        图解：
        <img src="https://upload-bbs.miyoushe.com/upload/2024/09/30/198629752/bbf70b405981e8ae02468e701a216a77_3706323876176022470.png" alt="矩阵图解">如图，我们的二维前缀和优化相当于求(i-1,j-1)到(k,t)之间的前缀和。也就是我用红色线条画的那部分。那么那部分的前缀和sum就等于我用w[k][t]减去(区1+区2+区3)的前缀和，那么公式也就是<code>sum=w[k][t]-(w[k][j-1]-w[i-1][j-1])+(w[i-1][t]-w[i-1][j-1])+w[i-1][j-1];</code>最后化简后就成了这样子：<code>sum=w[k][t]-w[k][j-1]-w[i-1][t]+w[i-1][j-1];</code><br><p>*这也就是<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1282">1282：最大子矩阵</a>的解法</p>（这道题妥妥模板题。我还硬啃了2小时，艹！）
    </div>

    <div class="t1">
        一维数组求“最大连续子序列和”的解法：
        <br><b>优化解法1：（递推）</b>
        <pre>
#include &lt;iostream&gt;
using namespace std;
int n,a[10001],maxn;
int main()
{
    cin&gt;n;
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;a[i];
    }
    //-----------------------
    for(int i=1;i&lt;=n;i++)
    {
        int sum=0;
        for(int j=i;j&lt;=n;j++)
        {
            sum+=a[j];
            maxn=sum&gt;maxn?sum:maxn;
        }
    }
    //----------------------
    cout&lt;&lt;maxn&lt;&lt;endl;
    return 0;
}
    </pre>
    两个注释线夹着的循环可以改为这种写法：（最朴素的解法）
    <pre>
for(int i=1;i<=n;i++)
{
    for(int j=i;j<=n;j++)
    {
        int sum=0;
        for(int k=i;k<=j;k++)
        {
            sum+=a[k];
        }
        maxn=sum>maxn?sum:maxn;
    }
}
    </pre>
    这两种是等价的，但前者能少一个循环。
    <br><b>优化解法2：利用前缀和求区间和</b>
    <pre>
#include &lt;iostream&gt;
using namespace std;
int n,a[10001],maxn,w[10001];
int main()
{
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;a[i];
        w[i]=w[i-1]+a[i];
    }
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=i;j&lt;=n;j++)
        {
            maxn=maxn&gt;(w[j]-w[i-1])?maxn:(w[j]-w[i-1]);
        }
    }
    cout&lt;&lt;maxn&lt;&lt;endl;
    return 0;
}
    </pre>
    这里用w数组在输入的时候就顺带把前缀和全都求出来了，然后要求出某个区间的前缀和，那就用区间的右端点的前缀和与左端点的前缀和相加就能得到答案。(但要注意左端点的头也得算在内，要i-1)。如图解：
    <img src="https://upload-bbs.miyoushe.com/upload/2024/09/30/198629752/175dac2c567043cd0c76c462fa3e903c_1093202781834302723.png" alt="区间图解">
    <br>
    一维和二维的处理方式有点不一样，见参考：<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1282">1282：最大子矩阵</a>
    </div>

    <div class="t1"><b>二维前缀和的计算方法</b><br>在二维数组中，我们首先定义一个同等大小的二维数组dp，其中dp[i][j]表示从原数组左上角(1,1)到(i,j)形成的子矩阵的元素和。计算dp[i][j]的状态转移方程如下：
<code>dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + arr[i][j];</code>
    <b>*即，自身前缀和=左+上+自身-左上。</b>
    </div>

    <div class="t1">动态规划+最优路径典中典的题目，这道题实在是太典了，建议记住。<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1266">1266：【例9.10】机器分配</a>
    <pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
using namespace std;
int n,m;
int a[10001][10001];
int dp[10001][10001];
int vis[10001][10001];
void print(int x,int y)
{
    if(x==0)return;
    print(x-1,y-vis[x][y]);
    cout&lt;&lt;x&lt;&lt;" "&lt;&lt;vis[x][y]&lt;&lt;endl;
}
int main()
{
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=m;j++)
        {
            cin&gt;&gt;a[i][j];
        }
    }
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=m;j++)
        {
            for(int k=0;k&lt;=j;k++)
            {
                if(dp[i-1][j-k]+a[i][k]&gt;=dp[i][j])
                {
                    dp[i][j]=dp[i-1][j-k]+a[i][k];
                    vis[i][j]=k;
                }
            }
        }
    }
    cout&lt;&lt;dp[n][m]&lt;&lt;endl;
    print(n,m);
    return 0;
}
    </pre>
    这是一个三重循环的动态规划，i外层代表当前公司，j代表要选的机器数，k代表还剩几台机器能够选。最后vis[i][j]记录公司选的机器数k，然后递归打印公司x和机器数vis[x][y]。
    </div>

    <div class="t1">模版题：<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1265">1265：【例9.9】最长公共子序列</a>
        <pre>
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;
using namespace std;
string a,b;
int dp[1001][1001];
int main()
{
    cin&gt;&gt;a&gt;&gt;b;
    int n=a.size(),m=b.size();
    a=' '+a;
    b=' '+b;
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=m;j++)
        {
            if(a[i]==b[j])
            {
                dp[i][j]+=dp[i-1][j-1]+1;
            }
            else
            {
                dp[i][j]=max(dp[i][j-1],dp[i-1][j]);
            }
        }
    }
    cout&lt;&lt;dp[n][m];
    return 0;
}
        </pre>
        建议直接背会。dp[i][j]的意思是，i的前面和j的前面有多少公共的部分，如果a[i]==b[j]，那么dp[i][j]+=dp[i-1][j-1]+1，那如果不相等，就继承i与j前面最大的公共部分。
    </div>

    <div class="t1">字符类型数组，一个字符占1byte大小，八位。实际上，能开的最大长度是2146793727。<code>char s[2146793727];</code><br>字符串类型数组，一个字符串能存储4049个字符（多了会卡死），但字符串类型的数组最大长度为268349215<code>string b[268349215];</code><br>int 类型数组，一个int类型的变量占4个字节，是字符的四倍，所以int类型数组的最大长度大概是字符类型的四分之一，为536698431<code>int a[536698431];</code><br>long long类型数组，一个long long类型的变量占8个字节，所以longlong类型数组的最大长度大概是268349215<code>long long c[268349215];</code><br>浮点数，float和double类型的变量就像是int和longlong，而数组最大长度也分别和int和longlong相同，为536698431和268349215<code>float e[536698431];<br>double f[268349215];</code><br>布尔类型，布尔类型的变量也只占一个字节，所以数组最大长度和char一样为2146793727<code>bool d[2146793727];</code><br>*以上总结的各类型数组最大长度仅为最大能编译的长度</div>

    <div class="t1">动态规划最短路径问题<br><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1261">1261：【例9.5】城市交通路网</a>这道题是一道经典dp，建议烂熟于心。<img src="https://upload-bbs.miyoushe.com/upload/2024/09/29/198629752/513612dea4e03294e7f64b38ffd8f2a4_456798892526461554.png" alt="城市交通路网"><br><code>memset(arr,0x3f,sizeof(arr));</code>memset用0x3f初始化数组代表无穷大，因为memset函数初始化特点是按字节去逐个初始化。</div>

    <div class="t1">最长上升子序列（LIS）<br><br>最长不下降子序列（LNDS）<br><br>最长下降子序列（LDS）<br><br>最长不上升子序列（LNIS）</div>

    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1091">P1091 [NOIP2004 提高组] 合唱队形</a>这道题是一道令人迷惑的题目，我做了2次，错了2次，而且全错，0分。不说了，代码放这了，自己看吧，啥时候忘了啥时候回来瞅一眼。
        <pre>
#include &lt;iostream&gt;
using namespace std;
int n,a[10001],up[10001],down[10001];
int main()
{
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;a[i];
        up[i]=1;down[i]=1;
    }
    for(int i=2;i&lt;=n;i++)
    {
        for(int j=1;j&lt;i;j++)
        {
            if(a[i]&gt;a[j]){up[i]=max(up[i],up[j]+1);}
        }
    }
    //这两个循环不等价，当时我还不信，硬是写一块去，结果WA了4个点。
    for(int i=n-1;i&gt;=1;i--)
    {
        for(int j=i+1;j&lt;=n;j++)
        {
            if(a[i]&gt;a[j]){down[i]=max(down[i],down[j]+1);}
        }
    }
    int ans=-0x3f3f3f3f;
    for(int i=1;i&lt;=n;i++)
    {
        ans=max(ans,up[i]+down[i]-1);
    }
    cout&lt;&lt;n-ans&lt;&lt;endl;
    return 0;
}
        </pre>
    </div>

    <div class="t1"><p>对于<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1283">1283：登山</a>这道题目我真是服了，</p><img src="https://upload-bbs.miyoushe.com/upload/2024/09/30/198629752/4d6f33c3b441e2a2080df38abe0eec24_6549954258408915795.png" alt="登山">就是这句具有迷惑性的话，直接让我0分。让我们来思考一下这句话的含义，首先不能连续爬相同的山，那么我们会很容易想到他下山的时候有没有可能会爬相同的山？那是不是就是非严格单调子序列？其实不是，我们反证法可以得出，如果他经过了2个相同高度的山，那么分2种情况，一种是在爬山(或下山)过程中经过的，很显然根据题目可知不会有这种情况。那么另外一种就是一个在爬的过程中经过一遍，一个在下山过程中经过一遍，但又由于，上山属于单调增，下山属于单调减，因此这种情况完全可以忽略不计，因为他们根本不可能同时在一个严格单调序列里面。<p>因此这道题就是<a href="https://www.luogu.com.cn/problem/P1091">P1091 [NOIP2004 提高组] 合唱队形</a>的变形，只不过最终的答案不再是n-ans，而是直接输出ans，其他都不需要改。也就是说这就转化成了一个数学证明题：求证同时经过两座山并且还得同时位于一个单调序列种的情况不可能出现。</p></div>

    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1260">1260：【例9.4】拦截导弹(Noip1999)</a>这道题目是典型的求 最长不上升子序列 和 最长下降子序列 的题目，具体代码如下：<img src="https://upload-bbs.miyoushe.com/upload/2024/09/29/198629752/f9380e628310dba1074bde3f982cc994_4117213231434843130.png" alt="拦截导弹"><br>当时错了好几遍都没过，致错原因还是太理所当然的认为是暴力求解，但其实由题意可得，答案是求最长不上升子序列和最长下降子序列。<br><br>这是一个代码模板，要求背会。考试能保证类似的题能拿一半的分。<br><br><a href="https://www.luogu.com.cn/problem/P1020">P1020 [NOIP1999 提高组] 导弹拦截</a>洛谷的这道题是升级版。<br>对于最小划分数有：<br>不升子序列：lower_bound<br>不降子序列：upper_bound<br>严格上升子序列：对所有数取相反数，upper_bound<br>严格下降子序列：对所有数取相反数，lower_bound<br><pre><b style="color: rgb(51, 255, 0);">Dilworth 定理</b><br>原链最长长度=反链划分数最小值：<br><br>上升子序列⇔不升子序列<br>下降子序列⇔不降子序列<br><br>*如果定理不会用(或没把握)，那就返璞归真，用最朴素的解法求答案。</pre><br>题解如下：<img src="https://upload-bbs.miyoushe.com/upload/2024/09/29/198629752/c9a4c200879f825f3558433fcff69c1d_5668380233911982326.png" alt="迪尔沃斯定理"></div>

    <div class="t1">题目都说了最大上升，上升，怎么能写成小于等于？应该是严格递增的呀。</div>

    <div class="t1">如果用scanf读入字符串不方便，害怕出错，那么就写stread()，即字符串快读，写法与数字快读同理。<br>
        <pre>
<span class="">string</span> <span>stread()</span>
<span>{</span>
    <span>string</span> <span>s</span>;<span>char</span> <span>ch</span>=<span>getchar()</span>;</span>
    &nbsp;&nbsp;<span>while</span><span>(</span><span>ch</span>&lt;<span>'a'</span>&&<span>ch</span>&gt;<span>'z'</span>||<span>ch</span>&lt;<span>'A'</span>&&<span>ch</span>&gt;<span>'Z'</span>||<span>ch</span>&lt;<span>'0'</span>&&<span>ch</span>&gt;<span>'9'</span><span>)</span><span>{</span><span>ch</span>=<span>getchar()</span>;<span>}</span></span>
    &nbsp;&nbsp;<span>while</span><span>(</span><span>ch</span>&gt;=<span>'a'</span>&&<span>ch</span>&lt;=<span>'z'</span>||<span>ch</span>&gt;=<span>'A'</span>&&<span>ch</span>&lt;=<span>'Z'</span>||<span>ch</span>&gt;=<span>'0'</span>&&<span>ch</span>&lt;=<span>'9'</span><span>)</span><span>{</span><span>s</span>+=<span>ch</span>;<span>ch</span>=<span>getchar()</span>;<span>}</span>
    <span>return</span> <span>s</span><span>;</span>
<span>}</span>
        </pre>
    </div>
    <div class="t1">字符串用scanf读入时，如果有空格，那么可能会出现一些棘手的问题。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;头文件&lt;string&gt;，用于定义string类型。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;头文件&lt;cstring&gt;，里面包含了字符串的相关函数，比如strlen()、strcpy()、fgets()、sscanf()。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;输入结束时getchar()会返回EOF，即End Of File。控制台中可以使用(Windows)Ctrl+Z或者(Linux)Ctrl+D来输入EOF表示输入结束。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;string类型的字符串可以直接进行比较，比较是按照字典序进行的。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;fgets()来读入一行字符串并存入字符数组中，而gets()有溢出的风险所以不使用。<code>fgets(s,sizeof(s),stdin);</code>这条语句制定了字符数组的最大读入数量，因此是安全的。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;sscanf()和scanf()是很接近的。比如，<code>sscanf(s,"%d",&a);</code>就可以从s字符串中读入一个整数a。他们的区别是，scanf()是从标准输入中读入，而sscanf()是从给定的一个字符串中读入，所以要求提供字符数组的名称，表示从哪个字符串里面读入信息。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;同理，<code>sprintf(s,"%d",a);</code>就可以将一个int类型的数a输出到字符串s中而不是标准输出。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;s.substr(pos,len)：截取字符串s，从第pos个位置开始len个字符，并返回这个字符串。<br>&nbsp;&nbsp;&nbsp;&nbsp;s.insert(pos,str)：在字符串s的第pos个字符之前，插入字符串str，并返回这个字符串。<br>&nbsp;&nbsp;&nbsp;&nbsp;s.find(str,[pos])：在字符串s中从第pos个字符开始寻找str，并返回位置，如果找不到返回-1。pos可以省略，默认值是0；<br>&nbsp;&nbsp;&nbsp;&nbsp;*要注意的是find函数查找子串但是找不到时，它会返回一个常量string::npos，但是由于它不一定是一个int类型的常量，因此要强制转换成int类型才能直接输出-1。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;另外还要注意字符串能赋值一个常量，但不能像下面这样赋值↓
        <pre>

<span><span>string</span> <span>a</span>,<span>b</span>;</span>
<span><span>a</span>=<span>"LUOGU"</span>;</span>
<span><span>b</span>=<span>a</span>;<span><span>//这一步是错误操作</span></span></span>
        </pre>
    </div>

    <div class="t1">公式：[1,n]的约数中有p的数的个数为[n/p]<br><br>&nbsp;&nbsp;&nbsp;&nbsp;*(其中[]表示向下取整)。<br><br>当p很大时，在一个区间范围内，[n/pi]保持不变，因此遍历时可以直接从pi跳到pj，其中pj=[n/(n/pi)]+1，区间长度为j-i。
<pre>

<span>#include</span> <span>&lt;iostream&gt</span>;
<span>using</span> <span>namespace</span> <span>std</span>;
<span>#define</span> <span>LL</span> <span>long long</span>
<span>LL</span> <span>ans</span>,<span>n</span>;
<span>int</span> <span>main()</span>
<span>{</span>
    cin>><span>n</span>;
    <span>for</span>(</span><span>LL</span> <span>i</span>=1,<span>j</span>;<span>i</span>&lt;=<span>n</span>;<span>i</span>=<span>j</span>)
    <span>{</span>
        <span>j</span>=<span>n</span>/<span>(</span><span>n</span>/<span>i</span><span>)</span>+<span>1</span>;
        <span>ans</span>+=<span>(</span><span>n</span>/<span>i</span><span>)</span>*<span>(</span><span>j</span>-<span>i</span><span>)</span>;
    <span>}</span>
    cout&lt;&lt;<span>ans</span>;
    <span>return</span> 0;
<span>}</span>

</pre>
    </div>
    <div class="t1"><img src="https://upload-bbs.miyoushe.com/upload/2024/09/29/198629752/09f0aab8de6e5cc0db270c73e691dab6_9079656361092462373.png" alt="时间复杂度">应尽量避免除法运算。还有循环如果能用while就用while。</div>
    <div class="t1">如果遇到10^6这样的大数据，能写快读就写快读。</div>
    <div class="t1">cin读取数字时可以把数字的符号一起读进去，也就是说，当你要读入一个数字表达式，那么可以直接用cin读入，连数字的正负判断都省了。</div>
    <div class="t1">补全程序当中遇到图论代码，如果遇到不认识的数组，就往“点”、“入度”、“出度”、“权值”上想，再偏也不会跑出这个考试范围。</div>
    <div class="t1">注意数据范围，要开 long long 的千万不要忘了开，否则只能拿一半的分！</div>
    <div class="t1">浮点数转整形会丧失精度，要看好代码中的类型转换以及是否出现了，函数要求传入int类型然而却传入了浮点类型。</div>
    <div class="t1">"7/sqrt(3)/2"和"7/2/sqrt(3)"不一样，前者会先变成浮点数再除以二，相比于后者精度更精确，二者存在明显的精度误差。</div>
    <div class="t1">b=a*q则，b是a的倍数，a是b的约数。</div>
    <div class="t1">由数字
        1,1,2,4,8,8 所组成的不同的 
        4 位数的个数是（）。<br><br>解：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;情况1：无重复的数字，1、2、4、8一共4个数字放在4个位置，：4×3×2=24<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;情况2：仅重复1，两个1，两个1的组合是6种：11xx,1x1x,1xx1,x11x,x1x1,xx11，两个x位置放3个不重复的数字，共3×2=6种，6×6=36种<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;情况3：仅重复8，两个8，同上，一共6×6=36种<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;情况4：重复两对，两个1和两个8。11xx,1x1x,1xx1,x11x,x1x1,xx11，一共6种。</div>
    <div class="t1">一些数字可以颠倒过来看，例如
        0,1,8 颠倒过来还是本身，
        6 颠倒过来是 
        9,9 颠倒过来看还是 
        6,其他数字颠倒过来都不构成数字。类似的，一些多位数也可以颠倒过来看，比如
        106 颠倒过来是
        901。假设某个城市的车牌只有 
        5 位数字，每一位都可以取 
        0 到 
        9。请问这个城市有多少个车牌倒过来恰好还是原来的车牌，并且车牌上的 
        5 位数能被 
        3 整除？（）<br><br>解：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第1、2位有（0、1、8、6、9）五个数字，第3位有（0、1、8）三个数字，第4、5位由第1、2位决定。由于0,1,8模3正好余0,1,2，所以其他位确定则第3位自然确定，共5*5=25种。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;举例：第1位选1，第5位必然是1；第2位选0，第4位必然是0；为能被3整除，第3位只能选8。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第1位可选5个数字，第2位也可选5个数字。5*5=25种。<br><br><p style="color: rgb(232, 0, 0);background-color: rgb(254, 241, 0);">注: 是车牌，车牌第一位可以是0</p></div>
    <div class="t1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果一个数的所有数字之和能被3整除，则这个数能被3整除。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果一个数的个位为0或5，则这个数能被5整除。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果一个数的所有数字之和能被9整除，则这个数能被9整除。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果一个数所有奇数位的数字相加减去所有偶数位的数字后的值能被11整除，那么这个数能被11整除。</div>
    <div class="t1">G是一个非连通无向图(没有重边和自环)，共有28条边，则该图至少有(  )个顶点。<br><br>解：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最优情况下是8个顶点的完全图，外加1个孤立顶点。即共有9个顶点。<img src="https://upload-bbs.miyoushe.com/upload/2024/09/23/198629752/de892d9f522b3dbd49e60532b643533c_4417491289934517107.png" alt="8个顶点的完全图">最后的边数就是1+2+3+4+5+6+7+8=28。</div>
    <div class="t1">在写并查集的代码时，并查集的初始化f[i]=i,其中i∈[a,b],则输入的一对节点(x,y)也应该在[a,b]范围内。因为如果超出这个范围，x的父节点会被默认指向为0或其他未知数字。</div>
    <div class="t1">没有路径压缩的并查集时间复杂度为线性的O(n),路径压缩后的为O(1)。</div>
    <div class="t1">如要补充，请联系管理员......</div>
    <!--  -->
    <!--  -->
    <!--  -->
</body>
<script src="./CanvasFor_index.js"></script>
<!-- <script src="./Canvas2.js"></script> -->
<script src="./Volume.js"></script>
<script src="./Unitcopy.js"></script>
<script src="./ChangSpanColor.js"></script>
<script src="./a_blank.js"></script>
</html>