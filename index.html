<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <link rel="apple-touch-icon" href="../../../sqhgxsq/next/Material/logo.png">
    <link rel="icon" href="https://ys.mihoyo.com/main/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="https://ys.mihoyo.com/main/favicon.ico" type="image/x-icon">
    <meta name="renderer" content="webkit">
    <meta property="og:image" content="https://fastcdn.mihoyo.com/static-resource-v2/2023/12/20/e04bc0be964b4fc7056bc1128b35f200_4546122273706382871.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="keywords" content="OIer的错题集,ESC,ESC.html">
    <meta name="description" content="OIer的错题集,ESC,ESC.html">

    <!-- bing sitmap system -->
    <meta name="msvalidate.01" content="E636B33C63F884A1E40D913638E2424B" />
    <!--  -->

    <title>错题集</title>

    <link rel="stylesheet" href="style.css">

    <!--  -->
    <style>
        @media screen and (max-width:900px) {
            .bg1{
        background-image: url("https://act-webstatic.mihoyo.com/event-static/2024/06/24/570fc67f4b580da77f9af206eb3bc0a5_7858946434453008095.jpg?x-oss-process=image/quality,Q_80/resize,m_lfit,s_700");
            }
        }
        @media screen and (min-width:901px){
            .bg1{
        background-image: url("https://act-webstatic.mihoyo.com/event-static/2024/06/24/94fe58803161e06dd1e2fcea8ba56a41_8214787202754590749.png?x-oss-process=image/quality,Q_80/resize,m_lfit,s_700");
    }
        }
    </style>
    <!--  -->
</head>
<body>
    <header id="_header">
        <!-- <div class="ph" id="h_1" onclick="window.open('./index.html')">
            NOI
        </div> -->
        <!-- <div class="ph" id="h_2" onclick="window.open('./PH.html')">
            物理
        </div> -->
        <!-- <div class="ph" id="h_3" onclick="window.open('./CM.html')">
            化学
        </div> -->
        <!-- <div class="ph" id="h_4" onclick="window.open('./BO.html')">
            生物
        </div> -->
        <!-- <div class="ph" id="h_5" onclick="window.open('https://oi-wiki.org/')">
            OIWiki
        </div> -->
    </header>
    
    <!--  -->
    <audio src="https://static-mp-54c94446-e6a2-431f-84c4-ed0d181ae263.next.bspapp.com/music/时暮的思眷.mp3" id="dd" autoplay loop style="display: none;"></audio>
    <!--  -->
    <div class="bg1"></div>
    <div class="bg2"></div>
    <div class="bg3"></div>
    <div class="bg4"></div>
    <div class="bg5"></div>
    <div class="bg6"></div>
    <div class="bg7"></div>
    <div class="bg8"></div>
    <!--  -->


    <div class="op">
        <h1>下拉查看OI错题</h1>
    </div>



    <br>
    <h1>错题集</h1>
    <br>
    <hr style="z-index: 1;">
    <br>
    <!--  -->
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1375">1375：骑马修栅栏(fence)</a>记录欧拉路要在回溯阶段存储，否则会出现错误。另外，起始点不一定是1。题目中说“输出第一个数较小的”意思就是开始的节点度数最小，那么我们的最终代码就出来了：<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
int f,n;
int arr[2001],top=1;
int g[2001][2001],du[2001];
void dfs(int xi)
{
    for(int i=1;i&lt;=n;i++)
    {
        if(g[xi][i])
        {
            g[xi][i]--;g[i][xi]--; 
            dfs(i);
        }
    }
    arr[top++]=xi;<span>//回溯阶段存储路径</span>
}
int main()
{
    cin&gt;&gt;f;
    int start=0x3f3f3f3f;<span>//就像我说的，起始节点不一定是1，所以要初始时赋值为一个很大的数，后面找最小的节点编号。</span> 
    for(int i=1,x,y;i&lt;=f;i++)
    {
        cin&gt;&gt;x&gt;&gt;y;
        g[x][y]++;g[y][x]++;
        du[x]++;du[y]++;
        n=x&gt;n?x:n;<span>//找到最大的点的编号。</span>
        n=y&gt;n?y:n;
        start=start&lt;x?start:x;<span>//找到最小的点</span>
        start=start&lt;y?start:y;
    }
    for(int i=1;i&lt;=n;i++)
    {
        if(du[i]%2==1)
        {
            start=i;
            break;
        }
    }
    dfs(start);
    for(int i=top-1;i&gt;=1;i--)
    {<span>//到序输出</span>
        cout&lt;&lt;arr[i]&lt;&lt;endl;
    }
    return 0;
}
    </pre>说白了还是最基础的邻接矩阵存图，没什么难的，但要是不注意题目说的是啥，那就容易爆0。(当时我还在想500进制表示法是啥来着，但现在看来啥用也没有。)</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1374">1374：铲雪车(snow)</a><p>看到这道题我第一时间想到的是建立一个图。结果当我看到<a href="https://blog.csdn.net/lq1990717/article/details/129891715#:~:text=%E9%93%B2%E9%9B%AA%E8%BD%A6%E5%8F%AF%E4%BB%A5%E5%9C%A8%E4%BB%BB%E6%84%8F%E4%BA%A4%E5%8F%89">题解</a>的时候立刻小脑萎缩。</p>致错原因：做题前没有充分分析题目。有些题目要用数学方法证明，如果能证明出来，那么题目会非常简单，但如果证明不出来，那么就只能模拟。但通常像这种题目，模拟难度往往很高。*我也不会模拟。</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1341">1341：【例题】一笔画问题</a>致错原因：这是无向图，有度，没有入度和出度之分，直接用度就好了。使用邻接矩阵解决。<p><a href="https://blog.csdn.net/Wchenchen0/article/details/81283700">题解</a>仅供参考。</p>原本深入浅出的那本书上讲的挺好的，到这里怎么我的编程能力还退化了呢？</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1372">1372：小明的账单</a>这道题挺简单，但要注意的是要对每个账单设置一个id，已经弹出的账单保证不再弹出。<a href="https://blog.csdn.net/lq1990717/article/details/128502439#:~:text=ybt%201372%EF%BC%9A%E5%B0%8F">题解</a>使用优先队列priority_queue可以快速完成。不建议使用多重集合multiset。</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1371">1371：看病</a>这道题看似很简单，其实坑点一大堆。其中一个点还超时。<a href="https://blog.csdn.net/lq1990717/article/details/128490063#:~:text=1371%EF%BC%9A%E7%9C%8B%E7%97%85%20%E6%97%B6%E9%97%B4">题解</a></div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1370">1370：最小函数值(minval)</a><p>这道题不难，主要是刚开始读题可能会理解错，这道题的意思是对函数值排序，不是叫你对解出的x值排序。这是<a href="https://www.cnblogs.com/tflsnoi/p/14150443.html#:~:text=1370%EF%BC%9A%E6%9C%80%E5%B0%8F%E5%87%BD%E6%95%B0%E5%80%BC">题解</a></p></div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1373">1373：鱼塘钓鱼(fishing)</a><p>这道题挺难的，因为我不会。但是<a href="https://blog.csdn.net/Wchenchen0/article/details/81259412">题解</a>很好看。</p></div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1369">1369：合并果子(fruit)</a>哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈，我对了！我对了！<br>我终于对了一道题了！！！哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈......<br><b>需要注意的是，要分成函数写，否测会WA，不知道为啥，写成顺序结构会WA，但封装成函数就AC了(挠头~)。</b><p>*也可以直接用<code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt;</code>来解出答案。(也不知道比赛时叫不叫用)</p><pre>
#include &lt;iostream&gt;
using namespace std;
#define LL long long
LL n,a[30001],ans;
void swap(LL &a,LL &b)
{
    LL tmp=a;a=b;b=tmp;
}
void _init()
{
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;a[i];
        int p=i;
        while(p!=1)
        {
            if(a[p/2]&gt;a[p])
            {
                swap(a[p/2],a[p]);
            }
            else break;
            p=p/2;
        }
    }
}
void put(int x)
{
    a[++n]=x;int p=n;
    while(p!=1)
    {
        if(a[p/2]&gt;a[p])
        {
            swap(a[p/2],a[p]);
        }
        else break;
        p=p/2;
    }
}
int get()
{
    LL res=a[1];
    a[1]=a[n--];
    for(int i=1;i&lt;=n;i++)
    {
        int p=i;
        while(p!=1)
        {
            if(a[p/2]&gt;a[p])
            {
                swap(a[p/2],a[p]);
            }
            else break;
            p=p/2;
        }
    }
    return res;
}
int main()
{
    cin&gt;&gt;n;
    _init();
    while(1)
    {
        if(n==1)break;
        LL a=get();
        LL b=get();
        put(a+b);
        ans+=(a+b);
    }
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}
    </pre></div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1368">1368：对称二叉树(tree_c)</a>二叉树的题目好难啊，这道题还是不会。<a href="https://blog.csdn.net/lq1990717/article/details/127680193">题解</a></div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1367">1367：查找二叉树(tree_a)</a>致错原因：题目描述的问题，与我无瓜~，™也没说1号必须是根节点呀？<a href="https://blog.csdn.net/qq_39053800/article/details/108318606">题解</a>如此简单的一道题，我又双叒做错了。</div> 
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1365">1365：FBI树(fbi)</a><p>这道题不会，我看的<a href="https://www.cnblogs.com/tflsnoi/p/14110703.html#:~:text=%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E7%AC%A8%E5%8A%9E%E6%B3%95%E5%BB%BA%E6%A3%B5%E6%A0%91">题解</a></p></div>
    <div class="t1">使用cin、cout、string......时，一定要引入命名空间<code>using namespace std;</code></div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1363">1363：小球(drop)</a>这道题可以暴力遍历。<a href="https://www.cnblogs.com/sxrekord/p/small_ball.html#:~:text=1363%EF%BC%9A%E5%B0%8F%E7%90%83%20(d">题解</a>*然而我还傻傻模拟了一棵树。</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1364">1364：二叉树遍历(flist)</a>这么简单的题也能错？我真的服了。致错原因：没有加if判断。<a href="https://www.cnblogs.com/sxrekord/p/binary_tree_traversal.html">题解</a>就只这两个if判断<pre>
if(p&gt;l)print(l,p-1);
if(p&lt;r)print(p+1,r);</pre>*函数名和题解的不一样。</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/pic/1340.gif">1340：【例3-5】扩展二叉树</a>写的时候发现全错，但答案是对的，后来发现自己忘记把新创建的节点赋值为NULL，然后再判断要不要创建新节点。<br>这是正确写法，重点标红：<pre>void crt(tree &p)
{
    char x=getchar();
    <b style="color: red;">p=NULL;</b><span>//先赋值为NULL。</span>
    <b style="color: red;">if(x=='.')return;</b><span>//再看看要不要创建新的。</span>
    <b style="color: red;">p=new node;</b><span>//如果要，那么就创建新的。</span>
    p->l=NULL;p->r=NULL;
    p->data=x;
    crt(p->l);
    crt(p->r);
}</pre>如果反过来写虽然输出是对的，但判题机给我判错，我想可能是因为我没有把p赋值为NULL，导致输出时某些不可见字符被输出了出来导致错误。</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1339">1339：【例3-4】求后序遍历</a>第一次就想写出来不就成了天才了？(自我安慰)<a href="https://blog.csdn.net/qq_39053800/article/details/108182882">题解</a>这是模板，后面学二叉树可能会用它来构造二叉树，需要背下来。</div>
    <div class="t1">创建链表。<pre>struct node
{
    int data;<span>//数据。</span> 
    node *next,*pre;<span>//前指针、后指针。 </span>
};
node *head,*p,*r;<span>//创建头、中、尾指针。</span>  </pre></div>
<div class="t1">
链表新增以及移动的几个步骤：<br>
1.申请新节点。<br>
2.赋值数据。<br>
3.当前节点的下一个置为NULL，前一个节点的下一个置为自己。<br>
4.指针后移，即前一个变成自己。<br>
<pre>
p=new node;
p->data=x;
p->next=NULL;
r->next=p;
r=p;
</pre>在此之前还需要<code>head=new node;<br>r=head;</code>最后指针p归位<code>p=head->next;</code>
</div>
    <div class="t1">二叉树的存储结构，可以用数组，也可以用指针。两种方式都差不多，总之就是模拟。<br>这个是指针方式：<code>
typedef struct node;<br>
typedef node *tree;<br>
struct node<br>
{<br>
	&nbsp;&nbsp;*tree lchild,rchild;<br>
	&nbsp;&nbsp;int data;<br>
};<br>
tree bt;<br>
    </code></div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1306">1306：最长公共子上升序列</a>据说这道题是一道模板题。总之我不会，就算是看了题解还是不会。<p><a href="https://blog.csdn.net/lq1990717/article/details/124222748">君义_noip</a>的题解第一个还写错了，也没看懂在写啥。</p><p><a href="https://www.cnblogs.com/-Ackerman/p/11232960.html#:~:text=%E5%A6%82%E6%9E%9C%E6%98%AF%E6%B1%82%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E4%B8%8B%E9%99%8D">-Ackermanの博客</a>的题解还算比较清晰，但没时间看了，暂时就过吧。</p></div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1305">1305：Maximum sum</a>这是一个动态规划之最大连续子段和问题。没学过，不会。<p><a href="https://blog.csdn.net/lq1990717/article/details/124162300#:~:text=%E8%A7%A3%E6%B3%951%EF%BC%9A%20%E8%A6%81%E5%9C%A8%E6%95%B4%E4%B8%AA%E5%BA%8F">题解</a>看的似懂非懂。</p></div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1107">P1107 [BJWC2008] 雷涛的小猫</a>始终不知道自己哪错了，拿了80分，稀里糊涂看了题解。</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1304">1304：数的划分</a>信心都快要错没了。致错原因：没找对状态转移方程。<a href="https://developer.aliyun.com/article/1285630#:~:text=%E7%AE%80%E4%BB%8B%EF%BC%9A%201304%EF%BC%9A%E6%95%B0%E7%9A%84%E5%88%92%E5%88%86%20%E6%97%B6%E9%97%B4%E9%99%90%E5%88%B6%3A%201000%20ms%20%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6%3A%2065536%20KB,%E5%B0%86%E6%95%B4%E6%95%B0n%E5%88%86%E6%88%90k%E4%BB%BD%EF%BC%8C%E4%B8%94%E6%AF%8F%E4%BB%BD%E4%B8%8D%E8%83%BD%E4%B8%BA%E7%A9%BA%EF%BC%8C%E4%BB%BB%E6%84%8F%E4%B8%A4%E4%BB%BD%E4%B8%8D%E8%83%BD%E7%9B%B8%E5%90%8C%20%28%E4%B8%8D%E8%80%83%E8%99%91%E9%A1%BA%E5%BA%8F%29%E3%80%82%20%E4%BE%8B%E5%A6%82%EF%BC%9An%3D7%EF%BC%8Ck%3D3%EF%BC%8C%E4%B8%8B%E9%9D%A2%E4%B8%89%E7%A7%8D%E5%88%86%E6%B3%95%E8%A2%AB%E8%AE%A4%E4%B8%BA%E6%98%AF%E7%9B%B8%E5%90%8C%E7%9A%84%E3%80%82%201%EF%BC%8C1%EF%BC%8C5%EF%BC%9B%201%EF%BC%8C5%EF%BC%8C1%EF%BC%9B%205%EF%BC%8C1%EF%BC%8C1%EF%BC%9B%20%E9%97%AE%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E5%88%86%E6%B3%95%E3%80%82%20%E8%BE%93%E5%87%BA%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%EF%BC%8C%E5%8D%B3%E4%B8%8D%E5%90%8C%E7%9A%84%E5%88%86%E6%B3%95%E3%80%82">阿里云题解</a>这个题解还是蛮清晰的。</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1303">1303：鸣人的影分身</a>这道题不是很清楚，但为了时间，还是草草过了，后面遇到类似的题回来看看吧。<a href="https://blog.csdn.net/lq1990717/article/details/125285359#:~:text=%E6%88%91%E4%BB%AC%E7%9A%84%E4%B8%BB%E8%A7%92%E6%BC%A9%E6%B6%A1%E9%B8%A3%E4%BA%BA%E6%89%80">题解</a>题解写的也是一如既往的简单啊。为什么我就是想不出来呢?</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1302">1302：股票买卖</a>致错原因：数组忘记改名了，导致同一个数组用了2遍。<a href="https://blog.csdn.net/lq1990717/article/details/125284609#:~:text=%E8%AE%A2%E9%98%85%E4%B8%93%E6%A0%8F.%20%E3%80%90%E9%A2%98%E7%9B%AE%E9%93%BE">题解</a>我写的是解法一的优化版，下次忘了就回来看看。</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1301">1301：大盗阿福</a>常规做法会超时，必须优化。<a href="https://blog.csdn.net/weq2011/article/details/127170491#:~:text=%E9%98%BF%E7%A6%8F%E6%98%AF%E4%B8%80%E5%90%8D%E7%BB%8F%E9%AA%8C%E4%B8%B0%E5%AF%8C%E7%9A%84">题解</a>这个作者写的很全，有2种优化，1.一维数组+压缩循环。2.滚动数组+压缩循环。</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1300">1300：鸡蛋的硬度</a>很难想。<a href="https://blog.csdn.net/lq1990717/article/details/125259551">题解</a></div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1299">1299：糖果</a>致错原因：还是不会找状态转移方程。dp[i][j]表示取前i个数的余数为j时的最大值。<a href="https://blog.csdn.net/qq_40802813/article/details/123556631#:~:text=1299%EF%BC%9A%E7%B3%96%E6%9E%9C%20%E6%97%B6%E9%97%B4">题解</a></div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1297">1297：公共子序列</a>这道题和最长公共子序列那道题很像，但就是有一点点不一样，不知道为什么，竟然这都能AC？<pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
using namespace std;
string a,b;
int dp[501][501];
int f(string a,string b)
{
    memset(dp,0,sizeof(0));
    a=" "+a;
    b=" "+b;
    for(int i=1;i&lt;a.length();i++)
    {
        for(int j=1;j&lt;b.length();j++)
        {
            if(a[i]==b[j])
            {
                <span>//增加</span>
                dp[i][j]=dp[i-1][j-1]+1;
            }
            else
            {
                <span>//继承</span>
                dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
            }
        }
    }
    return dp[a.length()-1][b.length()-1];
}
int main()
{
    while(cin&gt;&gt;a&gt;&gt;b)
    {
        cout&lt;&lt;f(a,b)&lt;&lt;endl;
    }
    return 0;
}
    </pre>容易忽视的问题：当你在字符串前面加上空格时，字符串长度也会增加，因此ij不能循环到s.length()了，输出也不能输出到s.length()。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1434">P1434 [SHOI2002] 滑雪</a>这道题是动态规划+记忆化搜索。
    <pre>
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
using namespace std;
int r,c,a[201][201],maxn,dp[200][200];
int dir[4][2]={{1,0},{-1,0},{0,1},{0,-1}};
int dfs(int x,int y)
{
    <span>//如果来过，那么直接返回当前点出发的长度。就不需要再走一遍了。</span>
    if(dp[x][y])return dp[x][y];
    <span>//如果没来过，那么算上这个点，从这个点开始进行搜索。</span>
    dp[x][y]=1;
    for(int i=0;i&lt;4;i++)
    {
        int ux=x+dir[i][0],uy=y+dir[i][1];
        if(ux&gt;=1&&ux&lt;=r&&uy&gt;=1&&uy&lt;=c&&a[ux][uy]&lt;a[x][y])
        {
            dfs(ux,uy);
            dp[x][y]=max(dp[x][y],dp[ux][uy]+1);
        }
    }
    return dp[x][y];
}
int main()
{
    cin&gt;&gt;r&gt;&gt;c;
    for(int i=1;i&lt;=r;i++)
    {
        for(int j=1;j&lt;=c;j++)
        {
            cin&gt;&gt;a[i][j];
        }
    }
    for(int i=1;i&lt;=r;i++)
    {
        for(int j=1;j&lt;=c;j++)
        {
            maxn=max(maxn,dfs(i,j));
        }
    }
    cout&lt;&lt;maxn&lt;&lt;endl;
    return 0;
}
</pre>如果仅仅用记忆化搜索，那么只能拿90分，其中一个点超时。优化：如果你已经找到一条对于该点出发来说的最长路径，那么下次遇到这个点的时候就可以不用搜索，直接返回这条路径的长度即可，最后用这个长度加上你之前走过的长度就是当前点的答案。省下了大量时间。</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1854">P1854 花店橱窗布置</a><p>这是一个不一样的动态规划，不会做，就看题解了。结果发现题解代码和<a href="https://www.luogu.com.cn/problem/P2066">P2066 机器分配</a>一模一样，可以去对比一下。</p>我觉得好的题解是这个<a href="https://blog.csdn.net/lq1990717/article/details/125213307">信息学奥赛一本通 1279：【例9.23】橱窗布置(flower) | 洛谷 P1854 花店橱窗布置</a></div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1278">1278：【例9.22】复制书稿(book)</a>这这道题很难，当时没做出来，就这样吧。
    <pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
using namespace std;
int m,k,a[1001],s[1001],dp[1001][1001];
void show(int t,int x)
{
    int i;
    int sum=0;
    if(t==0)return;
    for(i=t;i&gt;=1&&sum+a[i]&lt;=x;i--)
    {
        sum+=a[i];
    }
    show(i,x);
    cout&lt;&lt;i+1&lt;&lt;" "&lt;&lt;t&lt;&lt;endl;
}
int main()
{
    cin&gt;&gt;m&gt;&gt;k;
    for(int i=1;i&lt;=m;i++)
    {
        cin&gt;&gt;a[i];
        s[i]=a[i]+s[i-1];
    }
    memset(dp,0x3f,sizeof(dp));
    for(int i=1;i&lt;=m;i++)
    {
        dp[i][1]=s[i];
    }
    for(int i=1;i&lt;=m;i++)
    {//i表示抄写的人数。 
        for(int j=2;j&lt;=k;j++)
        {//前j本书分配给i个人抄写。 
            for(int h=j;h&lt;=i;h++)
            {//最后一个人需要抄写h~i本书。 
                dp[i][j]=min(dp[i][j],max(dp[h-1][j-1],s[i]-s[h-1]));
            }
        }
    }
    show(m,dp[m][k]);
    return 0;
}
</pre>
</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1004">P1004 [NOIP2000 提高组] 方格取数</a>因为是2个人走，所以要用4维数组，dp[i][j][k][p]，ij表示第一个人走的，kp表示第二个人走的。
    <pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
using namespace std;
#define LL long long
LL n,a[40][40],ans,dp[11][11][11][11];
void print()
{
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=n;j++)
        {
            cout&lt;&lt;a[i][j]&lt;&lt;" ";
        }cout&lt;&lt;endl;
    }cout&lt;&lt;endl;
}
LL max(LL a,LL b)
{
    return a&gt;b?a:b;
}
void f()
{
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=n;j++)
        {
            for(int k=1;k&lt;=n;k++)
            {
                for(int p=1;p&lt;=n;p++)
                {
                    dp[i][j][k][p]=max(dp[i-1][j][k-1][p],max(dp[i][j-1][k][p-1],max(dp[i-1][j][k][p-1],dp[i][j-1][k-1][p])))+a[i][j];
                    if(i!=k&&j!=p)<span>//如果第一个人没走过，那第二个人就走过来。</span>
                    {
                        dp[i][j][k][p]+=a[k][p];
                    }	
                }
            }
        }
    }
    ans=dp[n][n][n][n];
}
int main()
{
    cin&gt;&gt;n;
    LL x,y,v;
    while(cin&gt;&gt;x&gt;&gt;y&gt;&gt;v&&(x!=0||y!=0||v!=0))
    {
        a[x][y]=v;
    }
    f();
    cout&lt;&lt;ans&lt;&lt;endl;
}
    </pre>当时情况没有考虑周全，导致暴力求解WA了2个点。暴力做法的代码在这里了<a href="https://www.luogu.com.cn/record/179790417">暴力代码</a>
    </div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P2758">P2758 编辑距离</a>确定状态，转移方程，注意边界条件。<br>致错原因：未处理边界。
    <pre>
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
using namespace std;
int dp[2001][2001];
string a,b;
int main()
{
    cin&gt;&gt;a&gt;&gt;b;
    a=" "+a;b=" "+b;
    <b style="color: red;">for(int i=1;i&lt;=a.length();i++)
    {<span>//当其中一个串为0时，最小操作次数就是不为零的那个串的长度咯！</span>
        dp[i][0]=i;
    }
    for(int i=1;i&lt;=b.length();i++)
    {
        dp[0][i]=i;
    }</b>
    for(int i=1;i&lt;=a.length();i++)
    {
        for(int j=1;j&lt;=b.length();j++)
        {
            if(a[i]==b[j])dp[i][j]=dp[i-1][j-1];
            else
            {
                <span>//我可以增删改三选一，三选一找最小值。</span>
                dp[i][j]=min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]))+1;
            }
        }
    }
    cout&lt;&lt;dp[a.length()][b.length()]&lt;&lt;endl;
    return 0;
}
    </pre>
    </div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1275">1275：【例9.19】乘积最大</a>像这种动态规划的题目不要用瞪眼法，瞪眼法看不出来的，需要先用小数据枚举，找规律，找状态转移方程。<br>致错原因：区间定义错误。</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1274">1274：【例9.18】合并石子</a>状态转移方程，dp[i][j]表示从第i堆石子到第j堆石子合并的最小价值。</div>
    <div class="t1">二维数组最大开5000*5000，否则可能出现MLE的情况。如果数据范围拿不准，就用vector吧。</div>
    <div class="t1">
        各个数据类型大小(单位字节Byte,B)：<br>short 2<br>int 4<br>long 4<br>long long 8<br>char 1<br>double 8<br><br>1MB=1024kb=1024*1024B。
    </div>
    <div class="t1">循环边界再检查一遍。看看变量名是否与上文重合了。</div>
    <div class="t1">有些题目需要对某些情况特判。</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1293">1293：买书</a>错误原因：没有看清条件。</div>
    <div class="t1">
        <a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1296">1296：开餐馆</a>
        致错原因：ans最大值更新时放在了if语句内，导致更新失败而爆0。
        <pre>
int ans=dp[1];
for(int i=1;i&lt;=n;i++)
{
    for(int j=1;j&lt;i;j++)
    {
        if(m[i]-m[j]&gt;k)
        {
            dp[i]=max(dp[i],dp[j]+p[i]);
        }
        <b style="color: red;">ans=max(ans,dp[i]);</b>//&lt;------- 应该是在这，之前写到上边括号里头了。
    }
}
cout&lt;&lt;ans&lt;&lt;endl;
        </pre>
    </div>
    <div class="t1">经常忘记题目叫输出的是啥，比如叫你求最大值，而且输出格式是“max=最大值”，结果我只输出了最大值，那么全0分。</div>

    <div class="t1">01背包：每种物品只选一次。(逆推)<code>二维：dp[i][j]=max(dp[i-1][j],dp<b style="color: rgb(255, 79, 188);">[i-1]</b>[j-w[i]]+c[i])<br>一维：dp[j]=max(dp[j],dp[j-w[i]]+c[i])</code><br>完全背包：每种物品数量无限。(顺推)<code><p>二维：dp[i][j]=max(dp[i-1][j],dp<b style="color: rgb(255, 79, 188);">[i]</b>[j-w[i]]+c[i])<br>一维：dp[j]=max(dp[j],dp[j-w[i]]+c[i]);</p></code><br>多重背包：每种物品数量有限。(二维可顺可逆，一维要逆推)<br><code><p>二维：dp[i][j]=max(dp[i][j],dp<b style="color: rgb(255, 79, 188);">[i-1]</b>[j-k*w[i]]+k*c[i]);<br>一维：dp[j]=max(dp[j],dp[j-k*v[i]]+k*w[i]);</p></code></p><br>混合背包：遍历物品的时候加个判断就好，物品只有一个那就是01背包，无限就是完全背包，有穷就是多重背包。其他都不变。<br><br>二维费用问题：普通背包的基础上再加一个状态就好，状态的最小值设为0或1。<br><br>分组背包：普通背包问题的基础上最内层多加一个遍历每组的物品个数就好了，可以用vector储存每组的物品信息。<br><br>有依赖的背包问题：需要建树。<br><br>背包问题的方案总数：递推，f[0]=1，普通背包基础上，往下推即可。<br><br>**01背包dp[i][j]的意思是，考虑前i个物品且背包容量为j的情况下能够获得的最大价值。当优化成一维dp[i]时，表示考虑前i件物品能达到的最大价值。<br>**完全背包：含义与01背包相同，只不过第i种物品可以取无数次。<br><br>*背包的数组优化，仅仅在空间上进行了优化。</div>

    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1271">1271：【例9.15】潜水员</a>二维费用问题的典型题目，代码如下：
        <pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
int m,n,s,a[1001],b[1001],c[1001],dp[1001][1001];
int main()
{
    cin&gt;&gt;m&gt;&gt;n&gt;&gt;s;
    for(int i=1;i&lt;=s;i++)
    {
        cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i];
    }
    memset(dp,0x3f,sizeof(dp));
    dp[0][0]=0;//都不放的时候就是0。 
    for(int i=1;i&lt;=s;i++)
    {
        for(int j=m;j&gt;=0;j--)
        {//枚举氧气 
            for(int k=n;k&gt;=0;k--)
            {//枚举氮气 
                //氧气限度不能低于0，如果低于0代表超了。 
                dp[j][k]=min(dp[j][k],dp[max(0,j-a[i])][max(0,k-b[i])]+c[i]);
            }
        }
    }
    cout&lt;&lt;dp[m][n]&lt;&lt;endl;
    return 0;
}
        </pre>
    </div>

    <div class="t1">Linux主要命令，一定要熟练掌握，否则赛场两眼一摸黑。<br><br><p><code>mkdir</code>：创建文件夹。</p><p><code>touch</code>：创建文件。</p><p><code>cd</code>：切换目录。</p><p><code>ls</code>：列出当前文件夹下的内容。</p><p><code>cat</code>：显示文件内容，而且是全部显示。</p><p><code>more</code>：查看文件内容，但是翻页查看。</p><p><code>cp [-r] [被复制] [复制到哪]</code>：复制文件文件夹，参数<code>-r</code>可以复制文件夹。</p><p><code>mv [被移动] [目的地]</code>：移动文件文件夹。</p><p><code>rm [-r -f] [参数1......参数n]</code>：删除文件，<code>-r</code>删除文件夹，<code>-f</code>强制删除。</p></div>

    <div class="t1"><p>对拍时使用<code>rand()</code>函数生成伪随机数的方法。</p><p>头文件是<code>#include &lt;cstdlib&gt;</code></p>接下来是代码：
        <pre>
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cstdlib&gt;

int getRand(int min, int max) {
    return (rand() % (max - min + 1)) + min;
}

int main() {
    srand(time(0)); // 使用当前时间作为种子
    for (int i = 0; i &lt; 10; i++) {
        int r = getRand(2, 20); // 生成2到20之间的随机整数
        std::cout &lt;&lt; r &lt;&lt; std::endl;
    }
    return 0;
}
        </pre>
        建议写一个自己的解题代码，再写一个暴力的代码，之后再写一个随机数生成数据的代码。<br><br>即，用随机数生成数据，然后用暴力算法测试数据答案，最后用自己的解题代码测试答案与暴力解法是否相等，如果不相等，说明代码存在漏洞。
    </div>
    
    <div class="t1"><b>别忘了加上文件读写。</b><p>文件读写的头文件是<code>#include &lt;cstdio&gt;</code>。</p>开头加上这句<code>freopen("demo.in","r",stdin);<br>freopen("demo.out","w",stdout);</code>否则等着爆0。<br>结尾建议加上这句<code>fclose(stdin);<br>fclose(stdout);</code></div>

    <div class="t1">调试的那些打印语句别忘了注释掉！否则0分等着你！</div>
    <div class="t1">
        二维数组求“最大连续子矩阵和”的解法：<br><br>
        <b>暴力解法：</b>6层循环即可，外两层是左上角，中间两层是右下角，内两层是枚举累加左上到右下的和。<br><br>
        <b>优化解法1：一维前缀和优化</b>
        跟一维数组求“最大连续子区间”的优化解法是一样的，只不过把<code>w[i]=w[i-1]+a[i];</code>改成了<code>w[i][j]=w[i][j-1]+a[i][j]</code>然后对循环以及部分内容稍微改动就完事了。<br><br>
        <b>优化解法2：二维前缀和优化</b>
        <pre>
#include &lt;iostream&gt;
using namespace std;
int n,a[10001][10001],w[10001][10001],maxn=-0x3f3f3f3f;
//maxn建议赋值为负数，因为矩阵当中可能会出现负的数。
int main()
{
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=n;j++)
        {
            cin&gt;&gt;a[i][j];
            w[i][j]=w[i-1][j]+w[i][j-1]+a[i][j]-w[i-1][j-1];
        }
    }
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=n;j++)
        {//------枚举左上角--------

            for(int k=i;k&lt;=n;k++)
            {
                for(int t=j;t&lt;=n;t++)
                {//--------枚举右下角---------

                    int sum=w[k][t]-w[k][j-1]-w[i-1][t]+w[i-1][j-1];
                    maxn=maxn&gt;sum?maxn:sum;

                }
            }

        }
    }
    cout&lt;&lt;maxn&lt;&lt;endl;
    return 0;
}
        </pre>
        图解：
        <img src="https://upload-bbs.miyoushe.com/upload/2024/09/30/198629752/bbf70b405981e8ae02468e701a216a77_3706323876176022470.png" alt="矩阵图解">如图，我们的二维前缀和优化相当于求(i-1,j-1)到(k,t)之间的前缀和。也就是我用红色线条画的那部分。那么那部分的前缀和sum就等于我用w[k][t]减去(区1+区2+区3)的前缀和，那么公式也就是<code>sum=w[k][t]-(w[k][j-1]-w[i-1][j-1])+(w[i-1][t]-w[i-1][j-1])+w[i-1][j-1];</code>最后化简后就成了这样子：<code>sum=w[k][t]-w[k][j-1]-w[i-1][t]+w[i-1][j-1];</code><br><p>*这也就是<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1282">1282：最大子矩阵</a>的解法</p>（这道题妥妥模板题。我还硬啃了2小时，艹！）
    </div>

    <div class="t1">
        一维数组求“最大连续子序列和”的解法：
        <br><b>优化解法1：（递推）</b>
        <pre>
#include &lt;iostream&gt;
using namespace std;
int n,a[10001],maxn;
int main()
{
    cin&gt;n;
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;a[i];
    }
    //-----------------------
    for(int i=1;i&lt;=n;i++)
    {
        int sum=0;
        for(int j=i;j&lt;=n;j++)
        {
            sum+=a[j];
            maxn=sum&gt;maxn?sum:maxn;
        }
    }
    //----------------------
    cout&lt;&lt;maxn&lt;&lt;endl;
    return 0;
}
    </pre>
    两个注释线夹着的循环可以改为这种写法：（最朴素的解法）
    <pre>
for(int i=1;i<=n;i++)
{
    for(int j=i;j<=n;j++)
    {
        int sum=0;
        for(int k=i;k<=j;k++)
        {
            sum+=a[k];
        }
        maxn=sum>maxn?sum:maxn;
    }
}
    </pre>
    这两种是等价的，但前者能少一个循环。
    <br><b>优化解法2：利用前缀和求区间和</b>
    <pre>
#include &lt;iostream&gt;
using namespace std;
int n,a[10001],maxn,w[10001];
int main()
{
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;a[i];
        w[i]=w[i-1]+a[i];
    }
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=i;j&lt;=n;j++)
        {
            maxn=maxn&gt;(w[j]-w[i-1])?maxn:(w[j]-w[i-1]);
        }
    }
    cout&lt;&lt;maxn&lt;&lt;endl;
    return 0;
}
    </pre>
    这里用w数组在输入的时候就顺带把前缀和全都求出来了，然后要求出某个区间的前缀和，那就用区间的右端点的前缀和与左端点的前缀和相加就能得到答案。(但要注意左端点的头也得算在内，要i-1)。如图解：
    <img src="https://upload-bbs.miyoushe.com/upload/2024/09/30/198629752/175dac2c567043cd0c76c462fa3e903c_1093202781834302723.png" alt="区间图解">
    <br>
    一维和二维的处理方式有点不一样，见参考：<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1282">1282：最大子矩阵</a>
    </div>

    <div class="t1"><b>二维前缀和的计算方法</b><br>在二维数组中，我们首先定义一个同等大小的二维数组dp，其中dp[i][j]表示从原数组左上角(1,1)到(i,j)形成的子矩阵的元素和。计算dp[i][j]的状态转移方程如下：
<code>dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + arr[i][j];</code>
    <b>*即，自身前缀和=左+上+自身-左上。</b>
    </div>

    <div class="t1">动态规划+最优路径典中典的题目，这道题实在是太典了，建议记住。<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1266">1266：【例9.10】机器分配</a>
    <pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
using namespace std;
int n,m;
int a[10001][10001];
int dp[10001][10001];
int vis[10001][10001];
void print(int x,int y)
{
    if(x==0)return;
    print(x-1,y-vis[x][y]);
    cout&lt;&lt;x&lt;&lt;" "&lt;&lt;vis[x][y]&lt;&lt;endl;
}
int main()
{
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=m;j++)
        {
            cin&gt;&gt;a[i][j];
        }
    }
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=m;j++)
        {
            for(int k=0;k&lt;=j;k++)
            {
                if(dp[i-1][j-k]+a[i][k]&gt;=dp[i][j])
                {
                    dp[i][j]=dp[i-1][j-k]+a[i][k];
                    vis[i][j]=k;
                }
            }
        }
    }
    cout&lt;&lt;dp[n][m]&lt;&lt;endl;
    print(n,m);
    return 0;
}
    </pre>
    这是一个三重循环的动态规划，i外层代表当前公司，j代表要选的机器数，k代表还剩几台机器能够选。最后vis[i][j]记录公司选的机器数k，然后递归打印公司x和机器数vis[x][y]。
    </div>

    <div class="t1">模版题：<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1265">1265：【例9.9】最长公共子序列</a>
        <pre>
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;
using namespace std;
string a,b;
int dp[1001][1001];
int main()
{
    cin&gt;&gt;a&gt;&gt;b;
    int n=a.size(),m=b.size();
    a=' '+a;
    b=' '+b;
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=m;j++)
        {
            if(a[i]==b[j])
            {
                dp[i][j]+=dp[i-1][j-1]+1;
            }
            else
            {
                dp[i][j]=max(dp[i][j-1],dp[i-1][j]);
            }
        }
    }
    cout&lt;&lt;dp[n][m];
    return 0;
}
        </pre>
        建议直接背会。dp[i][j]的意思是，i的前面和j的前面有多少公共的部分，如果a[i]==b[j]，那么dp[i][j]+=dp[i-1][j-1]+1，那如果不相等，就继承i与j前面最大的公共部分。
    </div>

    <div class="t1">字符类型数组，一个字符占1byte大小，八位。实际上，能开的最大长度是2146793727。<code>char s[2146793727];</code><br>字符串类型数组，一个字符串能存储4049个字符（多了会卡死），但字符串类型的数组最大长度为268349215<code>string b[268349215];</code><br>int 类型数组，一个int类型的变量占4个字节，是字符的四倍，所以int类型数组的最大长度大概是字符类型的四分之一，为536698431<code>int a[536698431];</code><br>long long类型数组，一个long long类型的变量占8个字节，所以longlong类型数组的最大长度大概是268349215<code>long long c[268349215];</code><br>浮点数，float和double类型的变量就像是int和longlong，而数组最大长度也分别和int和longlong相同，为536698431和268349215<code>float e[536698431];<br>double f[268349215];</code><br>布尔类型，布尔类型的变量也只占一个字节，所以数组最大长度和char一样为2146793727<code>bool d[2146793727];</code><br>*以上总结的各类型数组最大长度仅为最大能编译的长度</div>

    <div class="t1">动态规划最短路径问题<br><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1261">1261：【例9.5】城市交通路网</a>这道题是一道经典dp，建议烂熟于心。<img src="https://upload-bbs.miyoushe.com/upload/2024/09/29/198629752/513612dea4e03294e7f64b38ffd8f2a4_456798892526461554.png" alt="城市交通路网"><br><code>memset(arr,0x3f,sizeof(arr));</code>memset用0x3f初始化数组代表无穷大，因为memset函数初始化特点是按字节去逐个初始化。</div>

    <div class="t1">最长上升子序列（LIS）<br><br>最长不下降子序列（LNDS）<br><br>最长下降子序列（LDS）<br><br>最长不上升子序列（LNIS）</div>

    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1091">P1091 [NOIP2004 提高组] 合唱队形</a>这道题是一道令人迷惑的题目，我做了2次，错了2次，而且全错，0分。不说了，代码放这了，自己看吧，啥时候忘了啥时候回来瞅一眼。
        <pre>
#include &lt;iostream&gt;
using namespace std;
int n,a[10001],up[10001],down[10001];
int main()
{
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;a[i];
        up[i]=1;down[i]=1;
    }
    for(int i=2;i&lt;=n;i++)
    {
        for(int j=1;j&lt;i;j++)
        {
            if(a[i]&gt;a[j]){up[i]=max(up[i],up[j]+1);}
        }
    }
    //这两个循环不等价，当时我还不信，硬是写一块去，结果WA了4个点。
    for(int i=n-1;i&gt;=1;i--)
    {
        for(int j=i+1;j&lt;=n;j++)
        {
            if(a[i]&gt;a[j]){down[i]=max(down[i],down[j]+1);}
        }
    }
    int ans=-0x3f3f3f3f;
    for(int i=1;i&lt;=n;i++)
    {
        ans=max(ans,up[i]+down[i]-1);
    }
    cout&lt;&lt;n-ans&lt;&lt;endl;
    return 0;
}
        </pre>
    </div>

    <div class="t1"><p>对于<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1283">1283：登山</a>这道题目我真是服了，</p><img src="https://upload-bbs.miyoushe.com/upload/2024/09/30/198629752/4d6f33c3b441e2a2080df38abe0eec24_6549954258408915795.png" alt="登山">就是这句具有迷惑性的话，直接让我0分。让我们来思考一下这句话的含义，首先不能连续爬相同的山，那么我们会很容易想到他下山的时候有没有可能会爬相同的山？那是不是就是非严格单调子序列？其实不是，我们反证法可以得出，如果他经过了2个相同高度的山，那么分2种情况，一种是在爬山(或下山)过程中经过的，很显然根据题目可知不会有这种情况。那么另外一种就是一个在爬的过程中经过一遍，一个在下山过程中经过一遍，但又由于，上山属于单调增，下山属于单调减，因此这种情况完全可以忽略不计，因为他们根本不可能同时在一个严格单调序列里面。<p>因此这道题就是<a href="https://www.luogu.com.cn/problem/P1091">P1091 [NOIP2004 提高组] 合唱队形</a>的变形，只不过最终的答案不再是n-ans，而是直接输出ans，其他都不需要改。也就是说这就转化成了一个数学证明题：求证同时经过两座山并且还得同时位于一个单调序列种的情况不可能出现。</p></div>

    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1260">1260：【例9.4】拦截导弹(Noip1999)</a>这道题目是典型的求 最长不上升子序列 和 最长下降子序列 的题目，具体代码如下：<img src="https://upload-bbs.miyoushe.com/upload/2024/09/29/198629752/f9380e628310dba1074bde3f982cc994_4117213231434843130.png" alt="拦截导弹"><br>当时错了好几遍都没过，致错原因还是太理所当然的认为是暴力求解，但其实由题意可得，答案是求最长不上升子序列和最长下降子序列。<br><br>这是一个代码模板，要求背会。考试能保证类似的题能拿一半的分。<br><br><a href="https://www.luogu.com.cn/problem/P1020">P1020 [NOIP1999 提高组] 导弹拦截</a>洛谷的这道题是升级版。<br>对于最小划分数有：<br>不升子序列：lower_bound<br>不降子序列：upper_bound<br>严格上升子序列：对所有数取相反数，upper_bound<br>严格下降子序列：对所有数取相反数，lower_bound<br><pre><b style="color: rgb(51, 255, 0);">Dilworth 定理</b><br>原链最长长度=反链划分数最小值：<br><br>上升子序列⇔不升子序列<br>下降子序列⇔不降子序列<br><br>*如果定理不会用(或没把握)，那就返璞归真，用最朴素的解法求答案。</pre><br>题解如下：<img src="https://upload-bbs.miyoushe.com/upload/2024/09/29/198629752/c9a4c200879f825f3558433fcff69c1d_5668380233911982326.png" alt="迪尔沃斯定理"></div>

    <div class="t1">题目都说了最大上升，上升，怎么能写成小于等于？应该是严格递增的呀。</div>

    <div class="t1">如果用scanf读入字符串不方便，害怕出错，那么就写stread()，即字符串快读，写法与数字快读同理。<br>
        <pre>
<span class="">string</span> <span>stread()</span>
<span>{</span>
    <span>string</span> <span>s</span>;<span>char</span> <span>ch</span>=<span>getchar()</span>;</span>
    &nbsp;&nbsp;<span>while</span><span>(</span><span>ch</span>&lt;<span>'a'</span>&&<span>ch</span>&gt;<span>'z'</span>||<span>ch</span>&lt;<span>'A'</span>&&<span>ch</span>&gt;<span>'Z'</span>||<span>ch</span>&lt;<span>'0'</span>&&<span>ch</span>&gt;<span>'9'</span><span>)</span><span>{</span><span>ch</span>=<span>getchar()</span>;<span>}</span></span>
    &nbsp;&nbsp;<span>while</span><span>(</span><span>ch</span>&gt;=<span>'a'</span>&&<span>ch</span>&lt;=<span>'z'</span>||<span>ch</span>&gt;=<span>'A'</span>&&<span>ch</span>&lt;=<span>'Z'</span>||<span>ch</span>&gt;=<span>'0'</span>&&<span>ch</span>&lt;=<span>'9'</span><span>)</span><span>{</span><span>s</span>+=<span>ch</span>;<span>ch</span>=<span>getchar()</span>;<span>}</span>
    <span>return</span> <span>s</span><span>;</span>
<span>}</span>
        </pre>
    </div>
    <div class="t1">字符串用scanf读入时，如果有空格，那么可能会出现一些棘手的问题。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;头文件&lt;string&gt;，用于定义string类型。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;头文件&lt;cstring&gt;，里面包含了字符串的相关函数，比如strlen()、strcpy()、fgets()、sscanf()。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;输入结束时getchar()会返回EOF，即End Of File。控制台中可以使用(Windows)Ctrl+Z或者(Linux)Ctrl+D来输入EOF表示输入结束。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;string类型的字符串可以直接进行比较，比较是按照字典序进行的。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;fgets()来读入一行字符串并存入字符数组中，而gets()有溢出的风险所以不使用。<code>fgets(s,sizeof(s),stdin);</code>这条语句制定了字符数组的最大读入数量，因此是安全的。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;sscanf()和scanf()是很接近的。比如，<code>sscanf(s,"%d",&a);</code>就可以从s字符串中读入一个整数a。他们的区别是，scanf()是从标准输入中读入，而sscanf()是从给定的一个字符串中读入，所以要求提供字符数组的名称，表示从哪个字符串里面读入信息。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;同理，<code>sprintf(s,"%d",a);</code>就可以将一个int类型的数a输出到字符串s中而不是标准输出。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;s.substr(pos,len)：截取字符串s，从第pos个位置开始len个字符，并返回这个字符串。<br>&nbsp;&nbsp;&nbsp;&nbsp;s.insert(pos,str)：在字符串s的第pos个字符之前，插入字符串str，并返回这个字符串。<br>&nbsp;&nbsp;&nbsp;&nbsp;s.find(str,[pos])：在字符串s中从第pos个字符开始寻找str，并返回位置，如果找不到返回-1。pos可以省略，默认值是0；<br>&nbsp;&nbsp;&nbsp;&nbsp;*要注意的是find函数查找子串但是找不到时，它会返回一个常量string::npos，但是由于它不一定是一个int类型的常量，因此要强制转换成int类型才能直接输出-1。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;另外还要注意字符串能赋值一个常量，但不能像下面这样赋值↓
        <pre>

<span><span>string</span> <span>a</span>,<span>b</span>;</span>
<span><span>a</span>=<span>"LUOGU"</span>;</span>
<span><span>b</span>=<span>a</span>;<span><span>//这一步是错误操作</span></span></span>
        </pre>
    </div>

    <div class="t1">公式：[1,n]的约数中有p的数的个数为[n/p]<br><br>&nbsp;&nbsp;&nbsp;&nbsp;*(其中[]表示向下取整)。<br><br>当p很大时，在一个区间范围内，[n/pi]保持不变，因此遍历时可以直接从pi跳到pj，其中pj=[n/(n/pi)]+1，区间长度为j-i。
<pre>

<span>#include</span> <span>&lt;iostream&gt</span>;
<span>using</span> <span>namespace</span> <span>std</span>;
<span>#define</span> <span>LL</span> <span>long long</span>
<span>LL</span> <span>ans</span>,<span>n</span>;
<span>int</span> <span>main()</span>
<span>{</span>
    cin>><span>n</span>;
    <span>for</span>(</span><span>LL</span> <span>i</span>=1,<span>j</span>;<span>i</span>&lt;=<span>n</span>;<span>i</span>=<span>j</span>)
    <span>{</span>
        <span>j</span>=<span>n</span>/<span>(</span><span>n</span>/<span>i</span><span>)</span>+<span>1</span>;
        <span>ans</span>+=<span>(</span><span>n</span>/<span>i</span><span>)</span>*<span>(</span><span>j</span>-<span>i</span><span>)</span>;
    <span>}</span>
    cout&lt;&lt;<span>ans</span>;
    <span>return</span> 0;
<span>}</span>

</pre>
    </div>
    <div class="t1"><img src="https://upload-bbs.miyoushe.com/upload/2024/09/29/198629752/09f0aab8de6e5cc0db270c73e691dab6_9079656361092462373.png" alt="时间复杂度">应尽量避免除法运算。还有循环如果能用while就用while。</div>
    <div class="t1">如果遇到10^6这样的大数据，能写快读就写快读。</div>
    <div class="t1">cin读取数字时可以把数字的符号一起读进去，也就是说，当你要读入一个数字表达式，那么可以直接用cin读入，连数字的正负判断都省了。</div>
    <div class="t1">补全程序当中遇到图论代码，如果遇到不认识的数组，就往“点”、“入度”、“出度”、“权值”上想，再偏也不会跑出这个考试范围。</div>
    <div class="t1">注意数据范围，要开 long long 的千万不要忘了开，否则只能拿一半的分！</div>
    <div class="t1">浮点数转整形会丧失精度，要看好代码中的类型转换以及是否出现了，函数要求传入int类型然而却传入了浮点类型。</div>
    <div class="t1">"7/sqrt(3)/2"和"7/2/sqrt(3)"不一样，前者会先变成浮点数再除以二，相比于后者精度更精确，二者存在明显的精度误差。</div>
    <div class="t1">b=a*q则，b是a的倍数，a是b的约数。</div>
    <div class="t1">由数字
        1,1,2,4,8,8 所组成的不同的 
        4 位数的个数是（）。<br><br>解：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;情况1：无重复的数字，1、2、4、8一共4个数字放在4个位置，：4×3×2=24<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;情况2：仅重复1，两个1，两个1的组合是6种：11xx,1x1x,1xx1,x11x,x1x1,xx11，两个x位置放3个不重复的数字，共3×2=6种，6×6=36种<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;情况3：仅重复8，两个8，同上，一共6×6=36种<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;情况4：重复两对，两个1和两个8。11xx,1x1x,1xx1,x11x,x1x1,xx11，一共6种。</div>
    <div class="t1">一些数字可以颠倒过来看，例如
        0,1,8 颠倒过来还是本身，
        6 颠倒过来是 
        9,9 颠倒过来看还是 
        6,其他数字颠倒过来都不构成数字。类似的，一些多位数也可以颠倒过来看，比如
        106 颠倒过来是
        901。假设某个城市的车牌只有 
        5 位数字，每一位都可以取 
        0 到 
        9。请问这个城市有多少个车牌倒过来恰好还是原来的车牌，并且车牌上的 
        5 位数能被 
        3 整除？（）<br><br>解：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第1、2位有（0、1、8、6、9）五个数字，第3位有（0、1、8）三个数字，第4、5位由第1、2位决定。由于0,1,8模3正好余0,1,2，所以其他位确定则第3位自然确定，共5*5=25种。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;举例：第1位选1，第5位必然是1；第2位选0，第4位必然是0；为能被3整除，第3位只能选8。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第1位可选5个数字，第2位也可选5个数字。5*5=25种。<br><br><p style="color: rgb(232, 0, 0);background-color: rgb(254, 241, 0);">注: 是车牌，车牌第一位可以是0</p></div>
    <div class="t1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果一个数的所有数字之和能被3整除，则这个数能被3整除。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果一个数的个位为0或5，则这个数能被5整除。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果一个数的所有数字之和能被9整除，则这个数能被9整除。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果一个数所有奇数位的数字相加减去所有偶数位的数字后的值能被11整除，那么这个数能被11整除。</div>
    <div class="t1">G是一个非连通无向图(没有重边和自环)，共有28条边，则该图至少有(  )个顶点。<br><br>解：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最优情况下是8个顶点的完全图，外加1个孤立顶点。即共有9个顶点。<img src="https://upload-bbs.miyoushe.com/upload/2024/09/23/198629752/de892d9f522b3dbd49e60532b643533c_4417491289934517107.png" alt="8个顶点的完全图">最后的边数就是1+2+3+4+5+6+7+8=28。</div>
    <div class="t1">在写并查集的代码时，并查集的初始化f[i]=i,其中i∈[a,b],则输入的一对节点(x,y)也应该在[a,b]范围内。因为如果超出这个范围，x的父节点会被默认指向为0或其他未知数字。</div>
    <div class="t1">没有路径压缩的并查集时间复杂度为线性的O(n),路径压缩后的为O(1)。</div>
    <div class="t1">如要补充，请联系管理员......</div>
    <div class="t1">如要补充，请联系管理员......</div>
    <div class="t1">如要补充，请联系管理员......</div>
    <div class="t1">如要补充，请联系管理员......</div>
    <div class="t1">如要补充，请联系管理员......</div>
    <div class="t1">如要补充，请联系管理员......</div>
    <div class="t1">如要补充，请联系管理员......</div>
    <div class="t1">如要补充，请联系管理员......</div>
    <div class="t1">如要补充，请联系管理员......</div>
    <div class="t1">如要补充，请联系管理员......</div>
    <div class="t1">如要补充，请联系管理员......</div>
    <div class="t1">如要补充，请联系管理员......</div>
    <div class="t1">如要补充，请联系管理员......</div>
    <div class="t1">如要补充，请联系管理员......</div>
    <div class="t1">如要补充，请联系管理员......</div>
    <div class="t1">如要补充，请联系管理员......</div>
    <!--  -->
    <!--  -->
    <!--  -->
</body>
<script src="./CanvasFor_index.js"></script>
<!-- <script src="./Canvas2.js"></script> -->
<script src="./Volume.js"></script>
<script src="./Unit.js"></script>
<script src="./ChangSpanColor.js"></script>
</html>