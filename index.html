<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <link rel="apple-touch-icon" href="../../../sqhgxsq/next/Material/logo.png">
    <link rel="icon" href="https://ys.mihoyo.com/main/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="https://ys.mihoyo.com/main/favicon.ico" type="image/x-icon">
    <meta name="renderer" content="webkit">
    <meta property="og:image" content="https://fastcdn.mihoyo.com/static-resource-v2/2023/12/20/e04bc0be964b4fc7056bc1128b35f200_4546122273706382871.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="keywords" content="OIer的错题集,ESC,ESC.html">
    <meta name="description" content="OIer的错题集,ESC,ESC.html">

    <!-- bing sitmap system -->
    <meta name="msvalidate.01" content="E636B33C63F884A1E40D913638E2424B" />
    <!--  -->

    <title>错题集</title>

    <link rel="stylesheet" href="style.css">

    <!--  -->
    <style>
        @media screen and (max-width:900px) {
            .bg1{
        background-image: url("https://act-webstatic.mihoyo.com/event-static/2024/06/24/570fc67f4b580da77f9af206eb3bc0a5_7858946434453008095.jpg?x-oss-process=image/quality,Q_80/resize,m_lfit,s_700");
            }
        }
        @media screen and (min-width:901px){
            .bg1{
        background-image: url("https://act-webstatic.mihoyo.com/event-static/2024/06/24/94fe58803161e06dd1e2fcea8ba56a41_8214787202754590749.png?x-oss-process=image/quality,Q_80/resize,m_lfit,s_700");
    }
        }
    </style>
    <!--  -->
</head>
<body>
    <header id="_header">
        <!-- <div class="ph" id="h_1" onclick="window.open('./index.html')">
            NOI
        </div> -->
        <!-- <div class="ph" id="h_2" onclick="window.open('./PH.html')">
            物理
        </div> -->
        <!-- <div class="ph" id="h_3" onclick="window.open('./CM.html')">
            化学
        </div> -->
        <!-- <div class="ph" id="h_4" onclick="window.open('./BO.html')">
            生物
        </div> -->
        <!-- <div class="ph" id="h_5" onclick="window.open('https://oi-wiki.org/')">
            OIWiki
        </div> -->
    </header>
    
    <!--  -->
    <audio src="https://static-mp-54c94446-e6a2-431f-84c4-ed0d181ae263.next.bspapp.com/music/时暮的思眷.mp3" id="dd" autoplay loop style="display: none;"></audio>
    <!--  -->
    <div class="bg1"></div>
    <div class="bg2"></div>
    <div class="bg3"></div>
    <div class="bg4"></div>
    <div class="bg5"></div>
    <div class="bg6"></div>
    <div class="bg7"></div>
    <div class="bg8"></div>
    <!--  -->


    <div class="op">
        <h1>下拉查看OI错题</h1>
    </div>



    <br>
    <h1>错题集</h1>
    <br>
    <hr style="z-index: 1;">
    <br>
    <!--  -->
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1278">1278：【例9.22】复制书稿(book)</a>这这道题很难，当时没做出来，就这样吧。
    <pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
using namespace std;
int m,k,a[1001],s[1001],dp[1001][1001];
void show(int t,int x)
{
    int i;
    int sum=0;
    if(t==0)return;
    for(i=t;i&gt;=1&&sum+a[i]&lt;=x;i--)
    {
        sum+=a[i];
    }
    show(i,x);
    cout&lt;&lt;i+1&lt;&lt;" "&lt;&lt;t&lt;&lt;endl;
}
int main()
{
    cin&gt;&gt;m&gt;&gt;k;
    for(int i=1;i&lt;=m;i++)
    {
        cin&gt;&gt;a[i];
        s[i]=a[i]+s[i-1];
    }
    memset(dp,0x3f,sizeof(dp));
    for(int i=1;i&lt;=m;i++)
    {
        dp[i][1]=s[i];
    }
    for(int i=1;i&lt;=m;i++)
    {//i表示抄写的人数。 
        for(int j=2;j&lt;=k;j++)
        {//前j本书分配给i个人抄写。 
            for(int h=j;h&lt;=i;h++)
            {//最后一个人需要抄写h~i本书。 
                dp[i][j]=min(dp[i][j],max(dp[h-1][j-1],s[i]-s[h-1]));
            }
        }
    }
    show(m,dp[m][k]);
    return 0;
}
</pre>
</div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1004">P1004 [NOIP2000 提高组] 方格取数</a>因为是2个人走，所以要用4维数组，dp[i][j][k][p]，ij表示第一个人走的，kp表示第二个人走的。
    <pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
using namespace std;
#define LL long long
LL n,a[40][40],ans,dp[11][11][11][11];
void print()
{
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=n;j++)
        {
            cout&lt;&lt;a[i][j]&lt;&lt;" ";
        }cout&lt;&lt;endl;
    }cout&lt;&lt;endl;
}
LL max(LL a,LL b)
{
    return a&gt;b?a:b;
}
void f()
{
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=n;j++)
        {
            for(int k=1;k&lt;=n;k++)
            {
                for(int p=1;p&lt;=n;p++)
                {
                    dp[i][j][k][p]=max(dp[i-1][j][k-1][p],max(dp[i][j-1][k][p-1],max(dp[i-1][j][k][p-1],dp[i][j-1][k-1][p])))+a[i][j];
                    if(i!=k&&j!=p)<span>//如果第一个人没走过，那第二个人就走过来。</span>
                    {
                        dp[i][j][k][p]+=a[k][p];
                    }	
                }
            }
        }
    }
    ans=dp[n][n][n][n];
}
int main()
{
    cin&gt;&gt;n;
    LL x,y,v;
    while(cin&gt;&gt;x&gt;&gt;y&gt;&gt;v&&(x!=0||y!=0||v!=0))
    {
        a[x][y]=v;
    }
    f();
    cout&lt;&lt;ans&lt;&lt;endl;
}
    </pre>当时情况没有考虑周全，导致暴力求解WA了2个点。暴力做法的代码在这里了<a href="https://www.luogu.com.cn/record/179790417">暴力代码</a>
    </div>
    <div class="t1"><a href="https://www.luogu.com.cn/problem/P2758">P2758 编辑距离</a>确定状态，转移方程，注意边界条件。<br>致错原因：未处理边界。
    <pre>
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
using namespace std;
int dp[2001][2001];
string a,b;
int main()
{
    cin&gt;&gt;a&gt;&gt;b;
    a=" "+a;b=" "+b;
    <b style="color: red;">for(int i=1;i&lt;=a.length();i++)
    {<span>//当其中一个串为0时，最小操作次数就是不为零的那个串的长度咯！</span>
        dp[i][0]=i;
    }
    for(int i=1;i&lt;=b.length();i++)
    {
        dp[0][i]=i;
    }</b>
    for(int i=1;i&lt;=a.length();i++)
    {
        for(int j=1;j&lt;=b.length();j++)
        {
            if(a[i]==b[j])dp[i][j]=dp[i-1][j-1];
            else
            {
                <span>//我可以增删改三选一，三选一找最小值。</span>
                dp[i][j]=min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]))+1;
            }
        }
    }
    cout&lt;&lt;dp[a.length()][b.length()]&lt;&lt;endl;
    return 0;
}
    </pre>
    </div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1275">1275：【例9.19】乘积最大</a>像这种动态规划的题目不要用瞪眼法，瞪眼法看不出来的，需要先用小数据枚举，找规律，找状态转移方程。<br>致错原因：区间定义错误。</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1274">1274：【例9.18】合并石子</a>状态转移方程，dp[i][j]表示从第i堆石子到第j堆石子合并的最小价值。</div>
    <div class="t1">二维数组最大开5000*5000，否则可能出现MLE的情况。如果数据范围拿不准，就用vector吧。</div>
    <div class="t1">
        各个数据类型大小(单位字节Byte,B)：<br>short 2<br>int 4<br>long 4<br>long long 8<br>char 1<br>double 8<br><br>1MB=1024kb=1024*1024B。
    </div>
    <div class="t1">循环边界再检查一遍。看看变量名是否与上文重合了。</div>
    <div class="t1">有些题目需要对某些情况特判。</div>
    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1293">1293：买书</a>错误原因：没有看清条件。</div>
    <div class="t1">
        <a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1296">1296：开餐馆</a>
        致错原因：ans最大值更新时放在了if语句内，导致更新失败而爆0。
        <pre>
int ans=dp[1];
for(int i=1;i&lt;=n;i++)
{
    for(int j=1;j&lt;i;j++)
    {
        if(m[i]-m[j]&gt;k)
        {
            dp[i]=max(dp[i],dp[j]+p[i]);
        }
        <b style="color: red;">ans=max(ans,dp[i]);</b>//&lt;------- 应该是在这，之前写到上边括号里头了。
    }
}
cout&lt;&lt;ans&lt;&lt;endl;
        </pre>
    </div>
    <div class="t1">经常忘记题目叫输出的是啥，比如叫你求最大值，而且输出格式是“max=最大值”，结果我只输出了最大值，那么全0分。</div>

    <div class="t1">01背包：每种物品只选一次。(逆推)<code>二维：dp[i][j]=max(dp[i-1][j],dp<b style="color: rgb(255, 79, 188);">[i-1]</b>[j-w[i]]+c[i])<br>一维：dp[j]=max(dp[j],dp[j-w[i]]+c[i])</code><br>完全背包：每种物品数量无限。(顺推)<code><p>二维：dp[i][j]=max(dp[i-1][j],dp<b style="color: rgb(255, 79, 188);">[i]</b>[j-w[i]]+c[i])<br>一维：dp[j]=max(dp[j],dp[j-w[i]]+c[i]);</p></code><br>多重背包：每种物品数量有限。(二维可顺可逆，一维要逆推)<br><code><p>二维：dp[i][j]=max(dp[i][j],dp<b style="color: rgb(255, 79, 188);">[i-1]</b>[j-k*w[i]]+k*c[i]);<br>一维：dp[j]=max(dp[j],dp[j-k*v[i]]+k*w[i]);</p></code></p><br>混合背包：遍历物品的时候加个判断就好，物品只有一个那就是01背包，无限就是完全背包，有穷就是多重背包。其他都不变。<br><br>二维费用问题：普通背包的基础上再加一个状态就好，状态的最小值设为0或1。<br><br>分组背包：普通背包问题的基础上最内层多加一个遍历每组的物品个数就好了，可以用vector储存每组的物品信息。<br><br>有依赖的背包问题：需要建树。<br><br>背包问题的方案总数：递推，f[0]=1，普通背包基础上，往下推即可。<br><br>**01背包dp[i][j]的意思是，考虑前i个物品且背包容量为j的情况下能够获得的最大价值。当优化成一维dp[i]时，表示考虑前i件物品能达到的最大价值。<br>**完全背包：含义与01背包相同，只不过第i种物品可以取无数次。<br><br>*背包的数组优化，仅仅在空间上进行了优化。</div>

    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1271">1271：【例9.15】潜水员</a>二维费用问题的典型题目，代码如下：
        <pre>
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
using namespace std;
int m,n,s,a[1001],b[1001],c[1001],dp[1001][1001];
int main()
{
    cin&gt;&gt;m&gt;&gt;n&gt;&gt;s;
    for(int i=1;i&lt;=s;i++)
    {
        cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i];
    }
    memset(dp,0x3f,sizeof(dp));
    dp[0][0]=0;//都不放的时候就是0。 
    for(int i=1;i&lt;=s;i++)
    {
        for(int j=m;j&gt;=0;j--)
        {//枚举氧气 
            for(int k=n;k&gt;=0;k--)
            {//枚举氮气 
                //氧气限度不能低于0，如果低于0代表超了。 
                dp[j][k]=min(dp[j][k],dp[max(0,j-a[i])][max(0,k-b[i])]+c[i]);
            }
        }
    }
    cout&lt;&lt;dp[m][n]&lt;&lt;endl;
    return 0;
}
        </pre>
    </div>

    <div class="t1">Linux主要命令，一定要熟练掌握，否则赛场两眼一摸黑。<br><br><p><code>mkdir</code>：创建文件夹。</p><p><code>touch</code>：创建文件。</p><p><code>cd</code>：切换目录。</p><p><code>ls</code>：列出当前文件夹下的内容。</p><p><code>cat</code>：显示文件内容，而且是全部显示。</p><p><code>more</code>：查看文件内容，但是翻页查看。</p><p><code>cp [-r] [被复制] [复制到哪]</code>：复制文件文件夹，参数<code>-r</code>可以复制文件夹。</p><p><code>mv [被移动] [目的地]</code>：移动文件文件夹。</p><p><code>rm [-r -f] [参数1......参数n]</code>：删除文件，<code>-r</code>删除文件夹，<code>-f</code>强制删除。</p></div>

    <div class="t1"><p>对拍时使用<code>rand()</code>函数生成伪随机数的方法。</p><p>头文件是<code>#include &lt;cstdlib&gt;</code></p>接下来是代码：
        <pre>
#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cstdlib&gt;

int getRand(int min, int max) {
    return (rand() % (max - min + 1)) + min;
}

int main() {
    srand(time(0)); // 使用当前时间作为种子
    for (int i = 0; i &lt; 10; i++) {
        int r = getRand(2, 20); // 生成2到20之间的随机整数
        std::cout &lt;&lt; r &lt;&lt; std::endl;
    }
    return 0;
}
        </pre>
        建议写一个自己的解题代码，再写一个暴力的代码，之后再写一个随机数生成数据的代码。<br><br>即，用随机数生成数据，然后用暴力算法测试数据答案，最后用自己的解题代码测试答案与暴力解法是否相等，如果不相等，说明代码存在漏洞。
    </div>
    
    <div class="t1"><b>别忘了加上文件读写。</b><p>文件读写的头文件是<code>#include &lt;cstdio&gt;</code>。</p>开头加上这句<code>freopen("demo.in","r",stdin);<br>freopen("demo.out","w",stdout);</code>否则等着爆0。<br>结尾建议加上这句<code>fclose(stdin);<br>fclose(stdout);</code></div>

    <div class="t1">调试的那些打印语句别忘了注释掉！否则0分等着你！</div>
    <div class="t1">
        二维数组求“最大连续子矩阵和”的解法：<br><br>
        <b>暴力解法：</b>6层循环即可，外两层是左上角，中间两层是右下角，内两层是枚举累加左上到右下的和。<br><br>
        <b>优化解法1：一维前缀和优化</b>
        跟一维数组求“最大连续子区间”的优化解法是一样的，只不过把<code>w[i]=w[i-1]+a[i];</code>改成了<code>w[i][j]=w[i][j-1]+a[i][j]</code>然后对循环以及部分内容稍微改动就完事了。<br><br>
        <b>优化解法2：二维前缀和优化</b>
        <pre>
#include &lt;iostream&gt;
using namespace std;
int n,a[10001][10001],w[10001][10001],maxn=-0x3f3f3f3f;
//maxn建议赋值为负数，因为矩阵当中可能会出现负的数。
int main()
{
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=n;j++)
        {
            cin&gt;&gt;a[i][j];
            w[i][j]=w[i-1][j]+w[i][j-1]+a[i][j]-w[i-1][j-1];
        }
    }
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=n;j++)
        {//------枚举左上角--------

            for(int k=i;k&lt;=n;k++)
            {
                for(int t=j;t&lt;=n;t++)
                {//--------枚举右下角---------

                    int sum=w[k][t]-w[k][j-1]-w[i-1][t]+w[i-1][j-1];
                    maxn=maxn&gt;sum?maxn:sum;

                }
            }

        }
    }
    cout&lt;&lt;maxn&lt;&lt;endl;
    return 0;
}
        </pre>
        图解：
        <img src="https://upload-bbs.miyoushe.com/upload/2024/09/30/198629752/bbf70b405981e8ae02468e701a216a77_3706323876176022470.png" alt="矩阵图解">如图，我们的二维前缀和优化相当于求(i-1,j-1)到(k,t)之间的前缀和。也就是我用红色线条画的那部分。那么那部分的前缀和sum就等于我用w[k][t]减去(区1+区2+区3)的前缀和，那么公式也就是<code>sum=w[k][t]-(w[k][j-1]-w[i-1][j-1])+(w[i-1][t]-w[i-1][j-1])+w[i-1][j-1];</code>最后化简后就成了这样子：<code>sum=w[k][t]-w[k][j-1]-w[i-1][t]+w[i-1][j-1];</code><br><p>*这也就是<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1282">1282：最大子矩阵</a>的解法</p>（这道题妥妥模板题。我还硬啃了2小时，艹！）
    </div>

    <div class="t1">
        一维数组求“最大连续子序列和”的解法：
        <br><b>优化解法1：（递推）</b>
        <pre>
#include &lt;iostream&gt;
using namespace std;
int n,a[10001],maxn;
int main()
{
    cin&gt;n;
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;a[i];
    }
    //-----------------------
    for(int i=1;i&lt;=n;i++)
    {
        int sum=0;
        for(int j=i;j&lt;=n;j++)
        {
            sum+=a[j];
            maxn=sum&gt;maxn?sum:maxn;
        }
    }
    //----------------------
    cout&lt;&lt;maxn&lt;&lt;endl;
    return 0;
}
    </pre>
    两个注释线夹着的循环可以改为这种写法：（最朴素的解法）
    <pre>
for(int i=1;i<=n;i++)
{
    for(int j=i;j<=n;j++)
    {
        int sum=0;
        for(int k=i;k<=j;k++)
        {
            sum+=a[k];
        }
        maxn=sum>maxn?sum:maxn;
    }
}
    </pre>
    这两种是等价的，但前者能少一个循环。
    <br><b>优化解法2：利用前缀和求区间和</b>
    <pre>
#include &lt;iostream&gt;
using namespace std;
int n,a[10001],maxn,w[10001];
int main()
{
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;a[i];
        w[i]=w[i-1]+a[i];
    }
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=i;j&lt;=n;j++)
        {
            maxn=maxn&gt;(w[j]-w[i-1])?maxn:(w[j]-w[i-1]);
        }
    }
    cout&lt;&lt;maxn&lt;&lt;endl;
    return 0;
}
    </pre>
    这里用w数组在输入的时候就顺带把前缀和全都求出来了，然后要求出某个区间的前缀和，那就用区间的右端点的前缀和与左端点的前缀和相加就能得到答案。(但要注意左端点的头也得算在内，要i-1)。如图解：
    <img src="https://upload-bbs.miyoushe.com/upload/2024/09/30/198629752/175dac2c567043cd0c76c462fa3e903c_1093202781834302723.png" alt="区间图解">
    <br>
    一维和二维的处理方式有点不一样，见参考：<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1282">1282：最大子矩阵</a>
    </div>

    <div class="t1"><b>二维前缀和的计算方法</b><br>在二维数组中，我们首先定义一个同等大小的二维数组dp，其中dp[i][j]表示从原数组左上角(1,1)到(i,j)形成的子矩阵的元素和。计算dp[i][j]的状态转移方程如下：
<code>dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + arr[i][j];</code>
    <b>*即，自身前缀和=左+上+自身-左上。</b>
    </div>

    <div class="t1">动态规划+最优路径典中典的题目，这道题实在是太典了，建议记住。<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1266">1266：【例9.10】机器分配</a>
    <pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
using namespace std;
int n,m;
int a[10001][10001];
int dp[10001][10001];
int vis[10001][10001];
void print(int x,int y)
{
    if(x==0)return;
    print(x-1,y-vis[x][y]);
    cout&lt;&lt;x&lt;&lt;" "&lt;&lt;vis[x][y]&lt;&lt;endl;
}
int main()
{
    cin&gt;n&gt;m;
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=m;j++)
        {
            cin&gt;a[i][j];
        }
    }
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=m;j++)
        {
            for(int k=0;k&lt;=j;k++)
            {
                if(dp[i-1][j-k]+a[i][k]&gt;=dp[i][j])
                {
                    dp[i][j]=dp[i-1][j-k]+a[i][k];
                    vis[i][j]=k;
                }
            }
        }
    }
    cout&lt;&lt;dp[n][m]&lt;&lt;endl;
    print(n,m);
    return 0;
}
    </pre>
    这是一个三重循环的动态规划，i外层代表当前公司，j代表要选的机器数，k代表还剩几台机器能够选。最后vis[i][j]记录公司选的机器数k，然后递归打印公司x和机器数vis[x][y]。
    </div>

    <div class="t1">模版题：<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1265">1265：【例9.9】最长公共子序列</a>
        <pre>
#include &lt;cstring&gt;
#include &lt;string&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;
using namespace std;
string a,b;
int dp[1001][1001];
int main()
{
    cin&gt;&gt;a&gt;&gt;b;
    int n=a.size(),m=b.size();
    a=' '+a;
    b=' '+b;
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=m;j++)
        {
            if(a[i]==b[j])
            {
                dp[i][j]+=dp[i-1][j-1]+1;
            }
            else
            {
                dp[i][j]=max(dp[i][j-1],dp[i-1][j]);
            }
        }
    }
    cout&lt;&lt;dp[n][m];
    return 0;
}
        </pre>
        建议直接背会。dp[i][j]的意思是，i的前面和j的前面有多少公共的部分，如果a[i]==b[j]，那么dp[i][j]+=dp[i-1][j-1]+1，那如果不相等，就继承i与j前面最大的公共部分。
    </div>

    <div class="t1">字符类型数组，一个字符占1byte大小，八位。实际上，能开的最大长度是2146793727。<code>char s[2146793727];</code><br>字符串类型数组，一个字符串能存储4049个字符（多了会卡死），但字符串类型的数组最大长度为268349215<code>string b[268349215];</code><br>int 类型数组，一个int类型的变量占4个字节，是字符的四倍，所以int类型数组的最大长度大概是字符类型的四分之一，为536698431<code>int a[536698431];</code><br>long long类型数组，一个long long类型的变量占8个字节，所以longlong类型数组的最大长度大概是268349215<code>long long c[268349215];</code><br>浮点数，float和double类型的变量就像是int和longlong，而数组最大长度也分别和int和longlong相同，为536698431和268349215<code>float e[536698431];<br>double f[268349215];</code><br>布尔类型，布尔类型的变量也只占一个字节，所以数组最大长度和char一样为2146793727<code>bool d[2146793727];</code><br>*以上总结的各类型数组最大长度仅为最大能编译的长度</div>

    <div class="t1">动态规划最短路径问题<br><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1261">1261：【例9.5】城市交通路网</a>这道题是一道经典dp，建议烂熟于心。<img src="https://upload-bbs.miyoushe.com/upload/2024/09/29/198629752/513612dea4e03294e7f64b38ffd8f2a4_456798892526461554.png" alt="城市交通路网"><br><code>memset(arr,0x3f,sizeof(arr));</code>memset用0x3f初始化数组代表无穷大，因为memset函数初始化特点是按字节去逐个初始化。</div>

    <div class="t1">最长上升子序列（LIS）<br><br>最长不下降子序列（LNDS）<br><br>最长下降子序列（LDS）<br><br>最长不上升子序列（LNIS）</div>

    <div class="t1"><a href="https://www.luogu.com.cn/problem/P1091">P1091 [NOIP2004 提高组] 合唱队形</a>这道题是一道令人迷惑的题目，我做了2次，错了2次，而且全错，0分。不说了，代码放这了，自己看吧，啥时候忘了啥时候回来瞅一眼。
        <pre>
#include &lt;iostream&gt;
using namespace std;
int n,a[10001],up[10001],down[10001];
int main()
{
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
    {
        cin&gt;&gt;a[i];
        up[i]=1;down[i]=1;
    }
    for(int i=2;i&lt;=n;i++)
    {
        for(int j=1;j&lt;i;j++)
        {
            if(a[i]&gt;a[j]){up[i]=max(up[i],up[j]+1);}
        }
    }
    //这两个循环不等价，当时我还不信，硬是写一块去，结果WA了4个点。
    for(int i=n-1;i&gt;=1;i--)
    {
        for(int j=i+1;j&lt;=n;j++)
        {
            if(a[i]&gt;a[j]){down[i]=max(down[i],down[j]+1);}
        }
    }
    int ans=-0x3f3f3f3f;
    for(int i=1;i&lt;=n;i++)
    {
        ans=max(ans,up[i]+down[i]-1);
    }
    cout&lt;&lt;n-ans&lt;&lt;endl;
    return 0;
}
        </pre>
    </div>

    <div class="t1"><p>对于<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1283">1283：登山</a>这道题目我真是服了，</p><img src="https://upload-bbs.miyoushe.com/upload/2024/09/30/198629752/4d6f33c3b441e2a2080df38abe0eec24_6549954258408915795.png" alt="登山">就是这句具有迷惑性的话，直接让我0分。让我们来思考一下这句话的含义，首先不能连续爬相同的山，那么我们会很容易想到他下山的时候有没有可能会爬相同的山？那是不是就是非严格单调子序列？其实不是，我们反证法可以得出，如果他经过了2个相同高度的山，那么分2种情况，一种是在爬山(或下山)过程中经过的，很显然根据题目可知不会有这种情况。那么另外一种就是一个在爬的过程中经过一遍，一个在下山过程中经过一遍，但又由于，上山属于单调增，下山属于单调减，因此这种情况完全可以忽略不计，因为他们根本不可能同时在一个严格单调序列里面。<p>因此这道题就是<a href="https://www.luogu.com.cn/problem/P1091">P1091 [NOIP2004 提高组] 合唱队形</a>的变形，只不过最终的答案不再是n-ans，而是直接输出ans，其他都不需要改。也就是说这就转化成了一个数学证明题：求证同时经过两座山并且还得同时位于一个单调序列种的情况不可能出现。</p></div>

    <div class="t1"><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1260">1260：【例9.4】拦截导弹(Noip1999)</a>这道题目是典型的求 最长不上升子序列 和 最长下降子序列 的题目，具体代码如下：<img src="https://upload-bbs.miyoushe.com/upload/2024/09/29/198629752/f9380e628310dba1074bde3f982cc994_4117213231434843130.png" alt="拦截导弹"><br>当时错了好几遍都没过，致错原因还是太理所当然的认为是暴力求解，但其实由题意可得，答案是求最长不上升子序列和最长下降子序列。<br><br>这是一个代码模板，要求背会。考试能保证类似的题能拿一半的分。<br><br><a href="https://www.luogu.com.cn/problem/P1020">P1020 [NOIP1999 提高组] 导弹拦截</a>洛谷的这道题是升级版。<br>对于最小划分数有：<br>不升子序列：lower_bound<br>不降子序列：upper_bound<br>严格上升子序列：对所有数取相反数，upper_bound<br>严格下降子序列：对所有数取相反数，lower_bound<br><pre><b style="color: rgb(51, 255, 0);">Dilworth 定理</b><br>原链最长长度=反链划分数最小值：<br><br>上升子序列⇔不升子序列<br>下降子序列⇔不降子序列<br><br>*如果定理不会用(或没把握)，那就返璞归真，用最朴素的解法求答案。</pre><br>题解如下：<img src="https://upload-bbs.miyoushe.com/upload/2024/09/29/198629752/c9a4c200879f825f3558433fcff69c1d_5668380233911982326.png" alt="迪尔沃斯定理"></div>

    <div class="t1">题目都说了最大上升，上升，怎么能写成小于等于？应该是严格递增的呀。</div>

    <div class="t1">如果用scanf读入字符串不方便，害怕出错，那么就写stread()，即字符串快读，写法与数字快读同理。<br>
        <pre>
<span class="">string</span> <span>stread()</span>
<span>{</span>
    <span>string</span> <span>s</span>;<span>char</span> <span>ch</span>=<span>getchar()</span>;</span>
    &nbsp;&nbsp;<span>while</span><span>(</span><span>ch</span>&lt;<span>'a'</span>&&<span>ch</span>&gt;<span>'z'</span>||<span>ch</span>&lt;<span>'A'</span>&&<span>ch</span>&gt;<span>'Z'</span>||<span>ch</span>&lt;<span>'0'</span>&&<span>ch</span>&gt;<span>'9'</span><span>)</span><span>{</span><span>ch</span>=<span>getchar()</span>;<span>}</span></span>
    &nbsp;&nbsp;<span>while</span><span>(</span><span>ch</span>&gt;=<span>'a'</span>&&<span>ch</span>&lt;=<span>'z'</span>||<span>ch</span>&gt;=<span>'A'</span>&&<span>ch</span>&lt;=<span>'Z'</span>||<span>ch</span>&gt;=<span>'0'</span>&&<span>ch</span>&lt;=<span>'9'</span><span>)</span><span>{</span><span>s</span>+=<span>ch</span>;<span>ch</span>=<span>getchar()</span>;<span>}</span>
    <span>return</span> <span>s</span><span>;</span>
<span>}</span>
        </pre>
    </div>
    <div class="t1">字符串用scanf读入时，如果有空格，那么可能会出现一些棘手的问题。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;头文件&lt;string&gt;，用于定义string类型。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;头文件&lt;cstring&gt;，里面包含了字符串的相关函数，比如strlen()、strcpy()、fgets()、sscanf()。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;输入结束时getchar()会返回EOF，即End Of File。控制台中可以使用(Windows)Ctrl+Z或者(Linux)Ctrl+D来输入EOF表示输入结束。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;string类型的字符串可以直接进行比较，比较是按照字典序进行的。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;fgets()来读入一行字符串并存入字符数组中，而gets()有溢出的风险所以不使用。<code>fgets(s,sizeof(s),stdin);</code>这条语句制定了字符数组的最大读入数量，因此是安全的。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;sscanf()和scanf()是很接近的。比如，<code>sscanf(s,"%d",&a);</code>就可以从s字符串中读入一个整数a。他们的区别是，scanf()是从标准输入中读入，而sscanf()是从给定的一个字符串中读入，所以要求提供字符数组的名称，表示从哪个字符串里面读入信息。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;同理，<code>sprintf(s,"%d",a);</code>就可以将一个int类型的数a输出到字符串s中而不是标准输出。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;s.substr(pos,len)：截取字符串s，从第pos个位置开始len个字符，并返回这个字符串。<br>&nbsp;&nbsp;&nbsp;&nbsp;s.insert(pos,str)：在字符串s的第pos个字符之前，插入字符串str，并返回这个字符串。<br>&nbsp;&nbsp;&nbsp;&nbsp;s.find(str,[pos])：在字符串s中从第pos个字符开始寻找str，并返回位置，如果找不到返回-1。pos可以省略，默认值是0；<br>&nbsp;&nbsp;&nbsp;&nbsp;*要注意的是find函数查找子串但是找不到时，它会返回一个常量string::npos，但是由于它不一定是一个int类型的常量，因此要强制转换成int类型才能直接输出-1。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;另外还要注意字符串能赋值一个常量，但不能像下面这样赋值↓
        <pre>

<span><span>string</span> <span>a</span>,<span>b</span>;</span>
<span><span>a</span>=<span>"LUOGU"</span>;</span>
<span><span>b</span>=<span>a</span>;<span><span>//这一步是错误操作</span></span></span>
        </pre>
    </div>

    <div class="t1">公式：[1,n]的约数中有p的数的个数为[n/p]<br><br>&nbsp;&nbsp;&nbsp;&nbsp;*(其中[]表示向下取整)。<br><br>当p很大时，在一个区间范围内，[n/pi]保持不变，因此遍历时可以直接从pi跳到pj，其中pj=[n/(n/pi)]+1，区间长度为j-i。
<pre>

<span>#include</span> <span>&lt;iostream&gt</span>;
<span>using</span> <span>namespace</span> <span>std</span>;
<span>#define</span> <span>LL</span> <span>long long</span>
<span>LL</span> <span>ans</span>,<span>n</span>;
<span>int</span> <span>main()</span>
<span>{</span>
    cin>><span>n</span>;
    <span>for</span>(</span><span>LL</span> <span>i</span>=1,<span>j</span>;<span>i</span>&lt;=<span>n</span>;<span>i</span>=<span>j</span>)
    <span>{</span>
        <span>j</span>=<span>n</span>/<span>(</span><span>n</span>/<span>i</span><span>)</span>+<span>1</span>;
        <span>ans</span>+=<span>(</span><span>n</span>/<span>i</span><span>)</span>*<span>(</span><span>j</span>-<span>i</span><span>)</span>;
    <span>}</span>
    cout&lt;&lt;<span>ans</span>;
    <span>return</span> 0;
<span>}</span>

</pre>
    </div>
    <div class="t1"><img src="https://upload-bbs.miyoushe.com/upload/2024/09/29/198629752/09f0aab8de6e5cc0db270c73e691dab6_9079656361092462373.png" alt="时间复杂度">应尽量避免除法运算。还有循环如果能用while就用while。</div>
    <div class="t1">如果遇到10^6这样的大数据，能写快读就写快读。</div>
    <div class="t1">cin读取数字时可以把数字的符号一起读进去，也就是说，当你要读入一个数字表达式，那么可以直接用cin读入，连数字的正负判断都省了。</div>
    <div class="t1">补全程序当中遇到图论代码，如果遇到不认识的数组，就往“点”、“入度”、“出度”、“权值”上想，再偏也不会跑出这个考试范围。</div>
    <div class="t1">注意数据范围，要开 long long 的千万不要忘了开，否则只能拿一半的分！</div>
    <div class="t1">浮点数转整形会丧失精度，要看好代码中的类型转换以及是否出现了，函数要求传入int类型然而却传入了浮点类型。</div>
    <div class="t1">"7/sqrt(3)/2"和"7/2/sqrt(3)"不一样，前者会先变成浮点数再除以二，相比于后者精度更精确，二者存在明显的精度误差。</div>
    <div class="t1">b=a*q则，b是a的倍数，a是b的约数。</div>
    <div class="t1">由数字
        1,1,2,4,8,8 所组成的不同的 
        4 位数的个数是（）。<br><br>解：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;情况1：无重复的数字，1、2、4、8一共4个数字放在4个位置，：4×3×2=24<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;情况2：仅重复1，两个1，两个1的组合是6种：11xx,1x1x,1xx1,x11x,x1x1,xx11，两个x位置放3个不重复的数字，共3×2=6种，6×6=36种<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;情况3：仅重复8，两个8，同上，一共6×6=36种<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;情况4：重复两对，两个1和两个8。11xx,1x1x,1xx1,x11x,x1x1,xx11，一共6种。</div>
    <div class="t1">一些数字可以颠倒过来看，例如
        0,1,8 颠倒过来还是本身，
        6 颠倒过来是 
        9,9 颠倒过来看还是 
        6,其他数字颠倒过来都不构成数字。类似的，一些多位数也可以颠倒过来看，比如
        106 颠倒过来是
        901。假设某个城市的车牌只有 
        5 位数字，每一位都可以取 
        0 到 
        9。请问这个城市有多少个车牌倒过来恰好还是原来的车牌，并且车牌上的 
        5 位数能被 
        3 整除？（）<br><br>解：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第1、2位有（0、1、8、6、9）五个数字，第3位有（0、1、8）三个数字，第4、5位由第1、2位决定。由于0,1,8模3正好余0,1,2，所以其他位确定则第3位自然确定，共5*5=25种。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;举例：第1位选1，第5位必然是1；第2位选0，第4位必然是0；为能被3整除，第3位只能选8。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第1位可选5个数字，第2位也可选5个数字。5*5=25种。<br><br><p style="color: rgb(232, 0, 0);background-color: rgb(254, 241, 0);">注: 是车牌，车牌第一位可以是0</p></div>
    <div class="t1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果一个数的所有数字之和能被3整除，则这个数能被3整除。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果一个数的个位为0或5，则这个数能被5整除。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果一个数的所有数字之和能被9整除，则这个数能被9整除。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果一个数所有奇数位的数字相加减去所有偶数位的数字后的值能被11整除，那么这个数能被11整除。</div>
    <div class="t1">G是一个非连通无向图(没有重边和自环)，共有28条边，则该图至少有(  )个顶点。<br><br>解：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最优情况下是8个顶点的完全图，外加1个孤立顶点。即共有9个顶点。<img src="https://upload-bbs.miyoushe.com/upload/2024/09/23/198629752/de892d9f522b3dbd49e60532b643533c_4417491289934517107.png" alt="8个顶点的完全图">最后的边数就是1+2+3+4+5+6+7+8=28。</div>
    <div class="t1">在写并查集的代码时，并查集的初始化f[i]=i,其中i∈[a,b],则输入的一对节点(x,y)也应该在[a,b]范围内。因为如果超出这个范围，x的父节点会被默认指向为0或其他未知数字。</div>
    <div class="t1">没有路径压缩的并查集时间复杂度为线性的O(n),路径压缩后的为O(1)。</div>
    <div class="t1">如要补充，请联系管理员......</div>
    <div class="t1">如要补充，请联系管理员......</div>
    <div class="t1">如要补充，请联系管理员......</div>
    <div class="t1">如要补充，请联系管理员......</div>
    <div class="t1">如要补充，请联系管理员......</div>
    <div class="t1">如要补充，请联系管理员......</div>
    <div class="t1">如要补充，请联系管理员......</div>
    <div class="t1">如要补充，请联系管理员......</div>
    <div class="t1">如要补充，请联系管理员......</div>
    <div class="t1">如要补充，请联系管理员......</div>
    <div class="t1">如要补充，请联系管理员......</div>
    <div class="t1">如要补充，请联系管理员......</div>
    <div class="t1">如要补充，请联系管理员......</div>
    <div class="t1">如要补充，请联系管理员......</div>
    <div class="t1">如要补充，请联系管理员......</div>
    <div class="t1">如要补充，请联系管理员......</div>
    <!--  -->
    <!--  -->
    <!--  -->
</body>
<script src="./Volume.js"></script>
<script src="./Unit.js"></script>
<script src="./ChangSpanColor.js"></script>
</html>